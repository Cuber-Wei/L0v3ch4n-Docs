---
url: /article/uniapp-bluetooth/index.md
---
# uni-app蓝牙踩坑小记
> 之前接了个与硬件建立蓝牙通讯的项目，学到了一些 uni-app 蓝牙操作的知识，也踩了一些坑，特此记录一下防止忘记。

> \[!note]
> 在蓝牙模块调用时，采用的是 Promise 链式调用的形式，因此下文所提供的代码片段均为 Promise 形式。
>
> 文章参考：[uni-app 官网](https://zh.uniapp.dcloud.io/quickstart-hx.html)、
> [蓝牙](https://uniapp.dcloud.net.cn/api/system/bluetooth.html)、
> [低功耗蓝牙](https://uniapp.dcloud.net.cn/api/system/ble.html)

## Step1 初始化蓝牙适配器

使用`uni.openBluetoothAdapter()`函数初始化蓝牙适配器，`uni.getBluetoothAdapterState()`函数获取蓝牙适配器状态。

```javascript
// Step1 初始化蓝牙
function initBlue() {
  return new Promise((resolve, reject) => {
    // [!code word:openBluetoothAdapter]
    uni.openBluetoothAdapter({
      success(res) {
        console.log('初始化蓝牙成功')
        // [!code word:getBluetoothAdapterState]
        uni.getBluetoothAdapterState({
          success(r) {
            console.log('蓝牙状态', r.available)
            if (r.available) {
              resolve()
            }
            else {
              uni.showToast({
                title: '请开启蓝牙',
                icon: 'error',
                duration: 2000,
              })
              reject()
            }
          },
          fail(err) {
            uni.showToast({
              title: '请开启蓝牙',
              icon: 'error',
              duration: 2000,
            })
            reject()
          },
        })
      },
      fail(err) {
        console.log('初始化蓝牙失败')
        console.error(err)
        uni.showToast({
          title: '请开启蓝牙',
          icon: 'error',
          duration: 2000,
        })
        reject()
      },
    })
  })
}
```

## Step2 开始搜索附近的蓝牙设备

使用`uni.startBluetoothDevicesDiscovery()`函数启动搜索附近的蓝牙设备，`uni.onBluetoothDeviceFound()`函数定义搜索到新设备时的回调函数。

```javascript
// Step2 开始搜寻附近设备
function discovery() {
  return new Promise((resolve, reject) => {
    // [!code word:startBluetoothDevicesDiscovery]
    uni.startBluetoothDevicesDiscovery({
      success(res) {
        uni.showLoading({
          title: '正在搜索设备',
          icon: 'none',
        })
        // 开启监听回调
        // [!code word:onBluetoothDeviceFound]
        uni.onBluetoothDeviceFound((devices) => {
          let obj = devices.devices[0]
          console.log(obj.name)
          if (obj.name === conf.deviceName) {
            // 找到目标设备
            // 设置设备ID到同步缓存中
            uni.setStorageSync('deviceId', obj.deviceId)
            uni.hideLoading()
            resolve()
          }
        })
        console.log('搜索蓝牙外围设备完成', res)
      },
      fail(err) {
        console.log(err)
      },
    })
  })
}
```

## Step3 连接蓝牙设备

使用`uni.createBLEConnection(deviceId)`函数连接到目标蓝牙设备。

```javascript
// Step3 连接设备
function connect() {
  return new Promise((resolve, reject) => {
    // [!code word:createBLEConnection]
    uni.createBLEConnection({
      deviceId: uni.getStorageSync('deviceId'), // 设备id
      success(res) {
        console.log('连接成功')
        console.log(res)
        uni.showToast({
          title: '连接成功',
          icon: 'success',
        })
        // Step4 蓝牙连接成功后关闭蓝牙搜索
        stopDiscovery()
        resolve()
      },
      fail(err) {
        uni.showToast({
          title: '连接失败',
          icon: 'error',
        })
        console.log('蓝牙连接失败')
        console.log(err)
        reject()
      },
    })
  })
}
```

> \[!important]
> 由于 Setp2 中搜索蓝牙设备的功能比较耗费系统资源，因此在搜索并连接到设备后务必[停止搜索](#step4-停止搜索)。

## Step4 停止搜索

使用`uni.stopBluetoothDevicesDiscovery()`函数停止搜索附近的蓝牙设备。

```javascript
// Step4 停止搜索
function stopDiscovery() {
  // [!code word:stopBluetoothDevicesDiscovery]
  uni.stopBluetoothDevicesDiscovery({
    success(res) {
      console.log('停止成功')
      console.log(res)
    },
    fail(err) {
      console.log('停止失败')
      console.error(err)
    },
  })
}
```

## Step5 获取蓝牙设备所有服务

使用`uni.getBLEDeviceServices(deviceId)`函数获取蓝牙设备所有服务。

```javascript
// Step5 获取蓝牙设备所有服务
function getServices() {
  return new Promise((resolve, reject) => {
    // [!code word:getBLEDeviceServices]
    uni.getBLEDeviceServices({
      deviceId: uni.getStorageSync('deviceId'),
      success(res) {
        console.log(res)
        resolve()
      },
      fail(err) {
        console.error(err)
        reject()
      },
    })
  })
}
```

## Step6 获取蓝牙设备某个服务中所有特征值

使用`uni.getBLEDeviceCharacteristics(deviceId, serviceId)`函数获取蓝牙设备某个服务中所有特征值。

```javascript
// Step6 获取蓝牙设备某个服务中所有特征值
function getCharacteristics() {
  return new Promise((resolve, reject) => {
    // [!code word:getBLEDeviceCharacteristics]
    uni.getBLEDeviceCharacteristics({
      deviceId: uni.getStorageSync('deviceId'),
      serviceId: conf.serviceId,
      success(res) {
        console.log(res)
        resolve()
      },
      fail(err) {
        console.error(err)
        reject()
      },
    })
  })
}
```

## Step7 开启消息监听

使用`uni.notifyBLECharacteristicValueChange(deviceId, serviceId, characteristicId, ...)`函数开启消息监听。

```javascript
// Step7 开启消息监听
function notify(handleFunc) {
  // 这里传入一个回调函数，用于处理接收到的数据。
  // [!code word:notifyBLECharacteristicValueChange]
  uni.notifyBLECharacteristicValueChange({
    deviceId: uni.getStorageSync('deviceId'), // 设备id
    serviceId: conf.serviceId, // 监听指定的服务
    characteristicId: conf.characteristicId, // 监听对应的特征值
    state: true,
    success(res) {
      console.log(res)
      listenValueChange(handleFunc) // 开启监听消息变化，并传入回调函数。
    },
    fail(err) {
      console.error(err)
      uni.showToast({
        title: '监听失败',
        icon: 'error',
      })
    },
  })
}
```

## Step8 监听消息变化

使用`uni.onBLECharacteristicValueChange()`函数监听消息变化并根据需求做相应处理。

```javascript
// Step8 监听消息变化
function listenValueChange(handleFunc) {
  // 这里传入一个回调函数，用于处理接收到的数据。
  // [!code word:onBLECharacteristicValueChange]
  uni.onBLECharacteristicValueChange((res) => {
    let resArray = ab2array(res.value) // 拿到数字数组
    // Something to do...
  })
}
// ArrayBuffer 转数组
function ab2array(buffer) {
  return Array.from(new Uint8Array(buffer))
}
```

## Step9 发送数据

使用`uni.writeBLECharacteristicValue(deviceId, serviceId, characteristicId, value)`函数向蓝牙设备发送数据。

```javascript
// Step9 发送数据
function sendCommand(data) {
  // [!code word:writeBLECharacteristicValue]
  uni.writeBLECharacteristicValue({
    deviceId: uni.getStorageSync('deviceId'),
    serviceId: conf.serviceId,
    characteristicId: conf.characteristicId,
    // 注意：value 是ArrayBuffer类型，需要进行转换。
    value: array2ab(data), // [!code highlight]
    success(res) {
      console.log(`写入成功${res.errMsg}`)
    },
    fail(err) {
      console.error(err)
      uni.showToast({
        title: '指令发送失败',
        icon: 'error',
      })
    },
  })
}
// 数组转Arraybuffer
function array2ab(numbers) {
  // 创建一个ArrayBuffer，其大小等于数字数组的长度
  const buffer = new ArrayBuffer(numbers.length)
  // 创建一个Uint8Array视图来操作buffer
  const uint8View = new Uint8Array(buffer)
  // 将数字填充到Uint8Array中
  for (let i = 0; i < numbers.length; i++) {
    uint8View[i] = numbers[i]
  }
  // 返回ArrayBuffer
  return buffer
}
```

## Step10 断开蓝牙连接

使用`uni.closeBLEConnection(deviceId)`函数断开蓝牙连接。

```javascript
// Step10 断开蓝牙连接
function stopConnection() {
  return new Promise((resolve, reject) => {
    // [!code word:closeBLEConnection]
    uni.closeBLEConnection({
      deviceId: uni.getStorageSync('deviceId'), // 设备id
      success(r) {
        resolve()
      },
      fail(r) {
        console.log(r)
        reject()
      },
    })
  })
}
```

## 踩过的坑

### 为什么收到的数据是乱码（不符合预期）？

1. **协议文档写错了**：可能是文档看错了或者硬件那边把协议改了却没有更新文档。
2. **数据类型不对**：可能是收到的数据没有进行转换，直接在 ArrayBuffer 上面进行了数据解析操作。
3. **硬件波特率设置有问题**：可能是硬件那边的波特率设置有问题，导致数据收发不正常。经过~~测试~~踩坑，波特率设置成 9600 时，
   数据收发正常。

### 为什么采用 Promise 链的形式？

1. **逻辑清晰**：Promise 链的形式可以让代码看起来更加清晰，易于理解。
2. **避免上下文影响**
   ：一些函数的调用会影响到下文，若只是按顺序结构编写逻辑则有可能发生[获取服务](#step5-获取蓝牙设备所有服务)
   先于[蓝牙连接](#step3-连接蓝牙设备)的情况，导致程序报错。

---

---
url: /CTF/CryptoFunctions/index.md
---
发现有些博客里面写的不是很全，而且自己也懒得去找。

一个菜鸡一边学一边补充的，没写完。

## Crypto.Util.number

1. $int\rightarrow bytes$

```python
# long_to_bytes()
'''
将整数转化成byte字符串
:param	要转化的数字(int)
:return	转化结果(byte)
'''
>>> long_to_bytes(112615676672893)
b'flag{}'
```

2. $bytes\rightarrow int$

```python
# bytes_to_long()
'''
将byte字符串转化为整数
:param	要转化的二进制字符串(byte)
:return	转化结果(int)
'''
>>> bytes_to_long(b'flag{}')
112615676672893
```

3. 获取指定二进制位数的质数

```python
# getPrime()
'''
获取随机的指定位数（二进制位）的质数
:param	质数的位数(int)
:return	对应位数的质数(int)
'''
>>> getPrime(16)
62297
```

4. 计算乘法逆元

```python
# inverse()
'''
计算乘法逆元
:param	原数(int)
:param	模数(int)
:return	原数的乘法逆元(int)，若不存在则报错
'''
>>> inverse(2,9)
5
```

5. 最大公约数

```python
# GCD()
'''
计算两数的最大公约数
:param	数字一(int)
:param	数字二(int)
:return	最大公约数(int)
'''
>>> GCD(114, 514)
2
```

## gmpy2

1. 开 n 次方

```python
# iroot()
'''
开n次方
:param	被开方数(int)
:param	方次n(int)
:return	(开方结果（向下取整）, 是否开尽)(tuple)
'''
>>> gmpy2.iroot(16, 4)
(mpz(2), True)
>>> gmpy2.iroot(16, 5)
(mpz(1), False)
```

2. 最大公约数

```python
# gmpy2.gcd()
'''
计算两数的最大公约数
:param	数字一(int)
:param	数字二(int)
:return	最大公约数(int)
'''
>>> gmpy2.gcd(24, 20)
mpz(4)
```

3. 拓展欧几里得定理

```python
# gmpy2.gcdext()
'''
计算两数的最大公约数及对应的a, b系数
:param	数字一(int)
:param	数字二(int)
:return	(最大公约数, a, b)(tuple)
'''
>>> gmpy2.gcdext(114, 514)
(mpz(2), mpz(-9), mpz(2))
```

4. 高次模幂

```python
# gmpy2.powmod()
'''
计算高次模幂。
:param	底数(int)
:param	指数(int)
:param	模数(int)
:return	计算结果(int)
'''
>>> gmpy2.powmod(114, 514, 1919810)
mpz(290606)
```

5. 下一个质数

```python
# gmpy2.next_prime()
'''
找到下一个质数。
:param	基数(int)
:return	下一个质数(int)
'''
>>> gmpy2.next_prime(4)
mpz(5)
```

## sagemath

\~~先摸了~~

---

---
url: /CTF/EasyLattice/index.md
---
# 简单的格密码问题
利用格基约化的技术，我们可以求解一些加密脚本中含未知数的问题。

格密码一般是基于两个格上的难题建立的（**SVP**和**CVP**）

> \[!note]
> 这边引入一个定理（**Hermite 定理**）：
> 这个定理揭示了格中最短向量的大概长度。
> 定理本体：对$n$维的格$L$，都包含一个非零向量$\mathbf{v}\in L$，满足：
>
> $$
> ||\mathbf{v}||\le\sqrt{n}det(L)^{1/n}
> $$
>
> 衍生出**Hermite 常数**$\gamma\_n$，有：
>
> $$
> ||\mathbf{v}||^2\le\gamma\_ndet(L)^{2/n}
> $$
>
> $$
> \frac{n}{2\pi e}\le\gamma\_n\le\frac{n}{2\pi e}
> $$

格密码的解题思路一般为：

1. 列出题目给出的一些关系式，明确未知数和已知数。
2. 对关系式进行变化，将关系式转化成向量相乘的形式。
3. 构造格，用 Hermite 定理进行大小验证，若不满足，考虑重新造格。
4. 格基约化求解，得到未知数。

## 一

```python
from Crypto.Util.number import *
import random

flag = b'******'
m = bytes_to_long(flag)

a = getPrime(1024)
b = getPrime(1536)

p = getPrime(512)
q = getPrime(512)
r = random.randint(2**14, 2**15)
assert ((p-r) * a + q) % b < 50

c = pow(m, 65537, p*q)

print(f'c = {c}')
print(f'a = {a}')
print(f'b = {b}')
```

我们可以从题目里拿到以下关系：

$$
(p-r)\cdot a+q+k\cdot b = x < 50
$$

$$
c\equiv m^{65537}\pmod{(pq)}
$$

$a,b$是已知的，$p,q,r$是未知的。然后后面的加密是正常的 RSA 加密手法。

看看大小：

$$
|a|=2^{1024},|b|=2^{1536},|p|=2^{512},|q|=2^{512},2^{14}<|r|<2^{15}
$$

稍微移一下项，我们忘格子的形式上靠：

$$
(p-r)\cdot a+k\cdot b=x-q
$$

考虑构造以下格子：

$$
L=\begin{bmatrix}
1 & a\\
0 & b
\end{bmatrix}
$$

这样可以找到：

$$
(p-r,k)L=(p-r,x-q)=\mathbf{v}
$$

计算 $\mathbf{v}$ 的大小：

$$
||\mathbf{v}||=\sqrt{|p-r|^2+|x-q|^2}\approx\sqrt2\cdot2^{512}<\sqrt2\cdot |b|^{1/2}
$$

大小可以，开归！然后就是正常的 RSA，进行一个爆破的解密。

**exp:**

```python
from Crypto.Util.number import *

c =
a =
b =
e = 65537

L = Matrix(ZZ, [[1, a],
                [0, b]])

p, q = map(abs, L.LLL()[0])

flag = False
for r in range(2**14, 2**15):
    for x in range(50):
        P = p + r
        Q = q + x
        phi = (P - 1)*(Q - 1)
        if gcd(phi, e) != 1:
            continue
        d = inverse_mod(e, phi)
        m = power_mod(c, d, P*Q)
        if b'NSSCTF' in long_to_bytes(int(m)):
            print(long_to_bytes(int(m)))
            flag = True
            break
    if flag:
        break
```

## 二

```python
from Crypto.Util.number import *

flag = b'******' # uuid形式
flag = bytes_to_long(flag)

p = getPrime(1024)
r = getPrime(175)
a = inverse(r, p)
a = (a*flag) % p

print(f'a = {a}')
print(f'p = {p}')
```

老样子，拿关系式：

$$
|p|=2^{1024},|r|=2^{175}
$$

$$
a\_0\cdot r=k\_1\cdot p + 1
$$

$$
a=a\_0\cdot m+k\_2\cdot p
$$

$a,p$是已知的，$r,a\_0,m$是未知。

移项，构造式子：

$$
ma\_0r=mk\_1p+m
$$

$$
(a-k\_2p)r=K\_1p+m
$$

$$
ar=kp+m
$$

$$
ra+kp=m
$$

考虑构造格：

$$
L=\begin{bmatrix}
1 & a\\
0 & p
\end{bmatrix}
$$

这样就有：

$$
(r,k)L=(r,m)=\mathbf{v}
$$

看看大小：$m$大概$128$bit 大小。

$$
||\mathbf{v}||=\sqrt{|r|^2+|m|^2}\approx 2^{176}<|p|^{1/2}=2^{512}
$$

还说什么呢，开归！

**exp:**

```python
from Crypto.Util.number import *

a =
p =

L = Matrix(ZZ, [[1, a],
                [0, p]])
r, m = L.LLL()[0]
print(long_to_bytes(abs(m)))
```

## 三

```python
from Crypto.Util.number import *
from gmpy2 import *

flag = b'******'
m = bytes_to_long(flag)

assert m.bit_length() == 351
p = getPrime(1024)
b = getPrime(1024)
c = getPrime(400)

a = (b*m + c) % p

print(f'a = {a}')
print(f'b = {b}')
print(f'p = {p}')
```

拿条件：

$$
a=bm+c+kp
$$

$$
a-bm-kp=c
$$

可以构造格：

$$
L=\begin{bmatrix}
1 & 0 & a\\
0 & 1 & -b\\
0 & 0 & p
\end{bmatrix}
$$

有：

$$
(1,m,-k)L=(1,m,c)=\mathbf{v}
$$

看大小：

$$
||\mathbf{v}||=\sqrt{1+|m|^2+|c|^2}\approx 2^{401}>|p|^{1/3}=2^{341}
$$

归不了一点！这下不得不优化一下凑个数据了：

先看看差多少：401-341=60，算上三次方得补上 60\*3=180。这个补充对向量大小影响不大，这里考虑冗余先补个 200 试试看。

$$
L=\begin{bmatrix}
2^{200} & 0 & a\\
0 & 1 & -b\\
0 & 0 & p
\end{bmatrix}
$$

看大小：

$$
||\mathbf{v}||=\sqrt{2^{200\times2}+|m|^2+|c|^2}\approx 2^{401}<|2^{200}p|^{1/3}=2^{408}
$$

格基规约，启动！

**exp:**

```python
from Crypto.Util.number import *

a =
b =
p =

L = Matrix(ZZ, [[2**200, 0, a],
                [0, 1, -b],
                [0, 0, p]])
_, m, _ = L.LLL()[0]
print(long_to_bytes(abs(m)))
```

---

---
url: /CTF/Lattice/index.md
---
# 格密码
## 什么是格(Lattice)

在一个线性空间内确定两个线性无关向量，作为基底，它们进行线性组合后扫过的空间就是格。

![image-20230703205526008](https://file.l0v3ch4n.top/L0v3ch4n-Docs-images/CTF/LatticeCrypto/image-20230703205526008.png)

在格密码中，我们一般设置基底前的系数为整数，因此形成的格都是离散的。

![image-20230703205601877](https://file.l0v3ch4n.top/L0v3ch4n-Docs-images/CTF/LatticeCrypto/image-20230703205601877.png)

格在密码学中很有趣因为我们很少处理实数，而它们给我们提供了很多处理整数的工具。

就像向量空间一样，格也可以用不同的基表示为矩阵来描述。不过与矩阵表示习惯不同的是，我们在格理论中常把基向量作为矩阵的行向量。

下面定义一个格 L${\overrightarrow{b\_1},\overrightarrow{b\_2},\dots\overrightarrow{b\_\omega}}$的行列式：

$$
det(L):=\prod\_{i=1}^{\omega}||\overrightarrow{b\_i}||
$$

\~~(其实就是矩阵的行列式)~~

## LLL 格基约化算法

**Lenstra-Lenstra-Lov´asz**格基约简算法是一种一步一步的演算，可以在多项式时间内减少格基。晶格保持不变，但根据某些定义，其新基的行向量“更小”

\*\*Definition 1:\*\*设 L 是一个基 B 的格，在 L 的基 B 上应用 LLL 算法产生了 L 的一个新基:$B'={b1,\dots,b\_n}$满足以下条件：

$$
\forall1\le j\<i\le n~\text{有}~|\mu\_{ij}|\le\frac{1}{2}\\
\forall1\le i\<n~\text{有}~\delta\cdot||\overrightarrow{b\_i}||^2\le||\mu\_{i+1,i}\cdot\overrightarrow{b\_i}+\overrightarrow{b\_{i+1}}||\\
\text{同时}~\mu\_{i,j}=\frac{b\_i\cdot\overrightarrow{b\_j}}{\overrightarrow{b\_j}\cdot\overrightarrow{b\_j}}~\text{且}~\overrightarrow{b\_1}=b\_1(\text{正交化})
$$

![image-20230703211709280](https://file.l0v3ch4n.top/L0v3ch4n-Docs-images/CTF/LatticeCrypto/image-20230703211709280.png)

## LLL 的性质

LLL 给出了最短向量问题的近似解。这对我们很有用，因为如果我们把晶格基的行向量看作多项式的系数向量。我们可以找到系数“特别小”的多项式的线性组合。

设 L 是一个维数为 n 的格。在多项式时间内，LLL 算法输出约简基向量$v\_i$，对于$1\le i\le n$，满足:

$$
||v\_1||\le||v\_2||\le\dots\le||v\_i||\le2^{\frac{n(n-1)}{4(n+1-i)}}\cdot det(L)^{\frac{1}{n+1-i}}
$$

由此，我们可以通过修改格基的维数和行列式来修改向量的界。

---

---
url: /CTF/LatticePractise/index.md
---
# Lattice练习
题目：

```python
from Crypto.Util.number import *

flag = b'******'
m = bytes_to_long(flag)

p = getPrime(512)
s = [getPrime(32) for i in range(3)]
a = [getPrime(512) for i in range(3)]

c = (a[0]*s[0]**2*s[1]**2 + a[1]*s[0]*s[2]**2 + a[2]*s[1]*s[2]) % p

flag = m*s[0]*s[1]*s[2]
print(f'c = {c}')
print(f'flag = {flag}')
print(f'a = {a}')
print(f'p = {p}')
```

拿来检测 Lattice 的学习效果还是不错的。

先拿关系式：

$$
c = a\_0s\_0^2s\_1^2 + a\_1s\_0s\_2^2 + a\_2s\_1s\_2+kp
$$

$$
enc = ms\_0s\_1s\_2
$$

分析已知和未知条件：

|   已知    | 未知  |
| :-------: | :---: |
|   $a\_i$   | $s\_i$ |
| $c,p,enc$ |       |

思路就是求出$s\_0,s\_1,s\_2$的值。

处理这种关系式，为了简化式子，我们选择把次数少的拎出来：

$$
a\_2s\_1s\_2=c-a\_0s\_0^2s\_1^2-a\_1s\_0s\_2^2+kp
$$

把系数变成 1：

$$
s\_1s\_2=a\_2^{-1}c-a\_2^{-1}a\_0s\_0^2s\_1-a\_2^{-1}a\_1s\_0s\_2+kp
$$

然后就可以构造格了：

$$
L=\begin{bmatrix}
1 & 0 & 0 & -a\_0a\_2^{-1}\\
0 & 1 & 0 & -a\_1a\_2^{-1}\\
0 & 0 & 1 & ca\_2^{-1}\\
0 & 0 & 0 & p\\
\end{bmatrix}
$$

这样就有：

$$
(s\_0^2s\_1^2, s\_0s\_2^2, 1, k)L=(s\_0^2s\_1^2, s\_0s\_2^2, 1, s\_1s\_2)=\mathbf{v}
$$

看看长度：

$$
||\mathbf{v}||=\sqrt{|s\_0^2s\_1^2|^2+|s\_0s\_2^2|^2+1^2+|s\_1s\_2|^2}\approx 2^{129}>|p|^{1/4}=2^{128}
$$

显然这规约不了一点，但是我们可以将对角线配平，这样会好一点。

目前向量$\mathbf{v}$的对角线大小为：

$$
(128, 96, 1, 64)
$$

我们就乘上这样一个矩阵：

$$
M=\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & 2^{32} & 0 & 0\\
0 & 0 & 2^{128} & 0\\
0 & 0 & 0 & 2^{64}\\
\end{bmatrix}
$$

这样，

$$
||\mathbf{v}\*M||=2^{130}<|2^{32+128+64}p|^{1/4}=2^{184}
$$

就可以规约出来了。

**exp:**

```python
from Crypto.Util.number import *

c =
flag =
a = []
p =

ia = inverse_mod(a[2], p)

L = Matrix(ZZ, [[1, 0, 0, -a[0]*ia%p],
                [0, 1, 0, -a[1]*ia%p],
                [0, 0, 1,     c*ia%p],
                [0, 0, 0,         p]])
L *= diagonal_matrix(ZZ, [1, 2^32, 2^128, 2^64])

v = L.LLL()[0]
s0s1 = isqrt(abs(v[0]))
s1s2 = abs(v[3]) >> 64
s1 = gcd(s0s1, s1s2)
s0 = s0s1 // s1
s2 = s1s2 // s1

flag = flag // s0 // s1 // s2
print(long_to_bytes(flag))
```

---

---
url: /CTF/NewStar2022Week1ezrsa/index.md
---
## 题干

```python
assert len(flag) % 5 == 0

cnt = len(flag) // 5

flags = [flag[cnt*i:cnt*(i+1)] for i in range(5)]
```

可知 flag 分五段。

## 第一段

```python
m = bytes_to_long(message)
c = 22160015525054597533062795679117215923801827397299805735087138192137742945881204146337349060934854888054628153923021387981306839951210090523829296521835965212118849043671673133979884712755090374758002677916820953359774554825569218497687506468472278309097929775388010403607769802840990547048001743970754496905
p = 6962443023774446497102092246794613339314677593117417573764609329949026862782472380488956732038459060928443992561763464365758383525259954798321350043810351
q = 9631855759661411029901156175243744760977799976661519182223576693685069000499866459636568713055906075171480855575061732016121299027658733834671035383233163
e = 0x10001
```

\*\*level1 \*\*就是常规的 RSA 解密

```python
import Crypto.Util.number
import gmpy2
n = p*q
phi_n = (p-1)*(q-1)
d = gmpy2.invert(e, phi_n)
m = pow(c, d, n)
```

## 第二段

```python
c = 17250922799297131008803303235771955129
n = 134097988095851988085603926250918812377
e = 0x10001
m = bytes_to_long(message)
```

**level2** p,q 没给出,我们就是通过网站分解质因数得到 p,q.

```python
import Crypto.Util.number
import gmpy2
n = p*q
phi_n = (p-1)*(q-1)
d = gmpy2.invert(e, phi_n)
m = pow(c, d, n)
```

## 第三段

```python
c = 2776571135646565181849912433877522437622755332262910824866791711
n = 85793694792655420934945863688968944466300304898903354212780512650924132933351787673979641944071634528676901506049360194331553838080226562532784448832916022442020751986591703547743056267118831445759258041047213294368605599719242059474324548598203039032847591828382166845797857139844445858881218318006747115157
e = 3
```

**level3** e 比较小,是低加密指数攻击

```python
import gmpy2
import binascii
i = 0
while True:
    if gmpy2.iroot((c+i*n), e)[1]:
        m = gmpy2.iroot((c+i*n), e)[0]
        break
    i += 1
```

## 第四段

```python
c = 68588738085497640698861260094482876262596289469248772328560280530093163764972313090939471997156632421517452790632223565521726590730640805290182026911025142051864898712501214753986865172996090706657535814234291235489829621372021092488300236623525366939477695283380634188510950335639019458758643273802572617191
e = 51999725233581619348238930320668315462087635295211755849675812266270026439521805156908952855288255992098479180003264827305694330542325533165867427898010879823017054891520626992724274019277478717788189662456052796449734904215067032681345261878977193341769514961038309763898052908572726913209883965288047452751
n = 68816697240190744603903822351423855593899797203703723038363240057913366227564780805815565183450516726498872118491739132110437976570592602837245705802946829337567674506561850972973663435358068441037127926802688722648016352967768929007662772115485020718202683004813042834036078650571763978066558718285783045969

```

**level4** e 很大,是低解密指数攻击

```python
import gmpy2
import binascii
import RSAwienerHacker
d = RSAwienerHacker.hack_RSA(e, n)
m = gmpy2.powmod(c, d, n)
```

## 第五段

```python
c = 1135954814335407362237156338232840769700916726653557860319741136149066730262056907097728029957898420630256832277578506404721904131425822963948589774909272408535427656986176833063600681390871582834223748797942203560505159946141171210061405977060061656807175913366911284450695116982731157917343650021723054666494528470413522258995220648163505549701953152705111304471498547618002847587649651689203632845303117282630095814054989963116013144483037051076441508388998829
hint = 611144874477135520868450203622074557606421849009025270666985817360484127602945558050689975570970227439583312738313767886380304814871432558985582586031211416586296452510050692235459883608453661597776103386009579351911278185434163016083552988251266501525188362673472772346212970459561496301631587043106524741903627979311997541301471894670374945556313285203740782346029579923650160327646876967315182335114575921178144825057359851607166387868294019144940296084605930
n = 1232865496850144050320992645475166723525103370117149219196294373695624167653495180701004894188767069545579706264513808335877905149818445940067870026924895990672091745229251935876434509430457142930654307044403355838663341948471348893414890261787326255632362887647279204029327042915224570484394917295606592360109952538313570951448278525753313335289675455996833500751672463525151201002407861423542656805624090223118747404488579783372944593022796321473618301206064979
n = p * p * q
e = 0x10001
d = inverse(e, p * (p-1) * (q-1))
assert m < n
c = pow(m, e, n)
hint = pow(d, e, n)
```

**level5** p q 无法啊直接通过 n 分解出来. 但仔细分析 n 和 phi(n)我们可以发现公约数是 p,那么我们的突破点就在这.
通过题目可以发现直接求出 phi(n)是不切实际的,那我们只需要让 phi(n)存在于某一个式子即可.

推导:

$$
n=p\times p\times q\newline
\text{则}\phi (n)=p\times (p-1)\times (q-1)\newline
p=gcd(n,\phi (n)\newline
\text{由题干知}:\newline
ed\equiv 1(\bmod \phi (n))\Leftrightarrow ed=1+K\_{1}\phi (n)\newline
hint=d^{e}\bmod n \Leftrightarrow d^{e}=hint +K\_{2}n\newline
\text{经代换可得}:\newline
(ed)^{e}\equiv 1\bmod \phi (n)\Leftrightarrow e^{e}\times d^{e}=1+K\_{3}\phi (n)\newline
\text{两边同时对}n\text{取模,化简得}:\newline
e^{e}\times hint\equiv 1+K\_{3}\phi (n)(\bmod n)\newline
\text{最后得到}:\newline
K\phi(n)=(x\times hint -1)\bmod n,\newline
\text{其中}x=e^{e}\bmod n
$$

```python
import math
import gmpy2
import Crypto.Util.number
# 求出e**e模n
x = pow(e, e, n)

a = (x*hint-1) % n
p = math.gcd(a, n)
q = n//p**2
phi = (p - 1) * (q - 1)*p
d = gmpy2.invert(e, phi)
m = pow(c, d, n)
```

## 完整 exp

```python
'''
assert len(flag) % 5 == 0

cnt = len(flag) // 5

flags = [flag[cnt*i:cnt*(i+1)] for i in range(5)]
'''
def sent1():
    # 正常的RSA解密
    # 公钥私钥都有了
    c = 22160015525054597533062795679117215923801827397299805735087138192137742945881204146337349060934854888054628153923021387981306839951210090523829296521835965212118849043671673133979884712755090374758002677916820953359774554825569218497687506468472278309097929775388010403607769802840990547048001743970754496905
    p = 6962443023774446497102092246794613339314677593117417573764609329949026862782472380488956732038459060928443992561763464365758383525259954798321350043810351
    q = 9631855759661411029901156175243744760977799976661519182223576693685069000499866459636568713055906075171480855575061732016121299027658733834671035383233163
    e = 0x10001
    import Crypto.Util.number
    import gmpy2
    n = p*q
    phi_n = (p-1)*(q-1)
    d = gmpy2.invert(e, phi_n)
    m = pow(c, d, n)
    return Crypto.Util.number.long_to_bytes(m)

def sent2():
    # 没有p,q,但是n比较小
    # 可以先分解n得到p,q
    c = 17250922799297131008803303235771955129
    p = 10094271714305059493
    q = 13284562957208247589
    e = 0x10001
    import Crypto.Util.number
    import gmpy2
    n = p*q
    phi_n = (p-1)*(q-1)
    d = gmpy2.invert(e, phi_n)
    m = pow(c, d, n)
    return Crypto.Util.number.long_to_bytes(m)

def sent3():
    # 低指数加密攻击-->爆破
    # 常见的低指数加密是e=3
    # ①当 m^3 < n 时 ， c = m^3 ， 直 接 将 c 开 三 次 方 即 可 得 到 m
    # ②当 m^3 > n 时 ， c = m^3 - i ∗ n ， 只 要 找 到 i ，
    # 使 得 c + i n 能 够 开 三 次 方 即 可 得 到m
    c = 2776571135646565181849912433877522437622755332262910824866791711
    n = 85793694792655420934945863688968944466300304898903354212780512650924132933351787673979641944071634528676901506049360194331553838080226562532784448832916022442020751986591703547743056267118831445759258041047213294368605599719242059474324548598203039032847591828382166845797857139844445858881218318006747115157
    e = 3
    import gmpy2
    import binascii
    i = 0
    while True:
        if gmpy2.iroot((c+i*n), e)[1]:
            m = gmpy2.iroot((c+i*n), e)[0]
            break
        i += 1
    return binascii.unhexlify(hex(m)[2:])

def sent4():
    # 题中e很大，故可知是低解密指数攻击
    # hacker模块利用
    c = 68588738085497640698861260094482876262596289469248772328560280530093163764972313090939471997156632421517452790632223565521726590730640805290182026911025142051864898712501214753986865172996090706657535814234291235489829621372021092488300236623525366939477695283380634188510950335639019458758643273802572617191
    e = 51999725233581619348238930320668315462087635295211755849675812266270026439521805156908952855288255992098479180003264827305694330542325533165867427898010879823017054891520626992724274019277478717788189662456052796449734904215067032681345261878977193341769514961038309763898052908572726913209883965288047452751
    n = 68816697240190744603903822351423855593899797203703723038363240057913366227564780805815565183450516726498872118491739132110437976570592602837245705802946829337567674506561850972973663435358068441037127926802688722648016352967768929007662772115485020718202683004813042834036078650571763978066558718285783045969
    import gmpy2
    import binascii
    import RSAwienerHacker
    d = RSAwienerHacker.hack_RSA(e, n)
    m = gmpy2.powmod(c, d, n)
    return binascii.unhexlify(hex(m)[2:])

def sent5():
    # 这一道题目需要进行模运算。p q无法啊直接通过n分解出来，
    # 但仔细分析n和phi（n）我们可以发现公约数是p，那么我们的突破点就在这。
    # 通过题目可以发现直接求出phi（n）是不切实际的，那我们只需要让phi存在于某一个式子即可
    n = 1232865496850144050320992645475166723525103370117149219196294373695624167653495180701004894188767069545579706264513808335877905149818445940067870026924895990672091745229251935876434509430457142930654307044403355838663341948471348893414890261787326255632362887647279204029327042915224570484394917295606592360109952538313570951448278525753313335289675455996833500751672463525151201002407861423542656805624090223118747404488579783372944593022796321473618301206064979
    hint = 611144874477135520868450203622074557606421849009025270666985817360484127602945558050689975570970227439583312738313767886380304814871432558985582586031211416586296452510050692235459883608453661597776103386009579351911278185434163016083552988251266501525188362673472772346212970459561496301631587043106524741903627979311997541301471894670374945556313285203740782346029579923650160327646876967315182335114575921178144825057359851607166387868294019144940296084605930
    c = 1135954814335407362237156338232840769700916726653557860319741136149066730262056907097728029957898420630256832277578506404721904131425822963948589774909272408535427656986176833063600681390871582834223748797942203560505159946141171210061405977060061656807175913366911284450695116982731157917343650021723054666494528470413522258995220648163505549701953152705111304471498547618002847587649651689203632845303117282630095814054989963116013144483037051076441508388998829
    e = 0x10001
    import math
    import gmpy2
    import Crypto.Util.number
    # 求出e**e模n
    x = pow(e, e, n)
    a = (x*hint-1) % n
    p = math.gcd(a, n)
    q = n//p**2
    phi = (p - 1) * (q - 1)*p
    d = gmpy2.invert(e, phi)
    m = pow(c, d, n)
    return Crypto.Util.number.long_to_bytes(m)

print(sent1()+sent2()+sent3()+sent4()+sent5())
# flag:
# b'flag{W0w_U_ar3_re4L1y_g0Od_4t_m4th_4nD_RSA!!}'
```

---

---
url: /CTF/NTRU/index.md
---
## 参数

```
- 模 p
- 私钥 $(f,g)$
- 公钥 $h=f^{-1}g\pmod p$
- 临时密钥 r
```

## 加密

$$
c\equiv rh+m\equiv rf^{-1}g+m\pmod p
$$

## 解密

$$
fc\equiv rg+mf\equiv fm\pmod g
$$

再乘上$f^{-1}$就是 m 了。

**参数大小**

显然当$rg+fm\<p,m\<g$时才能正常解密。

考虑格

$$
L=\begin{bmatrix}1\&h\0\&p\end{bmatrix}
$$

同时我们有$hf+kp=g$，
此时我们发现$(f,g)$时格中的一个格点。因为：

$$
(f,k)L=(f,fh+kp)=(f,g)
$$

因此，如果我们能够找到$(f,p)$，那我们就可以确定$(f,g)$。

**更多条件**

$$
f<\frac{p^{1/2}}{2},g<\frac{p^{1/2}}{2},m<\frac{p^{1/2}}{4},r<\frac{p^{1/2}}{2}
$$

此时我们可以发现向量$\mathbf{b}=(f,g)$的长度（欧几里得范数）为：

$$
||\mathbf{b}||=\sqrt{f^2+g^2}<\sqrt{\frac{p}{2}}
$$

这条向量就是在$L$这个格下的最短向量，我们可以求解这个 SVP 问题得到$f,g$。

## 例题

```python
from Crypto.Util.number import *

p = getPrime(1024)

f = getPrime(400)
g = getPrime(512)
r = getPrime(400)

h = inverse(f, p) * g % p

m = b'******'
m = bytes_to_long(m)

c = (r*h + m) % p
```

**exp：**

```python
from Crypto.Util.number import *

p =
h =
c =

# 构造格子
L = matrix([[1, h],
            [0, p]])
# 格基约化拿到f, g
f, g = L.LLL()[0]
# 计算fm
fm = c * f % p % g
# 乘f逆得到m
m = fm * inverse(f, g) % g
print(long_to_bytes(m))
# NSSCTF{94068324-38bb-410b-b464-e1b8baf6b358}
```

---

---
url: /CTF/Paillier/index.md
---
# Paillier：最著名的半同态加密方案
## 何为同态加密（HE）？

HE 是一种特殊的加密方法，它允许直接对加密数据执行计算，如加法和乘法，而计算过程不会泄露原文的任何信息。计算的结果仍然是加密的，拥有密钥的用户对处理过的密文数据进行解密后，得到的正好是处理后原文的结果

根据支持的计算类型和支持程度，同态加密可以分为以下三种类型：

* **半同态加密（Partially Homomorphic Encryption, PHE）**：只支持加法或乘法中的一种运算。其中，只支持加法运算的又叫
  **加法同态加密（Additive Homomorphic Encryption, AHE）**；

* **部分同态加密（Somewhat Homomorphic Encryption, SWHE）**：可同时支持加法和乘法运算，但支持的计算次数有限；

* **全同态加密（Fully Homomorphic Encryption, FHE）**：支持任意次的加法和乘法运算。

在同态加密概念被 Rivest 在 1978 年首次提出后，学术界出现了多个支持 PHE 的方案，如 RSA、GM、Elgamal、Paillier。此后，SWHE 方案也相继问世，如 BGN。关于 FHE 如何实现，学术界在很长的时间都没有答案。直到 2009 年，Gentry 使用理想格构造了第一个 FHE 方案，轰动了整个学术界，并引发了学者们对于 FHE 方案构造的研究热潮。此后相继涌现出多个优秀的 FHE 方案，包括 BFV、BGV、CKKS 等，以及多个优秀的开源算法库如 SEAL、HELib 等。

## Paillier 简介

Paillier 是一个**支持加法同态的公钥密码系统**。由于其效率较高、安全性证明完备的特点，在各大顶会和实际应用中被广泛使用，是隐私计算场景中最常用的 PHE 实例化方案之一。

## Paillier 方案原理

### 前置知识

**加法同态加密定义**

在描述具体方案之前，我们先定义加法 PHE。首先列举方案具有的所有算法。

* `KeyGen()`：密钥生成算法。用于产生加密数据的公钥 PK（Public Key）和私钥 SK（Secret Key），以及一些公开常数 PP（Public Parameter）；

* `Encrypt()`：加密算法。使用 PK 对用户数据 Data 进行加密，得到密文 CT（Ciphertext）；

* `Decrypt()`：解密算法。用于解密得到数据原文 PT（Plaintext）。

HE 除了加解密以外，还具有在密文上进行处理的能力，所以还应拥有“处理”算法。对于加法 PHE，支持的算法有同态加以及同态标量乘（标量乘法可看作多次加法）。

* `Add()`：同态加算法。输入两个 CT 进行同态加运算。

* `ScalaMul()`：同态标量乘算法。输入一个 CT 和一个标量 PT，计算 CT 的标量乘结果。

### Paillier 方案描述

原版 Paillier 方案详见论文: Paillier P. Public-key cryptosystems based on composite degree residuosity classes\[C]
//International conference on the theory and applications of cryptographic techniques. Springer, Berlin, Heidelberg,
1999: 223-238

**密钥生成**

第一形式：

1. 随机选择两个大素数$p$, $q$满足 $g c d ( p q , ( p − 1 ) ( q − 1 ) ) = 1$，且满足$p$,$q$长度相等。
2. 计算$n=pq$及$\lambda=lcm(p-1,q-1)=\frac{(p-1)(q-1)}{gcd(p-1,q-1)}$，这里$lcm$表示最小公倍数，$|n|$为$n$的比特长度。
3. 选择随机整数$g\leftarrow Z^\*\_{n^2}$即$0\<g\<n^2$。
4. 定义$L$函数：$L(x)=\frac{x-1}{n}$，计算$\mu=\[L(g^\lambda~mod~n^2)]^{-1}\_n$。

公钥$(n,g)$，私钥$(\lambda, \mu)$。

第二形式（优化参数选择）：

其余参数不变，主要改变$g$，$\lambda$，$\mu$的定义。

$$
g=n+1\\
\lambda=\phi(n)=(p-1)(q-1)\\
\mu=\[\phi(n)]^{-1}\_n
$$

**加密**

1. 输入明文信息$m$，满足$0\le m\<n$。
2. 选择随机整数$r$，满足$0\le r\<n$且$r\in Z^\*\_m$。
3. 计算密文$c=g^mr^n~mod~n^2$。

**解密**

1. 输入密文$c$，满足$c\in Z^\*\_{n^2}$。
2. 计算明文信息$m=L(c^\lambda~mod~n^2)\cdot\mu~mod~n$。

**同态加**

对密文$c\_1$，$c\_2$，计算$c=c\_1\cdot c\_2~mod~n^2$。

**同态标量乘**

对密文$c\_1$和标量$a$，计算$c=c\_1^a~mod~n^2$。

**安全性**

Paillier 方案满足加密方案的标准安全定义：语义安全，即在选择明文攻击下的密文的不可区分性（IND-CPA）。直观地说，就是密文不会泄露明文中的任意信息。方案安全性可以归约到判定性合数剩余假设（Decisional
Composite Residuosity Assumption,
DCRA），即给定一个合数 n 和整数 z，判定 z 是否在 n^2 下是否是 n 次剩余是困难的。这个假设经过了几十年的充分研究，到目前为止还没有多项式时间的算法可以攻破，所以 Paillier 加密方案的安全性被认为相当可靠。

## CTF 例题

DASCTF-2020 四月-Crypto-not\_RSA

```python
from Crypto.Util.number import getPrime as getprime, long_to_bytes, bytes_to_long, inverse
from secret import flag, p, q
from sympy import isprime, nextprime
import random

m=bytes_to_long(flag)
n=p*q
g=n+1
r=random.randint(1,n)

c=(pow(g,m,n*n)*pow(r,n,n*n))%(n*n)

print "c=%d"%(c)
print "n=%d"%(n)

'''
c=29088911054711509252215615231015162998042579425917914434962376243477176757448053722602422672251758332052330100944900171067962180230120924963561223495629695702541446456981441239486190458125750543542379899722558637306740763104274377031599875275807723323394379557227060332005571272240560453811389162371812183549
n=6401013954612445818165507289870580041358569258817613282142852881965884799988941535910939664068503367303343695466899335792545332690862283029809823423608093
'''
```

### 思路

从$Z\_{n}\times Z\_{n}^{*}$到$Z\_{n^{2}}^{*}$存在双射关系$(x,y)\rightarrow g^{x}y^{n}(mod\ n^{2})$

$g\in Z\_{n^{2}}^{\*},\quad\therefore \exists(a, b),s.t.\ g=(n+1)^{a}b^{n}(mod\ n^{2})$

$c^{\lambda}=(n+1)^{am\lambda}b^{nm\lambda}r^{n\lambda}=(n+1)^{am\lambda}=1+am\lambda n(mod\ n^{2})$

$L(c^{\lambda}\ mod\ n^{2})=am\lambda$，同理$L(g^{\lambda}\ mod\ n^{2})=a\lambda$，证毕

本题$g=n+1$，且 n 可以直接`Fermat`分解得到$p$，$q$，按上述方法解密即可。

### exp

```python
from Crypto.Util.number import *

p = 80006336965345725157774618059504992841841040207998249416678435780577798937819
q = 80006336965345725157774618059504992841841040207998249416678435780577798937447
n = p * q
c = 29088911054711509252215615231015162998042579425917914434962376243477176757448053722602422672251758332052330100944900171067962180230120924963561223495629695702541446456981441239486190458125750543542379899722558637306740763104274377031599875275807723323394379557227060332005571272240560453811389162371812183549
lcm = ((p - 1) * (q - 1)) // GCD(p - 1, q - 1)
a = (pow(c, lcm, n * n) - 1) // n
b = (pow(n + 1, lcm, n * n) - 1) // n
m = long_to_bytes((a * inverse(b, n)) % n)
print(m)
```

---

---
url: /CTF/SchmidtSamoa/index.md
---
# Schmidt-Samoa密码系统
Schmidt-Samoa 密码系统，像 Rabin 加密一样，其安全性基于整数因式分解的难度。但 Rabin 解密时会得到四个解，而 Schmidt-Samoa
得到的是唯一解。

## 加密过程

**密钥生成**

1. 选取两个大的质数 p 和 q 并进行计算 $N = p^2\*q$
2. 计算 $d=invert(N,\varphi(pq))$
3. 公钥取数对$(N, d)$

**加密**

对消息 $m$ ，计算密文 $C=m^N \pmod N$

**解密**

计算明文 $m = C^d\pmod{pq}$

正确性证明就不写了。~~摸了摸了~~

## 关于 pq 的获取问题

我们有$N=p^2q,d\cdot N\equiv1\pmod{(p-1)(q-1)}$，有欧拉定理：

$$
a^{(p-1)(q-1)}\equiv1\pmod{pq}
$$

所以：

$$
a^{(p-1)(q-1)}\cdot a\equiv1\pmod{pq}
$$

$$
a\equiv a^{(p-1)(q-1)}\pmod{pq}
$$

由此，我们有：

$$
k\cdot pq=a^{Nd}-a
$$

$$
pq=gcd(a^{Nd}-a,N)
$$

我们只要随便取个$a$就行能拿到$pq$了。

## 例题

```python
from Crypto.Util.number import *
flag = b'NSSCTF{******}'

p = getPrime(512)
q = getPrime(512)
n = p*p*q
e = n

c = pow(bytes_to_long(flag), e, n)
d = inverse(e, (p-1)*(q-1))
```

$$
x^{nd}\equiv x^{nd-1}\cdot x\equiv x\pmod{pq}
$$

显然有 $pq\mid{(x^{nd}-x)}$ 。然后题目有$n=p^2q$ ，GCD 一下就有$pq$了。

**exp**:

```python
from Crypto.Util.number import *

n =
d =
c =

pq = GCD(n, pow(2, n*d, n)-2)
m = pow(c, d, pq)
print(long_to_bytes(m))
```

---

---
url: /DevTools/Docker/DockerBasic/index.md
---
# Docker基础知识
## 0xFF Docker 简介

Docker 是一个用于 构建(build)、运行(run)、传送(share) 应用程序的平台。

有了 Docker，我们就可以将一个程序及其运行时所需要的依赖包、第三方软件库、配置文件等打包在一起，以便在任何环境中都能正确地运行。

## 0x00 Docker 与传统虚拟机的区别

虚拟机在一定程度上实现了资源的整合，但是缺点也很明显：每台虚拟机都需要大量资源，并且启动的时间都比较久。
这个缺陷在我们仅需要运行一个对外提供服务的应用程序时就盖过了它带来的好处。

Docker 和容器并不是同一概念，Docker 是容器化技术的一个解决方案，而容器是一种虚拟化技术，和虚拟机类似，也是一个独立的环境。
与虚拟机不同，容器并不需要在其中运行完整的操作系统，而是使用宿主机的操作系统，因此它的启动速度非常快；
同时，因为需要的资源少，我们可以在一台物理机上运行更多的容器，能够更加充分利用物理机的资源，减少资源闲置

## 0x01 Docker 基本概念

![Docker架构](https://file.l0v3ch4n.top/L0v3ch4n-Docs-images/DevTool/Docker/Docker架构.png)

Docker 采用 C/S 架构模式，Docker Client 与 Docker Daemon 之间通过 Socket 或者 RESTful API 进行通信。
Docker Daemon 是 Docker 服务端的守护进程，负责管理 Docker 的各种资源。
Docker Client 负责向 Docker Daemon 发送请求，Docker Daemon 在接收到请求后进行处理并返回服务端的处理结果给 Docker Client

**镜像(image)**：镜像是个只读的模板，它可以用来创建容器。

**容器(container)**：容器是 Docker 运行的实例，它提供了一个独立的可移植的环境，可以在这个环境中运行应用程序。

**仓库(registry)**：Docker 仓库是用来存储 Docker 镜像的地方。最流行、最常用的 Docker 仓库是[DockerHub](https://www.docker.com/products/docker-hub/)。

> **常见比喻**
>
> 如果将镜像比做食谱，容器就是按照食谱烹饪出来的菜肴；只要你严格按照食谱来制作，就一定能做出完全一致的菜肴。
> 同时你也可以将这个食谱分享给朋友，Ta 也能根据这个食谱做出完全一样的菜来。
> 你可以把你发明的食谱上传到社交媒体（Docker 仓库）上，这样其他人就可以根据这个食谱，也做出完全一样的菜来。

## 0x02 Docker 的安装配置

在[官网](https://www.docker.com)下载安装包，安装即可。安装好 Docker 后请务必记得启动 Docker，否则无法使用 Docker 命令进行相应操作。

在终端输入`docker version`，若返回了 Client 和 Server 的版本信息则视为安装 Docker 成功，否则请检查是否启动 Docker 程序。

## 0x03 容器化和 Dockerfile

顾名思义就是将应用程序打包成容器，然后在容器中运行应用程序的过程。这个过程简单来说可以分成三个步骤：

1. 创建一个 Dockerfile，告诉 Docker 构建应用程序镜像所需要的步骤和配置。
2. 使用 Dockerfile 构建镜像。
3. 使用这个镜像创建和运行容器。

**Dockerfile**：用于指导 Docker 构建镜像的文本文件，其中包括应用程序执行的所有命令。一般来说包括以下内容：

1. 精简版的操作系统（如 Alpine）
2. 应用程序运行时环境（如 NodeJS，Java，Python）
3. 应用程序（如 Spring Boot 打包好的 jar 包）
4. 应用程序依赖的第三方库或者包、配置文件、环境变量等。

---

---
url: /DevTools/Docker/DockerPractice/index.md
---
# Docker实践
## 0xFF 引言

本文主要介绍如何编写 Dockerfile、创建镜像、启动容器的全过程。

## 项目初始化

首先创建一个名为`HelloDocker`的文件夹作为项目文件夹。

---

---
url: /DevTools/PostgreSQL/PosegreSQLInstallation/index.md
---
> 最近正在做个人网站的技术调研，由于听说PostgreSQL这个数据库很强大，所以来安装一下玩一玩。

## 一、安装PostgreSQL

::: tabs
@tab  Windows

```bash
# 下载安装包（官网：postgresql.org）
# 安装时注意：
# - 记住设置的密码（默认用户：postgres）
# - 选择安装路径
# - 默认端口5432
```

@tab  MacOS

```bash
# 使用Homebrew安装
brew install postgresql@18
brew services start postgresql@18
```

@tab  Linux

```bash
sudo apt update
sudo apt install postgresql postgresql-contrib
sudo systemctl start postgresql
```

:::

## 二、基础配置步骤

### 1. **访问PostgreSQL**

```bash
# Linux/macOS
sudo psql -u postgres

# Windows（使用pgAdmin或psql命令行）
```

### 2. **修改postgres用户密码**

```sql
ALTER USER postgres WITH PASSWORD '你的新密码';
```

### 3. **创建新用户和数据库**

```sql
-- 创建新用户
CREATE USER myuser WITH PASSWORD 'mypassword';

-- 创建数据库
CREATE DATABASE mydatabase OWNER myuser;

-- 授予权限
GRANT ALL PRIVILEGES ON DATABASE mydatabase TO myuser;
```

## 三、配置文件修改

### 1. **找到配置文件位置**

```bash
# Linux通常位置
/etc/postgresql/[版本]/main/

# 主要配置文件：
# - postgresql.conf   主配置文件
# - pg_hba.conf       客户端认证配置
```

### 2. **修改连接权限（pg\_hba.conf）**

```
# 允许本地连接（添加或修改）
local   all             all                                     trust
host    all             all             127.0.0.1/32            md5
host    all             all             ::1/128                 md5
```

### 3. **启用远程访问（如果需要）**

```bash
# postgresql.conf中修改：
listen_addresses = '*'  # 修改为 '*' 或具体IP

# pg_hba.conf中添加：
host    all             all             0.0.0.0/0               md5
```

### 4. **重启服务使配置生效**

```bash
# Linux
sudo systemctl restart postgresql

# macOS
brew services restart postgresql@16
```

## 四、常用工具

```bash
# 连接到数据库
psql -h localhost -U username -d databasename

# 常用命令
\l     # 列出所有数据库
\c dbname  # 切换数据库
\dt    # 列出当前数据库的表
\du    # 列出用户
\q     # 退出
```

## 五、基础测试

### 1. **连接测试**

```bash
# 使用新用户连接
psql -h localhost -U myuser -d mydatabase
```

### 2. **创建测试表**

```sql
-- 创建表
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入数据
INSERT INTO users (name, email)
VALUES ('张三', 'zhangsan@example.com');

-- 查询数据
SELECT * FROM users;
```

## 六、安全建议

### 1. **基础安全设置**

```sql
-- 不要使用默认的postgres用户进行应用连接
-- 为每个应用创建独立用户
-- 限制用户权限

-- 示例：创建只有特定权限的用户
CREATE USER appuser WITH PASSWORD 'securepassword';
GRANT CONNECT ON DATABASE mydb TO appuser;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO appuser;
```

### 2. **定期备份**

```bash
# 使用pg_dump备份
pg_dump -U username -d databasename -f backup.sql

# 恢复备份
psql -U username -d databasename -f backup.sql
```

## 七、常见问题解决

### 1. **连接被拒绝**

```bash
# 检查服务是否运行
sudo systemctl status postgresql

# 检查配置文件是否正确
```

### 2. **忘记密码**

```bash
# 修改pg_hba.conf，将认证改为trust
# 重启服务后无需密码登录
# 使用ALTER USER修改密码
# 改回原来的认证方式
```

### 3. **端口占用**

```bash
# 查看占用5432端口的进程
sudo lsof -i :5432

# 修改端口（在postgresql.conf中）
port = 5433
```

---

---
url: /interview/index.md
---
# 面试题笔记
## 说明

本笔记主要用于整理、记录可能会遇到的、跟其他人讨论过的面试题目。

目前笔记所收集的面试题， 主要是在**前端**的范畴中，不涉及其他。

后续按本人需求可能会添加其他方向的面试题。

---

---
url: /interview/async/index.md
---
# 异步请求
::: tip 提问

1. ajax
2. Fetch API
3. jsonp

:::

## ajax

ajax（Asynchronous JavaScript and XML）是指通过 javascript 的异步通信，从服务端获取 XML 文档，
从中提取数据，再将数据更新到当前网页的对应部分，而不需要刷新网页。

一般来说，ajax 包括以下几个步骤：

* 通过 XMLHttpRequest 对象创建一个异步调用对象；
* 创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息
* 设置响应 HTTP 请求状态变化的函数
* 发送 HTTP 请求
* 获取异步调用返回的数据
* 使用 javascript 和 DOM 实现局部更新

## Fetch API

Fetch API 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。它还提供了一个全局 fetch()
方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。

## jsonp

jsonp 是一种利用 `<script>` 标签 来实现的 支持跨域的异步通信方案。

前端将函数名作为参数传递到后端服务，后端服务在函数中注入需要返回的数据后，作为动态脚本返回给前端，
前端通过 script 标签加载这个动态脚本后，调用该函数，获取到返回的数据。

---

---
url: /interview/BFC/index.md
---
# BFC块级格式化上下文
::: tip 提问

* 什么是 BFC ?
* 如何创建 BFC ?
* BFC 有什么作用 ？

:::

## 什么是 BFC

BFC, Block Formatting Context。是 W3C CSS2.1 规范中的一个概念。 是页面中的一块块级渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和作用。

具有 BFC 特性的元素，可以看做是一个被隔离了的独立容器，容器内的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。

## 创建 BFC 的方式

1. 根元素（html）
2. 浮动元素，即 float 值不为 none。
3. 绝对定位元素， 元素的 position 为 absolute 或者 fixed
4. 行内块元素， 元素的 display 为 inline-block
5. 表格单元格， 元素的 display 为 table-cell。 （HTML 表格单元格默认为该值）
6. 表格标题， 元素的 display 为 table-caption。 （HTML 表格标题默认为该值）
7. 匿名表格单元格元素， 元素的 display 为 table、table-row、table-row-group、
   table-header-group、table-footer-group 。 （分别是 HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table。
8. overflow 计算值不为 visible 的块元素
9. display 值为 flow-root 的元素
10. contain 值为 layout、content、paint 的元素
11. 弹性元素，display 为 flex、inline-flex 元素的直接子元素
12. 网格元素， display 为 gird、inline-gird 元素的直接子元素
13. 多列容器，元素的 column-count 或 column-width 不为 auto， 包括 column-count 不为 1
14. colum-span 为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中。

## 作用

1. 同一个 BFC 的外边距会发生折叠（合并）， 通过将其放在不同的 BFC 中规避折叠。
2. BFC 可以包含浮动元素，即清除浮动。
3. BFC 可以阻止元素被浮动元素覆盖。

---

---
url: /interview/BoxModel/index.md
---
# 盒模型
::: tip 提问

* 请简述 CSS 盒模型。
* 盒模型有哪些类型？有什么区别？

:::

盒模型是 CSS 规范定义的模块，它规定了一个矩形盒子（标准盒模型），描述任意元素在文档树中占据的空间区域。每个盒子有四个边：

* `外边距边（margin edge or outer edge）`
* `边框边（border edge）`
* `内填充边（padding edge）`
* `内容边（content edge or inner edge）`

可以划分四个区域：

* `外边距区域（margin area）`
* `边框区域（border area）`
* `内填充区域（padding area）`
* `内容区域（content area）`

![css box model](https://drafts.csswg.org/css-box-3/images/box.png)

为什么会有盒模型类型，严格来说，多数浏览器都按照规范实现了标准盒模型，而盒模型的类型主要是来自于不同浏览器对元素宽高的方式不同而导致，IE 浏览器认为元素的
`width/height`应该是由元素的`内容+内填充+边框`组成，而 W3C 规定的元素的`width/height`应该是元素的`内容`，从而衍生了不同的盒子模型。到
`CSS3`，添加了`box-sizing`属性，用于更改用于计算元素宽高的默认盒子模型，并将 IE 浏览器和 W3C 规范纳入了实现中。可以使用此属性来模拟不正确支持 CSS 盒子模型规范的浏览器的行为。

*注：`width/height`最终并不能完全决定元素的实际占用宽高。*

```css
/* 关键字值 */
box-sizing: border-box; /* 默认值 */
box-sizing: content-box;
/* 全局值 */
box-sizing: inherit;
box-sizing: initial;
box-sizing: unset;
```

`border-box`规定了元素的`width`由`内容+内填充+边框`组成，即 IE 浏览器的实现。 元素的实际占据宽度由 width 属性+外边距。内容宽度为
`width - padding - border`。

`content-box`规定了元素的`width`即`内容宽度`, W3C 规范的标准。元素的实际占据宽度由`widht + padding + border + margin`
。内容宽度为`width`。

`box-sizing`还有一个待废除的值`padding-box`，`width` 和 `height` 属性包括内容和内边距，但是不包括边框和外边距。只有 Firefox 实现了这个值，它在 Firefox
50 中被删除。

在高度计算上以上规则同样适用，但对非替换行内元素，尽管内容周围存在内边距与边框，但其占用空间受到`line-height`属性影响。

---

---
url: /interview/BrowserRender/index.md
---
# 浏览器渲染原理
::: tip 提问

1. 请说说浏览器渲染页面的过程

:::

浏览器在拿到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出渲染任务开始渲染流程。

## 渲染流程

整个渲染流程分为多个阶段： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、展示。

每个阶段都有明确的输入和输出，形成一套严密的生产流水线。

## 解析 HTML

```:no-line-numbers
输入：HTML文档
输出：DOM树、CSSOM树
```

解析 HTML 过程中遇到 CSS 会解析 CSS，遇到 JS 会执行 JS。为了提高效率，浏览器在开始解析前会启动预解析线程，先行下载 HTML 中用到的外部的 CSS、JS 文件。

下载和解析 CSS 文件的工作是在预解析线程中进行的，所以 CSS 解析不会阻塞主线程。

而 JS 执行可能会影响 DOM 树，因此执行 JS 时主线程会被阻塞。

本阶段完成后，会得到 DOM 树和 CSSOM 树，浏览器默认样式、内部样式、行内样式均会包含在 CSSOM 树中。

## 样式计算

```:no-line-numbers
输入：DOM树、CSSOM树
输出：带样式的DOM树
```

主线程会一次遍历 DOM 树，为树中每个节点计算出最终样式（Computed Style）。

这一过程中，很多预设值会转变成绝对值，相对单位会转变成绝对单位。

这一阶段完成后，会得到一棵带样式的 DOM 树。

## 布局

```:no-line-numbers
输入：带样式的DOM树
输出：布局树
```

依次遍历 DOM 树的每一节点，计算节点几何信息（宽高、相对包含快的位置）。

::: note 提示

大部分时候，布局树和 DOM 树并非一一对对应。

比如 `display: none` 的节点没有几何信息，因此不会生成到布局树；又如伪元素选择器，虽然 DOM 书中不存在这些伪元素节点，但是他们拥有几何信息，
因此会被天机道布局树中。

:::

本阶段完成后会产生一棵布局树。

## 分层

主线程会根据库一套复杂的策略对整个布局树进行分层。

分层的优势在于：将来某一层改变后，仅会对该层进行处理，提升效率。

可能影响分层的事物：

1. 滚动条
2. 堆叠上下文
3. transform
4. opacity
5. will-change 属性

## 绘制

对每一层生成绘制指令集，描述如何绘制该层内容。

## 分块

完成分层后，主线程将信息提交给合成线程，剩余工作在合成线程中完成。

合成线程先将每个图层分块，划分成更多的小区域。

## 光栅化

将每个快变成位图，**优先处理靠近视口的分块**。

## 展示

最后调用 GPU 硬件将页面渲染到屏幕上。

---

---
url: /interview/ComponentCom/index.md
---
# 组件间通信
::: tip 提问
vue3 有哪几种组件通信方式？
:::

在 vue2 中能够使用的组件通信方式，在 vue3 中同样的都能够使用，但有部分有区别，同时，还扩展了其他的通信方式

## 组件通信方式

::: info
仅列出跟 vue2 有区别的部分，以及新增的方式
:::

### $parent / refs / expose

相比于 vue3 ，vue2 删除了 `$children` ，可以使用 `refs` 获取子组件的实例。

子组件还可以通过 `expose` 选项 控制允许哪些内容暴露给父组件

适用场景：

* 父子组件通信

### $attr

在 vue3 中， 已经移除了 `$listener`， 并将其合并到了 `$attr` 中，所以可以直接使用 `attr`向后代组件传递数据

### 共享响应式对象

使用 `reactive` 创建一个响应式对象，并在不同组件中导入它。

这种方式可以创建一个简单的共享状态管理， 但由于任何导入它的组件都可以对其进行修改，这种做法不好维护。
而且仅适用于纯客户端前端页面，如果需要使用 `SSR`，那么这种方式可能会导致 **跨请求状态污染**

适用场景：

* 父子组件通信
* 兄弟组件通信
* 隔代组件通信

这种方式虽然可以进行各种组件间关系的通信，但不适合用于有复杂变更状态的场景。

### Pinia

一个 替代 `Vuex` 的 状态管理库。

---

---
url: /interview/crossOrigin/index.md
---
# 跨域
::: tip 提问

1. 什么是跨域
2. 浏览器的同源策略
3. 跨域解决方案

:::

## 跨域

当 协议、 子域名、 主域名、 端口号 中任意一个不相同是，都算作不同域。
不同域之间相互请求资源，就被认为是 **跨域**。

## 浏览器的同源策略

同源策略是一种约定，它是浏览器最核心也是最基本的安全功能。

同源策略是指： `协议 + 域名 + 端口` 三者相同，即使两个不同的域名指向同一个 IP 地址，也非同源。

同源策略限制的内容有：

* Cookie、LocalStorage、IndexedDB 等存储性内容
* DOM 节点
* AJAX 请求

有三个标签允许跨域加载资源：

* `<img>`
* `<link>`
* `<script>`

## 跨域解决方案

跨域问题并不是前端开发人员仅依靠浏览器和 javascript 就能够解决的，常常需要跟服务器、后端技术人员进行配合，
才能解决。

### jsonp

利用`<script>` 标签没有跨域限制的特点，网页可以得到从其他来源动态产生的 JSON 数据。
JSONP 请求一定需要对方的服务器做支持才可以。

### cors

cors 方案需要浏览器和后端同时支持。

服务端需要设置 `Access-Control-Allow-Origin` 就可以开启 cors。

该属性表示哪些域名可以访问资源，如果设置了通配符则表示所有网站都可以访问资源。

浏览器端会自动进行 CORS 通信。

### 代理转发

* 通过 nginx 配置一个代理服务器，反向代理 非同源域名的接口到当前域名。
* 服务器 中间代理。通过 服务器 代理转发非同源域名的接口。

### 其他

以下方法仅能解决部分场景下的跨域问题，并不是一种通用的，合适的解决方案。

* postMessage
* websocket
* window.name + iframe
* location.hash + iframe
* document.domain + iframe

::: tip 说明
在工作中最常用的跨域解决方案是 CORS 和 服务器代理转发。
这两种方法是最合适和最通用的解决方案。
:::

---

---
url: /interview/CSSfloat/index.md
---
# CSS浮动
::: tip 提问

* 什么是 CSS 浮动？
* 浮动元素会带来哪些影响？
* 如何清除浮动？ 各自的优点？

:::

## 什么是 CSS 浮动（float）

一开始 引入 float 属性是为了让 开发人员实现简单的布局，在一列文本中浮动的图像，文字环绕在它的左边或者右边。

但 开发人员意识到，任何东西都可以浮动，而不仅仅是图像，所以浮动的使用范围扩大了。

在早期，浮动可以用来实现整个网站的页面布局， 因为浮动使得元素可以横向并列。

## 浮动元素带来哪些影响？

* 包裹性，自适应性；

  * 如果浮动元素父元素宽度为 300px，浮动元素不声明宽度，浮动元素子元素是一个 200px 的图片，则此时浮动元素的宽度表现为包裹，
    宽度就是子元素图片的宽度 200px；

  * 如果浮动元素子元素还包括大串文本内容，父元素不足以一行放下所有文本内容，则此时浮动元素则自适应父元素的宽度，宽度为父元素宽度。

* 块级化并格式化上下文

  * 当一个元素的 float 属性值不为 none，则其 display 计算值就是 block 或者 table。
  * 同时，该浮动元素也会产生一个格式化上下文

* 破坏文档

  浮动元素会让其父元素的高度塌陷。在大多数场景下，这个特性会影响到 正常的布局。

* 没有任何 margin 合并

## 清除浮动

### clear 属性

clear 属性的官方解释是： 元素盒子的边不能和前面的浮动元素相邻。

用法：

```
clear: none | left | right | both;
```

使用：

* 在浮动元素后面插入空白块级元素，并声明 clear 属性

  ```html
  <style>
      .float {
          float: left;
      }
      .clear {
          clear: both;
      }
  </style>
  <div>
      <div class="float">float</div>
      <div class="clear"></div>
  </div>
  ```

* 使用伪类元素，并声明 clear 属性

  ```html
  <style>
      .float {
          float: left;
      }
      .clear::after {
          content: "";
          display: block;
          clear: both;
      }
  </style>
  <div class="clear">
      <div class="float">float</div>
  </div>
  ```

### 创建 BFC 包裹浮动元素

创建 BFC 的方式比如：

* 浮动元素父元素设置 float 属性
* 浮动元素父元素设置 overflow 属性，且值为 auto、scroll 或 hidden
* 浮动元素父元素设置 position 属性，且值不为 relative 或 static
* 浮动元素父元素设置 display 属性，且值为 inline-block、table-cell 或 table-caption

::: tip 说明
float 属性，一开始的设计目的，仅仅是为 文字和图片服务的，是为了实现文字的环绕效果。
但是由于当年可用的布局手段很少，想要实现复杂的排版，大都依赖`<table>`布局，后来发现给元素浮动后，
可以像垒房子一样，把元素变成一块块砖搭建页面，float 也被开发人员变成了一种网页布局手段。

在当下，网页可用的布局方式已经越来越丰富，比如`flex`布局、`Gird`布局等，都比用 float 属性进行布局要更加强大。
所以在当下，不推荐继续使用 float 进行布局。
:::

---

---
url: /interview/dataType/index.md
---
# 数据类型
::: tip 提问

1. javascript 有哪些数据类型？
2. 什么是基本数据类型？
3. 什么是引用数据类型？
4. 如何做数据类型判断？

:::

## 数据类型

javascript 有两种数据类型，分别是 基本数据类型 和 引用数据类型。

## 基本数据类型

javascript 一共有 7 中基本数据类型，包括：
`undefined`, `null`, `Boolean`, `Number`,
`String`, `BigInt`, `Symbol`。

特性：

* 存放在栈区
* 进行值比较时，`==` 只进行值的比较，会进行数据类型转换， `===` 不仅进行值的比较，还要进行数据类型的比较。

## 引用数据类型

引用数据类型指 Object 类型， 所有其他的如 Array、Date、Function 等类型都可以理解为 Object 类型的子类。

特性：

* 同时保存在栈内存和堆内存中。解释器寻找引用值是，会首先检索它在栈中的地址，取得地址后从堆中获得实体。
* 比较时是引用的比较

## 数据类型判断

### typeof

`typeof` 返回一个表示数据类型的字符串，可以用来判断 `number`, `boolean`, `string`,`symbol`,`object`,
`undefined`, `function` 等 7 种数据类型，但不能判断 `null`，`Object`的子类等。

### instanceof

`instanceof` 用来判断 A 是否为 B 的实例。 一般用于判断引用类型。但在 类的原型继承中，结果不一定准确。

### constructor

`constructor` 和 `instanceof` 类似， 但还可以处理除了 null、undefined 之外的基本数据类型的检测。

`constructor`不是稳定的，如果把类的原型重写，可能会把之前的`constructor`给覆盖了。

### Object.prototype.toString.call(someObj)

最准确也是最常用的数据类型检测方式。 该方法会将数据类型的检测结果以`[object <type>]` 的形式返回。

### 其他

除了上述的方式，一些数据类型也提供了方法进行数据类型判断，如：

* Array.isArray()
* Number.isNaN()

---

---
url: /interview/DebounceAndThrottle/index.md
---
# 防抖和节流
::: tip 提问

1. 什么是 节流与防抖？
2. 如何实现 节流与防抖？

:::

## 节流与防抖

* 函数防抖： 在事件被触发的 N 秒后再执行回调，如果在这 N 秒内事件又被触发，则重新计时。

* 函数节流：在一个规定的单位时间内，只能有一次触发事件的回调函数执行，如果在单位时间内事件被触发多次，只有一次生效。

## 实现

### 函数防抖

```js
function debounce(fn, wait) {
  let timer = null
  return function () {
    let ctx = this
    let args = arguments

    if (timer) {
      clearTimeout(timer)
      timer = null
    }
    timer = setTimeout(() => {
      fn.apply(ctx, args)
    }, wait)
  }
}
```

### 函数节流

```js
function throttle(fn, delay) {
  let preTime = Date.now()
  return function () {
    let ctx = this
    let args = arguments
    let nowTime = Date.now()
    if (nowTime - preTime >= delay) {
      preTime = Date.now()
      return fn.apply(ctx, args)
    }
  }
}
```

---

---
url: /interview/DOCTYPE/index.md
---
# DOCTYPE
::: tip 提问

1. 什么是 DOCTYPE？
2. DOCTYPE 的作用是什么？
3. 标准模式和兼容模式
4. HTML5 `<!DOCTYPE HTML>`
5. 什么是 DTD？

:::

## 什么是 DOCTYPE

`DOCTYPE` 是 文档类型， 用于声明当前文档使用哪种文档模式进行解析和渲染。

## DOCTYPE 的作用是什么？

`<!DOCTYPE>` 声明一般位于文档的第一行，它的作用是告知浏览器以哪种模式进行解析文档。
一般指定之后，会使用标准模式进行文档解析，否则就以兼容模式进行解析。

## 标准模式和兼容模式

* 标准模式 是指 浏览器以该浏览器支持的最高标准进行文档解析和渲染，包括 JS 引擎。
* 兼容模式 是指 文档以宽松的向后兼容的方式渲染，模拟老式浏览器的行为以防止站点无法工作。

## HTML5 的 DOCTYPE 声明

HTML5 的 不需要对 DTD 进行引用。但是需要 DOCTYPE 来规范浏览器的行为。
所以 HTML 的 DOCTYPE 声明为

```html
<!DOCTYPE html>
```

## 什么是 DTD？

DTD 全称： `Document Type Definition (文档类型定义)`，是一组机器可读的规则。

DTD 定义了 XML 或者 HTML 的特定版本中所有允许元素和它们的属性和层级关系的定义。
解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。

---

---
url: /interview/DOMOperation/index.md
---
# DOM节点操作
::: tip 提问
如何添加、移除、移动、复制、创建、查找节点？
:::

## 创建节点

* `document.createDocumentFragment(node)` 创建一个虚拟节点对象
* `document.createElement(node)` 创建一个新的元素
* `document.createTextNode(text)` 创建一个文本节点

## 添加、移除、替换、插入

* `appendChild(node)` 在元素的末尾插入一个子元素
* `removeChild(node)` 删除元素中的指定的元素
* `replaceChild(newNode, oldNode)` 使用 newNode 替换 oldNode
* `insertBefore(newNode, node)` 在 node 元素之前插入一个 newNode

## 查找

* `getElementById(id)`
* `getElementsByName(name)`
* `getElementsByTagName(tagName)`
* `getElementsByClassName(className)`
* `querySelector(selector)`
* `querySelectorAll(selector)`

## 属性操作

* `getAttribute(key)`
* `setAttribute(key, value)`
* `hasAttribute(key)`
* `removeAttribute(key)`

---

---
url: /interview/ElemCenter/index.md
---
# 元素垂直居中
::: tip 提问

* 在 某某场景下，如何让某某元素垂直居中？
* 有哪些方式可以实现元素的垂直居中？

:::

**设立一个场景：在一个宽高不固定的容器中，实现一个宽高不固定的内容盒子，并垂直水平居中。**

```html
<!-- 假设 warpper、container 宽高不固定 实现container相对于wrapper垂直水平居中-->
<div class="wrapper">
    <div class="container"></div>
</div>
```

**方法一：** 使用 flex 布局

```css
.wrapper {
    display: flex;
}

.container {
    margin: auto;
}
```

适用于支持 flex 布局的浏览器（IE11 以上，其他现代浏览器）。这里是利用 flex 弹性布局的特性，弹性容器改变了其子元素填充可用空间的方式，子元素默认从容器左上角开始排列，在不设置宽高时，子元素填充空间由
`flex`声明，默认值为`0 1 auto`,即
`flex-grow: 0;flex-shrink: 1;flex-basis: auto`; 其中 `flex-basis`定义了子元素的宽和高的尺寸大小，`auto`
值表示自动尺寸，根据子元素内容计算宽高，在子元素上设置`margin: auto`，这是利用`auto`
平均分配水平或垂直方向上的额外的空间，从而达到目的。（此方法实现的结果是“真正的”垂直水平居中）

或者

```css
.wrapper {
    display: flex;
    justify-content: center;
    align-content: center;
}
```

**方法二：** 使用 table 布局

```css
.wrapper {
    display: table-cell;
    vertical-align: middle;
}

.container {
    margin: auto;
}
```

利用的是 table 布局的特性，不过该方法有个缺点就是，`display: table-cell`元素的宽高设置百分比数值是“无效的”，原因是父元素非
`table`元素或`display: table`元素，`display: table-cell`元素的宽高百分比数字是相对于`table`计算的。

**方法三：** `position` + `transform`

```css
.wrapper {
    position: relative;
}

.container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
```

该方法与前面两个方法的作用机理有很大的不同，首先第一点是`container`脱离了文档流，
并且`container`自身的宽高发生了坍塌，在不设置宽高属性下，尺寸由内容撑开，
`container`相对`wrapper`元素进行绝对定位，水平方向与垂直方向上，
`container`的左上角顶点偏移到`wrapper`中点，`container`的`transform`是相对于自身的，
`translate(-50%, -50%)`相对于自身，将左上角顶点做左上偏移自身的一半，从而实现了目的。

*有一些面试者给出了`container`元素上设置`margin-left: -50%; margin-top: -50%`
的答案，然而，margin 的百分比值，是相对于其父元素计算的。*

**方法四：** 使用 行内块元素

```css
.wrapper {
    text-align: center;
}

.wrapper:after {
    content: "";
    display: inline-block;
    vertical-align: middle;
    height: 100%;
}

.container {
    display: inline-block;
    vertical-align: middle;
    text-align: left;
}
```

该方法实现的垂直水平居中其实是一个近似垂直水平居中，兼容 IE7 以上的浏览器。
水平方向上`.wrapper`设置`text-align: center;`实现了水平居中；垂直方向上，
给定`container`声明行内块元素，并`vertical-align: middle`，但由于`container`高度不确定，
无法声明具体的行高，所以借助了父元素的伪类元素，创建了一个宽度为 0 高度为 100%的行内块元素，
从而使`container`元素在垂直方向上实现了居中。
但由于`vertical-align: middle`是元素的中线与字符 X 的中心点对齐，大多数字体设计字体的中心点偏下，
也导致了实现的垂直居中并不是绝对的垂直居中。而要实现绝对的垂直居中，需要添加一下属性：

```css
.wrapper {
    font-size: 0;
    white-space: nowrap;
}

.container {
    font-size: 14px; /* 重置回默认字体大小 */
    white-space: normal;
}
```

---

---
url: /interview/ElemClassify/index.md
---
# 元素的分类
::: tip 提问

1. 行内元素和块级元素
2. HTML5 元素的分类
3. 空元素的定义

:::

## 行内元素和块级元素

在 HTML4 中，元素被分为两大类， inline（内联元素）和 block（块级元素）

1. 内联元素

   内联元素 只占据它对应的标签的边框所包含的空间。

   常见的内联元素有： `<a>`, `<span>`, `<img>`, `<button>`, `<input>`, `strong`, `<label>`,
   `<select>`, `<textarea>` 等

2. 块级元素

   块级元素占据其父元素（容器）的整个宽度，创建了一个`块`。

   常见的块级元素有： `<div>`, `<ul>`, `<ol>`, `<li>`, `<h1>`, `<h2>`, `<h3>`, `<h4>`, `<h5>`,
   `<h6>`, `<p>` 等

## HTML5 元素的分类

由于 CSS 属性 `display` 可以直接声明 元素是 `block` 或 `inline` 或`inline-block` 等，
所以简单的将 元素分类为 内联元素和块级元素已不再符合需求。

在 HTML5 中，元素主要分为 7 类， 并且每个元素可以归属于一个或多个类型：

* Metadata 元数据元素

  `<base>`, `<link>`, `<link>`, `<meta>`, `<script>`, `<noscript>`, `<style>`, `<title>`

* Flow 流式元素

  `<a>`, `<abbr>`, `<address>`, `<article>`, `<aside>`, `<audio>`, `<br>`, `<button>`,
  `<blockquote>`, `<canvas>`, `<div>`, `<footer>`, `<form>`, `<h1>`, `<h2>`, `<h3>`,
  `<h4>`, `<h5>`,`<h6>`, `<p>` 等

* Sectioning 章节元素

  `<article>`, `<aside>`, `<nav>`, `<section>` 等

* Heading 标题元素

  `<h1>`, `<h2>`, `<h3>`, `<h4>`, `<h5>`,`<h6>`, `<hgroup>`等

* Phrasing 短语元素

  `<abbr>`, `<br>`, `<button>`, `<canvas>`, `<code>`, `<img>`, `<i>`, `<strong>`, `<iframe>`,
  `<input>`, `<small>`, `<select>` 等

* Embedded 嵌入元素

  `<audio>`, `<video>`, `<canvas>`, `<iframe>`, `<img>`, `<embed>`, `<svg>` 等

* Interactive 交互元素

  `<a>`, `<button>`, `<details>`, `<embed>`, `<iframe>`, `<label>`, `<textarea>`, `<select>`

## 空元素的定义

标签内没有内容的 HTML 标签被称为空元素。

空元素是在开始标签中关闭的，也称 自闭合元素。

`<br>`, `<hr>`, `<img>`, `<input>`, `<link>`, `<meta>`

---

---
url: /interview/EnPackage/index.md
---
# 闭包
::: tip 提问

1. 什么是闭包
2. 闭包有什么作用

:::

## 闭包

闭包是指有权访问另一个函数作用域中变量的函数。

创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

闭包的本质就是作用域链的一个特殊应用，只要了解作用域链的创建过程，就能够理解闭包的实现原理。

## 作用

* 闭包可以使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，
  从而在外部访问到函数内部的变量，可以用这种方法来创建私有变量。

* 闭包可以使已经结束运行的函数上下文中的半两对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，
  所以这个变量对象不会被回收。

---

---
url: /interview/EventListener/index.md
---
# 事件监听
addEventListener() 方法是添加事件监听器的标准方式，它允许我们对 DOM 元素的特定事件进行响应。

## 基本用法

```javascript
element.addEventListener(event, func, useCapture)
```

* event：一个字符串，表示要监听的事件类型（如 "click"、"mouseover" 等）。
* function：当事件发生时要执行的函数（也称为回调函数）。
* useCapture：一个可选的布尔值，指示是否在捕获阶段调用事件处理程序。默认为 false，表示在冒泡阶段调用。

## 常见事件类型

1. 点击事件(click)
2. 鼠标悬停事件(mouseover)
3. 鼠标移出时间(mouseout)
4. 键盘按下事件(keydown)
5. 表单提交事件(submit)

## 移除事件监听器

如果需要移除已添加的事件监听器，可以使用 removeEventListener() 方法。注意，移除事件监听器时，必须传入相同的事件类型和函数引用。

---

---
url: /interview/EventLoop/index.md
---
# 事件循环
::: tip 提问

1. 请说说什么是事件循环
2. 说说你对 JS 异步的理解 / JS 为什么会阻碍渲染

:::

## 事件循环

事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。

在 Chrome 浏览器源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行。其他线程产生的任务会加入到队列末尾。

具体来说，每个任务都有不同的类型，而现代浏览器中会维护多个任务队列，不同任务队列中的任务对象具有不同的类型和执行优先级。不同的浏览器
实现这一功能时有所不同（队列个数不尽相同），但是其中必定会有一条微队列，其中的任务具有最高优先级，必须优先调度执行。

## JS 异步的理解

首先，JS 是一门单线程的语言——因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。

渲染主线程承担着渲染页面、执行 JS 脚本等工作，如果采用同步的运行策略，就极可能导致主线程产生阻塞，导致其他任务无法得到执行。这样会导致
主线程工作效率极低，同时导致页面无法及时更新，面向用户就是卡死。

所以浏览器采用异步的策略来避免阻塞。具体来说是在某些任务（如计时器、网络、事件监听）发生时，主线程将任务交给其他线程处理，自身立刻结束
任务执行，转而执行后续代码。当其他线程完成任务时，会把事先传递的回调函数包装成任务对象，加入到消息队列末尾等待主线程调度执行。

这种模式下，浏览器用不阻塞，从而最大程度保证了浏览器的流畅运行。

---

---
url: /interview/FlexGrid/index.md
---
# flex弹性布局
::: tip 提问
描述一下 Flex box
:::

## Flex Box

Flex Box 即**弹性盒布局模型**。

任何一个容器都可以指定为 Flex 布局。

采用 Flex 布局的元素，称为 Flex 容器，简称容器。它的所有子元素自动成为容器成员。

在容器上，可以设置以下属性：

* `flex-direction`: 主轴的方向，默认值是 row
* `flex-wrap` : 一条轴线排不下时，如何换行，默认值是 nowrap
* `flex-flow` : flex-direction 和 flex-wrap 的简写形式，默认值是 row nowrap
* `justify-content` 定义容器成员在主轴上的对齐方式
* `align-items` 定义项目成员在交叉轴上的对齐方式
* `align-content` 定义多根轴线的对齐方式，如果容器成员只有一根轴线，该属性不起作用

在项目成员上，可以设置以下属性：

* `order` 定义成员的排列顺序。数值越小，排列越靠前，默认为 0
* `flex-grow` 定义成员的放大比例，默认为 0
* `flex-shrink` 定义成员的缩小比例，默认为 1
* `flex-basis` 定义在分配多余空间之前，成员占据的主轴空间，默认为 auto
* `flex` flex-grow, flex-shrink , flex-basis 的简写，默认为 0 1 auto
* `align-self` 定义单个成员的对齐方式

## 总结

flex 布局是 css3 新增的布局方式，可以通过将一个元素的 display 属性声明为 flex 从而使元素成为 flex 容器。

一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴，可以声明主轴的方向、定义容器成员的主轴上的对齐方式，
交叉轴的对齐方式、换行方式等。对容器成员，可以定义排列顺序、空间利用方式、对齐方式等。

---

---
url: /interview/HTML5feature/index.md
---
# HTML5新特性
::: tip 提问

1. HTML5 有哪些新特性？
2. 如何处理 HTML5 新标签的浏览器兼容?

:::

## 新特性

* 媒介 video 和 audio 元素
* 绘画 canvas
* 本地离线存储 localStorage、sessionStorage
* 语义化标签：article,footer,header,nav,section,aside,表单控件等
* Web Worker
* Web Socket

等

## HTML5 新标签的浏览器兼容方案

在 IE 6/7/8 中，支持通过 `document.createElement` 方法产生标签，可以利用这个特性
让这些浏览器支持 HTML5 标签，同时还需要为标签添加默认样式。

---

---
url: /interview/HTTP/index.md
---
# HTTP协议
::: tip 提问

1. http 协议
2. http 状态码
3. https 协议
4. post 和 get 区别？
5. options 请求有什么用？

:::

## http 协议

http 是超文本传输协议，定义了客户端和服务器之间交换报文的格式和方式。
http 使用 TCP 作为传输层协议，保证了数据传输的可靠性。
http 是一个无状态协议，http 服务器不会保存关于客户的任何信息。

http 报文有两种：

* 请求报文，包括 请求行和 首部行 和实体主体。请求行包括了请求方法和 URL 字段等。
* 响应报文，包括 状态行和首部航和实体主体。 状态行包括了 状态码 和 状态信息 等。

## http 状态码

http 状态吗 是由三个十进制的数字组成，可以分为五类。

* `1**` 信息响应，服务器接受到请求，需要请求者继续执行操作
* `2**` 成功响应，操作被成功接收并处理
* `3**` 重定向，需要进一步的操作以完成请求
* `4**` 客户端错误，请求包含语法错误或无法完成请求
* `5**` 服务器错误，服务器在处理请求的过程中发生了错误

常见的状态码

* `200` 请求成功
* `204` 无内容。请求成功，服务器成功处理，但未返回内容
* `304` 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。
* `400` 客户端请求语法错误，服务器无法理解
* `401` 请求要求用户的身份认证
* `403` 服务器拒绝执行请求
* `404` 服务器无法根据客户端的请求找到资源

## HTTPS 协议

https 是超文本传输安全协议，是基于 HTTP 协议的，使用 TLS/SSL 来对数据加密。

## Post 和 Get 的区别

* 从应用场景上来说，GET 请求是一个幂等请求，一般 GET 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页。
  而 POST 请求不是一个幂等请求，一般用于对服务器资源会产生影响的请求。比如注册用户等操作。

* 由于不同的应用场景，浏览器一般会对 GET 请求缓存，但很少对 POST 请求缓存

* 从发送的报文格式来说，GET 请求的报文实体不为空，POST 请求的报文实体部分一般为向服务器发送的数据

* GET 请求的请求参数一般是放入到 URL 中想服务器发送，POST 请求一般是在请求实体中发送数据

## OPTIONS 请求的作用

一般是用于客户端 请求服务端返回该资源所支持的所有 HTTP 请求方法。

该方法会用 `*` 来代替资源名称，向服务器发送 OPTIONS 请求，测试服务器功能是否可用。

JS 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，对复杂请求，会使用 OPTIONS 方法发送嗅探请求，判断是否有对指定资源的访问权限。

---

---
url: /interview/HTTPCache/index.md
---
# HTTP缓存
::: note
老生常谈！老生常谈！老生常谈啊！
:::

## 什么是 HTTP 缓存

当客户端向服务器发起资源请求时，会先抵达浏览器缓存，如果浏览器有要请求的资源的副本，
那么就可以直接从浏览器缓存中提取而不是从原始服务器中获取这个资源。

http 缓存都是从对同一资源的第二次请求开始的。

* 第一次请求时，服务器返回资源，并在`response header`中回传资源的缓存参数；
* 第二次请求时，浏览器会根据这些缓存参数，判断是否使用浏览器缓存的资源副本还是从服务器获取资源。

## HTTP 缓存分类

HTTP 缓存，根据是否需要重新向服务器发起请求，可分为两大类：

* 强缓存： 强制缓存，在缓存有效时间内，不再向服务器发起资源请求，直接使用浏览器缓存的资源副本
* 协商缓存：在缓存有效时间内，需要向服务器询问资源是否需要更新，如果需要更新，则从服务器获取新的资源，
  如果不需要更新，则继续使用浏览器缓存的资源副本；

::: tip 另一种缓存分类
根据资源是否可以被单个用户或多个用户使用来分类，还可以分为 私有缓存和共享缓存。

这种一般是对于 代理服务器的，即 浏览器发起请求 -> 代理服务器 -> 原始服务器。

* 私有缓存： 在代理服务器中，仅针对单个用户使用的资源缓存，其他用户发起的对同一个资源的首次请求，仍然需要从原始服务器获取资源
  并为该用户建立新的缓存资源。

* 共享缓存：只要有一个用户发起的对同一个资源的首次到达代理服务器的请求，代理服务器对该资源缓存后，其他用户请求代理服务器上的资源，
  在缓存有效时间内，代理服务器不再向原始服务器获取新的资源，返回代理服务为缓存的资源副本。

:::

## 主要的 HTTP Headers

* 通用首部字段

  | 字段          | 说明                                         |
  | ------------- | -------------------------------------------- |
  | Cache-Control | 控制缓存行为                                 |
  | Pragma        | http1.0 时代的产物，值为 no-cache 时禁用缓存 |

* 请求头部字段 Request Headers

  | 字段                | 说明                           |
  | ------------------- | ------------------------------ |
  | If-Match            | 比较 ETag 是否一致             |
  | If-None-Match       | 比较 ETag 是否不一致           |
  | If-Modified-Since   | 比较资源最后更新时间是否一致   |
  | If-Unmodified-Since | 比较资源最后更新时间是否不一致 |

* 响应头部字段 Response Headers

  | 字段 | 说明         |
  | ---- | ------------ |
  | ETag | 资源匹配信息 |

* 实体头部字段

  | 字段          | 说明                                 |
  | ------------- | ------------------------------------ |
  | Expires       | http1.0 时代的产物，实体主体过期时间 |
  | Last-Modified | 资源的最后一次更新时间               |

::: warning 提醒
`Pragma`、`Expires` 这两个 header 是 http1.0 中的内容，在 http1.1 及往后的版本中逐步被弃用。

但为了能够对浏览器向下兼容，大多数网站在设置 缓存机制时，仍然在 response headers 中保留这两个字段的声明。

本文同样也会对这两个字段进行说明，以及为什么 http1.1 后会使用 `Cache-Control` 代替。
:::

::: warning 提醒
在某些技术文章分享中，常常会直接把这些 headers 字段各自分类到 强缓存 或 协商缓存中，
个人认为这种简单粗暴的划分方式是有待商榷，就比如`Cache-Control`的不同取值，其行为会根据值表现为强缓存或协商缓存。
:::

### Pragma

`Pragma` 字段仅有一个 `no-cache`的可选值，会告知客户端不要对该资源进行缓存读取，应该每次都向服务器发送资源请求。

在客户端使用时，通常做法是在 HTML 中加上一个 meta 标签：

```html
<meta http-equiv="Pragma" content="no-cache" />
```

::: caution 警告

* 这个标签声明仅有 IE 才能识别含义，其他主流浏览器不兼容。
* 在 IE 浏览器中，虽然能够识别含义，但并不一定会在请求 Request Header 中加上 Pragma，但确实会让当前页面每次都发起新请求。
  （仅限页面 html 文件，页面内使用的其他资源不受影响。）

:::

在服务端配置为 Response Header 时，浏览器读取到该字段，会禁用缓存行为，后续的对同一资源的请求会重新发起请求而不使用缓存。

::: warning 提醒
由于`Pragma` 在浏览器端的兼容问题，在服务器端又有其他字段能更好的控制缓存行为，Pragma 字段基本已经被抛弃，不再使用，

*除了部分网站出于兼容性考虑，还会带上该字段。*
:::

### Expires

在 http1.0 中，Pragma 用于禁用缓存，也需要有一个字段用于启用缓存和定义缓存时间。Expires 就是用于这个目的。

Expires 的值是一个 GMT 时间， 如：`Thu Jun 07 2018 14:26:45 GMT`，用于告诉浏览器资源的缓存过期时间，如果还没有超过该时间
则不发起新的资源请求。

在客户端，可以使用 meta 标签来告知浏览器缓存时间

```html
<meta http-equiv="expires" content="Thu Jun 07 2018 14:26:45 GMT" />
```

如果希望不走缓存，每次页面请求都发起新的请求，可以把 content 设置为 -1 或 0。

::: caution 提醒
跟 Pragma 字段一样， 该 meta 标签只有 IE 能够正确识别。
而且该方式仅是告知 IE 缓存时间的标记，并不能在 Request Header 中找到该字段。
:::

服务端在 Response Headers 中设置 Expires 字段，则在任何浏览器中都能正确设置资源缓存时间；

::: info 说明
如果同时使用 Pragma 和 Expires 字段， 则 Pragma 优先级会更好，页面会发起新的请求
:::

::: warning 提醒
Expires 字段虽然能够定义缓存有效时间，但是这个时间的设置是相对于本地时间的。
如果在服务端定义，则这个时间是相对于服务端时间的，
这个时间返回到客户端， 客户端是拿着客户端的本地时间与返回的服务端时间做对比。
那么就会导致一种情况，当用户更改了客户端的时间，如超过了 Expires 定义的缓存时间，那么缓存就立即失效了。

也正是应该存在着这样的问题，Expires 并不能保证缓存能够达到预期的表现，所以也被逐步弃用。
:::

### Cache-Control

`Cache-Control` 是从 `http1.1` 开始支持的 header 属性，该属性的值描述了使用缓存的行为以及缓存的有效时间。

`Cache-Control` 可以在 发起请求时，在`Request Headers` 中声明该属性，（如果资源请求是通过代理服务器再到原始服务器，）
通知代理服务器对资源的缓存方式，以及是否向原始服务器请求最新的资源。

`Cache-Control` 做为 `Response Headers` 属性返回时，通知浏览器对该资源的缓存方式和有效时间。

Cache-Control 语法如下：

```
Cache-Control: <cache-directive>
```

* 作为 `Request Headers` 时， `cache-directive` 支持以下可选值

| 字段名称                   | 说明                                                                                                                         |
| -------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| no-cache                   | 告知(代理)服务器不直接使用缓存，要求从原始服务器发起请求                                                                     |
| no-store                   | 所有内容都不会被保存到缓存或 Internet 临时文件中                                                                             |
| max-age=delta-seconds      | 告知服务器 客户端希望接收一个存在时间（age）不大于 delta-seconds 秒的资源                                                    |
| max-stale\[=delta-seconds] | 告知(代理)服务器 客户端愿意接收一个超过缓存时间的资源，若有定义 delta-seconds，则为 delta-seconds 秒，若没有则为超过任意时间 |
| min-fresh=delta-seconds    | 告知(代理)服务器 客户端希望接收一个在 delta-seconds 秒内被更新过的资源                                                       |
| no-transform               | 告知(代理)服务器 客户端希望获取一个实体数据没有被转换(如压缩)过的资源                                                        |
| only-if-cached             | 告知(代理)服务器 客户端希望获取缓存的资源（若有）,而不用向原服务器发起请求                                                   |

* 作为 `Response Headers`时，`cache-directive` 支持以下可选值

| 字段名称                | 说明                                                                                                                                   |
| ----------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| public                  | 表明任何情况下都需要缓存该资源                                                                                                         |
| private\[="file-name"]   | 表明返回报文中全部或部分(若指定了*file-name*的字段数据)仅开放给某些用户(服务器指定的*share-use*)做缓存使用，其他用户则不能缓存这些数据 |
| no-cache                | 不直接使用缓存，要求向服务器发起（新鲜度校验）请求                                                                                     |
| no-store                | 所有内容都不会被保存到缓存或 Internet 临时文件中                                                                                       |
| max-age=delta-seconds   | 告知客户端该资源在*delta-seconds*秒内是新鲜的，无需向服务器发起请求                                                                    |
| s-max-age=delta-seconds | 同 max-age，但仅应用于 共享缓存                                                                                                        |
| no-transform            | 告知客户端缓存文件时不得对实体数据做任何改变                                                                                           |
| must-revalidate         | 当前资源一定是向原始服务器发去验证请求的，若请求失败会返回 504(而非代理服务器上的缓存)                                                 |
| proxy-revalidate        | 和 must-revalidate 类似，但仅应用于 共享缓存                                                                                           |

* 可以直接在 HTML 页面的`<head>` 中通过 meta 标签来给请求头加上 `Cache-Control` 字段：

  ```html
  <meta http-equiv="Cache-Control" content="no-cache" />
  ```

* `Cache-Control` 允许自由组合可选值：

  ```
  Cache-Control: max-age=3600, must-revalidate
  ```

  这段声明表示，该资源必须从原始服务器获取，且其缓存有效时间为一个小时，在后续的一个小时内，用户重新访问该资源都无需发送请求。

### 缓存校验

`Pragma`、`Expires`、`Cache-Control` 字段能够让客户端决定是否向服务器发送请求，缓存未过期的从本地缓存获取资源，缓存过期的从服务器端获取资源。

但是，客户端向服务器发送了请求，是否以为着一定要读取并返回该资源的实体内容？

* 如果一个资源在客户端的缓存时间过期了，但服务器并没有更新过这个资源，那服务端是否一定要重新把资源的实体内容返回？

* 如果这个资源过大，虽然缓存过期，但又没有更新过，返回实体内容是否会浪费带宽和时间？

对于这些问题，其实只要采取某种策略，让服务器知道客户端现在保存的缓存文件跟服务端的资源文件是一致的，
然后通知客户端该资源可以继续使用缓存文件，不需要重新返回资源实体内容。
那么就可以解决上述的问题，同时为 HTTP 请求带来优化和加速。

http1.1 新增了 `Last-Modified`、`ETag`、 `If-Match`、`If-None-Match`、`If-Modified-Since`、
`If-Unmodified-Since` 这些字段，用于对缓存资源的校验，提高缓存的复用率。

### Last-Modified

服务器将资源发送给客户端时，会将资源的最后更新时间以如下格式加载实体首部，一起返回给客户端。

客户端会为该资源标记上该信息，下次在请求时，会把该信息添加在请求报文中发送给服务端去做检查。
如果客户端上报字段时间值和服务端的对应资源的最后修改时间一致，则说明改资源没有被修改过，直接返回 304 状态码。

客户端在上报 Last-Modified 时，可以使用的 Request Headers 字段有两个：

* `If-Modified-Since`: 该字段格式如下

  ```
  If-Modified-Since: <Last-Modified-Value>
  ```

  字段告诉服务端，如果客户端上报的最后修改时间和服务器上的最后修改时间一致，则直接返回 304 和响应报头即可。

  当前各浏览器默认使用该字段用来向服务端上报保存的 Last-Modified 值。

* `If-Unmodified-Since`: 该字段格式如下

  ```
  If-Unmodified-Since: <Last-Modified-Value>
  ```

  字段告诉服务端，如果客户端上报的最后修改时间和服务端上的最后修改时间不一致，
  则应当返回 412（Precondition Failed）状态码给客户端。

Last-Modified 由于是使用的资源最后修改时间来确定资源是否有被修改，
但是在实际情况中，往往存在着一个资源被修改了但实际内容没有发生改变，
而由于资源最后修改时间已经发生改变，依然会返回整个实体内容给客户端，而其实内容跟客户端缓存内容一致。

### ETag

为了解决 `Last-Modified` 可能存在的不准确的问题，http1.1 还推出了 ETag 实体首部字段。

服务器会通过某种算法，给资源计算得出一个唯一标识符，在把资源响应给客户端的时候，会在实体首部加上该字段一起返回给客户端。

```
ETag: ETag-Value
```

客户端为资源标记上该信息，下次在请求时，会把该信息添加在请求报文中发送给服务端去做检查。
服务端只需要比较客户端传来的 ETag 和对应的该资源的 ETag 是否一致，就可以判断资源相对于客户端资源是否被修改过。
如果 ETag 是一致的，那么就直接返回 304 状态码，否则就返回新的资源实体内容给客户端。

客户端在上报 ETag 时，可以使用的 Request Headers 字段有两个：

* `If-None-Match` 该字段格式如下

  ```
  If-None-Match: <ETag-Value>
  ```

  字段告诉服务端，如果 ETag 没有匹配上，需要重新返回新的资源实体内容，否则直接返回 304 状态码。

  当前各浏览器默认使用该字段用来向服务端上报保存的 ETag 值。

* `If-Match` 该字段格式如下

  ```
  If-Match: <ETag-Value>
  ```

  字段告诉服务端，如果 ETag 没匹配到，或者收到了`"*"`值而当前没有该资源实体，
  则应当返回 412（Precondition Failed）状态码给客户端。否则服务器直接忽略该字段。

::: tip 提醒
如果 `Last-Modified` 和 `ETag` 同时被使用，则要求它们的验证必须同时通过才返回 304，
若其中一个没有通过，则服务器会按照常规返回资源的实体以及 200 状态码。
:::

## 次要的 HTTP Headers

以下的字段虽然跟缓存有关系，但没有那么重要。

### Vary

`Vary` 表示 服务端会以什么基准字段来区分、筛选缓存版本。

首先考虑一个问题，服务端有一个请求地址，如果是 IE 用户则返回针对 IE 开发的内容，否则返回另一个主流浏览器版本的内容。

一般来说，服务端获取到请求的 `User-Agent` 字段做处理即可。
但是如果用户请求的是代理服务器而非原始服务器，且代理服务器如果直接把缓存的 IE 版本资源发给了非 IE 的客户端，那就出问题了。

而 Vary 则是用于处理这类问题的头部字段，只需要在响应报文加上：

```
Vary: User-Agent
```

字段告知代理服务器需要以 User-Agent 这个请求头部字段来区别缓存版本，确定传递给客户端的版本。

Vary 字段也接受条件组合的形式

```
Vary: User-Agent, Accept-Encoding
```

字段告知代理服务器需要以 User-Agent 和 Accept-Encoding 两个请求头部字段来区别缓存版本。

### Date、Age

Date 字段表示原始服务器发送该资源的响应报文时间（GMT 时间）。
该字段的作用可以帮助我们判断该资源命中的是原始服务器还是代理服务器。

* 如果`Date`的时间与当前时间差别较大，或者连续 F5 刷新发现 Date 值没有变化，那么说明当前请求命中的是代理服务器的缓存。
* 如果每次刷新页面，浏览器每次都会重新发起这条请求，那么其 Date 的值会不断变化，说明该资源是直接从原始服务器返回的。

Age 字段表示某个文件在代理服务器中存在的时间（秒），如果文件被修改或替换，Age 会重新从 0 开始累计。

## 浏览器表现

### 强缓存

对于强缓存的资源：

* 当用户第一次访问该资源时，服务器返回 200 状态码，以及资源实体内容。

* 如果用户访问完第一次后，在没有关闭浏览器的前提下，进行了第二次或更多次资源访问，那么浏览器不再请求服务器，
  而是从 浏览器的内存缓存区取出资源，并且 状态码 标记为 `200 (memory cache)`

* 如果用户访问完第一次后，关闭浏览器后，重新打开浏览器，进行第二次或更多次资源访问，那么浏览器也不会请求服务器，

* 而是从 浏览器的磁盘缓存区取出资源，并且 状态码 标记为 `200（disk cache）`

### 协商缓存

* 当用户第一次访问该资源时，服务器返回 200 状态码，以及资源实体内容。

* 如果用户进行第二次访问时，进行缓存校验。 或在缓存时间内，或 资源未被修改，那么 直接返回 304 状态码

* 如果用户进行第二次访问时，服务器资源已被更新，则返回 状态码 200 ，以及新的资源实体内容。

---

---
url: /interview/lazyLoad/index.md
---
# 懒加载
在包含许多图片的长网页或应用中，如果一开始就加载所有图片，会导致页面加载缓慢，并且浪费用户的流量和服务器资源。

通过懒加载，页面在加载时只会加载当前可见区域的内容，而不会一次性加载所有图片。当用户滚动页面时，懒加载会动态地加载其他部分的内容，这样可以加快页面
加载速度，减少数据传输量，并提高用户体验。

在前端开发中，懒加载常用于图片、视频以及需要滚动页面才能看到的内容，比如加载更多的帖子或商品。这种技术帮助页面在开始时只加载必要的内容，用户需要查看
其他部分时再进行加载，从而减少初始加载时间。

总的来说，懒加载通过延迟加载页面内容或资源，能够提升页面加载速度，减少数据传输量，并优化用户体验，是一种重要的前端性能优化方法。

## 懒加载的实现原理

懒加载的实现原理主要涉及延迟加载页面中的内容，特别是图片和其他资源，以减少初始加载时的压力和等待时间。

具体来说，对于图片，它们通常是通过 src 属性来加载的。当网页加载时，浏览器会按照 src 的地址请求图片资源。懒加载的原理是利用 HTML5 中的 data-xxx 属性
（这里以 data-src 为例）来存储图片的路径。在需要加载图片时，通过 JavaScript 将 data-src 中的图片路径赋值给 src，这样就实现了图片的按需加载，即懒加载。

重点在于确定用户需要加载哪些图片。在浏览器中，用户可见区域内的资源是用户需要的资源。因此，当图片出现在可见区域时，我们可以获取图片的真实地址并赋值给
图片元素即可。

## 具体实现

### 原生 JavaScript

1. `window.innerHeight`：浏览器可视区域的高度
2. `document.body.scrollTop` 或 `document.documentElement.scrollTop`：浏览器已滚动的距离
3. `img.offsetTop`：图片顶部相对于文档顶部的高度（包括滚动条的距离）
4. 图片加载条件：`img.offsetTop < window.innerHeight + document.body.scrollTop`

### 利用前端框架

在 Vue 中，懒加载可以通过代码拆分和动态导入实现。
我们可以使用 Vue 的 defineAsyncComponent 来实现懒加载。
:::tabs
@tab Component.vue

```vue
<script>
export default {
  name: 'HelloWorld',
}
</script>

<template>
  <div>
    <p>This is a lazy-loaded component.</p>
  </div>
</template>
```

@tab App.vue

```vue
<script>
import { defineAsyncComponent } from 'vue'

export default {
  data() {
    return {
      isComponentLoaded: false,
      asyncComponent: null,
    }
  },
  methods: {
    loadComponent() {
      this.asyncComponent = defineAsyncComponent(() =>
        import('./components/Component.vue')
      )
      this.isComponentLoaded = true
    },
  },
}
</script>

<template>
  <div id="app">
    <h1>Vue Lazy Load Example</h1>
    <button @click="loadComponent">
      Load HelloWorld Component
    </button>
    <component :is="asyncComponent" v-if="isComponentLoaded" />
  </div>
</template>
```

:::

还可以使用 Vue 的第三方库[`vue-lazyload`](https://www.npmjs.com/package/vue-lazyload)通过 v-lazy 指令来实现图片的懒加载。

## 懒加载与预加载的区别

懒加载和预加载是为了提高网页性能而采取的两种不同策略。它们的核心区别在于一个是延迟加载，一个是提前加载，而且实现方式和影响也略有不同。

懒加载（也被称为延迟加载）的核心思想是：在用户需要访问图片或其他资源时，再去加载这些内容。这个策略可以减轻服务器的压力，因为不需要一开始就加载所有
资源。懒加载适用于网站中有很多图片，或者页面很长的情况，比如电商网站。它的实现原理是，当页面滚动时，判断图片是否进入了可视区域，如果是，就从事先
保存好的真实路径中获取图片地址，然后赋值给图片的 src 属性，这样就实现了图片的延迟加载。

预加载则是在页面加载过程中提前加载可能会在后续访问中用到的资源。这样一来，当用户需要某些资源时，可以直接从缓存中获取，而不需要重新请求服务器，从而
减少了等待时间，提高了用户体验。预加载通常应用于未来可能会用到的内容，例如提前加载下一个页面的资源、准备将要播放的视频或音频文件等。这样一来，用户
在真正需要这些资源时，可以立刻获取，而不必等待加载时间。

---

---
url: /interview/life/index.md
---
# 生命周期
::: tip 提问
简述一下 vue3 的组件生命周期
:::

## 生命周期

### 选项式

1. `beforeCreate` 在组件实例初始化完成之后立即调用。
2. `created` 在组件实例处理完所有与状态相关的选项后调用。
3. `beforeMount` 在组件被挂载之前调用。
4. `mounted` 在组件被挂载之后调用。
5. `beforeUpdate` 在组件即将因为一个响应式状态变更而更新其 DOM 树之前调用。
6. `updated` 在组件即将因为一个响应式状态变更而更新其 DOM 树之后调用。
7. `beforeUnmount` 在一个组件实例被卸载之前调用。
8. `unmounted` 在一个组件实例被卸载之后调用。
9. `errorCaptured` 在捕获了后代组件传递的错误时调用。

### 组合式

1. `onMounted()` 注册一个在组件挂载完成后执行的回调函数。
2. `onUpdated()` 注册一个回调函数，在组件由于响应性状态改变而更新了 DOM 树后调用。
3. `onUnmounted()` 注册一个要在组件卸载后调用的回调。
4. `onBeforeMount()` 注册一个钩子在组件被挂载之前被调用。
5. `onBeforeUpdate()` 注册一个钩子，在组件因为响应式状态改变而要更新 DOM 树之前调用
6. `onBeforeUnmount()` 注册一个钩子，在组件实例被卸载之前调用。
7. `onErrorCaptured()` 注册一个钩子，当从下级组件抛上来的错误被捕获时被调用。

---

---
url: /interview/LongConnection/index.md
---
# 长连接
## 短连接（Short Connection）

短连接是指客户端和服务器之间建立连接后，进行一次请求-响应后就断开连接。常见的协议如 HTTP/1.x 就是基于短连接的，每次请求都会建立一次新的连接。

**特点：**

1. 简单易用：每次请求都创建新的连接，不需要维护长时间的连接状态。
2. 负载较高：每次请求都需要建立新的连接，增加了连接的开销（如 TCP 连接的三次握手和四次挥手）。
3. 适合小流量应用：对于请求频率低且每次请求/响应的数据量较小的应用比较合适。

**适用场景：**

* 传统的 Web 应用、API 服务。
* 高并发的情况下，短连接避免了过多的连接占用，适合快速响应和简单的请求/响应模式。

## 长连接（Long Connection）

长连接则是指客户端和服务器之间建立一次连接后，可以复用这个连接进行多次请求和响应。HTTP/2 及 WebSocket 等协议都是基于长连接的。

**特点：**

1. 性能优越：因为连接只建立一次，后续的数据传输效率较高，避免了频繁的连接建立和关闭过程。
2. 资源消耗大：长连接需要保持客户端和服务器之间的连接状态，因此对服务器端资源的消耗较大，可能会导致连接过多时服务器负载过高。
3. 适合大流量和实时性强的应用：对于需要频繁交互和数据实时更新的应用，长连接可以显著降低延迟，提高效率。

**适用场景：**

* 实时通讯应用（如即时消息、在线游戏等）。
* 数据流传输密集型应用，如视频直播、股票行情等。
* API 需要高效传输大量数据的场景。
* 长连接的实现是基于 TCP 协议的持久连接机制，通常需要客户端与服务器建立一个 TCP
  连接，并在数据交互期间保持该连接不被关闭。这种机制相比于短连接的最大优势是减少了频繁建立和断开连接的开销，从而提高了通信效率。

## TCP 长连接原理

长连接是指客户端与服务器之间建立连接后，连接持续存在一段时间，不会因为一次请求-响应就关闭连接。
客户端和服务器通过这个持久的连接进行多次交互，直到主动关闭连接或发生超时。

### TCP 长连接的核心要点：

**三次握手建立连接：**

长连接首先通过 TCP 三次握手 建立连接。客户端发送一个 SYN 包到服务器，服务器响应一个 SYN-ACK 包，最后客户端再发送一个 ACK
包确认连接建立。 一旦连接建立，客户端与服务器就可以通过这个连接进行数据传输。

**连接复用：**

在长连接模式下，连接建立后不会被立即关闭，而是保持打开状态，等待未来的请求。客户端每次发送请求时，不需要重新建立连接，节省了建立和关闭连接的开销。

**数据传输：**

在连接保持期间，数据可以连续传输。在这期间，TCP 连接会保持一个 全双工通信，即双方可以在同一连接上同时发送和接收数据。

**TCP 保活机制：**

为了确保连接在长时间没有数据交换时不会被中断，TCP 提供了保活机制（TCP Keep-Alive）。如果没有数据传输，TCP
会定期发送空的数据包（keep-alive），以检查连接是否仍然有效。

**四次挥手关闭连接：**

当客户端或服务器不再需要数据交互时，连接会被关闭。这个过程通过 TCP 四次挥手 来完成，确保连接被优雅地关闭，避免数据丢失。

## 长连接的心跳和保活机制

由于长连接在长时间没有数据交互时可能会被网络中间设备（如路由器、防火墙等）关闭，因此需要有 心跳机制 或 保活机制 来保证连接的持续有效。

**心跳机制（Heartbeat）：**

心跳机制通过定期发送一些空数据包，或者一些低频率的请求来保持连接的活跃。这些请求和响应不会包含有效数据，仅用于确保连接仍然存在，并维持连接的存活。

**TCP Keep-Alive：**

TCP 协议本身也提供了 Keep-Alive 选项，它会在连接空闲时定期发送数据包以检查连接是否仍然活跃。服务器和客户端可以设置
Keep-Alive 的时间间隔。
如果双方在一定时间内没有数据交互，TCP 会自动发送 Keep-Alive 包（例如，每隔 60
秒发送一次），以确认连接是否仍然有效。如果长时间没有回应，则认为连接已经断开，进行相应的处理。

---

---
url: /interview/MVVM/index.md
---
# MVC/MVP/MVVM
::: tip 提问

1. MVC
2. MVP
3. MVVM
4. 区别

:::

::: info 说明
以上架构设计模式，仅限于在前端领域内进行说明。
:::

## Model\&View

* `Model` 是用于封装应用程序的业务逻辑的相关数据以及对数据的处理方法。

* `View` 作为视图层，主要负责数据的展示。

## MVC

`C` 是指 `Controller`。负责监听 `View` 的用户事件，得到数据后后 `Controller` 做一些处理，然后渲染 `View`。

`MVC` 通过分离 `Model`、`View` 和 `Controller` 的方式来组织代码结构。
`View` 和 `Model` 应用了观察者模式，当 `Model` 层发生改变的时候它会通知有关 View 层更新页面。
`Controller` 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，
`Controller` 中的事件触发器就开始工作了，通过调用 `Model` 层，来完成对 `Model` 的修改，然后 `Model` 层再去通知 View 层更新。

## MVP

`P` 是指 `Presenter`。`Presenter`会调用 View 层提供的接口去渲染 Model。

`MVP` 模式中，View 层的接口暴露给了 `Presenter`，
因此可以在 `Presenter` 中将 `Model` 的变化和 `View` 的变化绑定在一起，以此来实现 `View` 和 Model 的同步更新。
这样就实现了对 `View` 和 `Model` 的解耦，`Presenter` 还包含了其他的响应逻辑。

## MVVM

`VM` 是指 `ViewModel`。

`MVVM` 在`VM`中构建一组状态数据（state data），作为`View`状态的抽象。
然后通过 **双向数据绑定（data binding）** 使`VM`中的 **状态数据（state data）** 与`View`中的 **显示状态（screen state）**
保持一致。
这样，`VM`中的展示逻辑只需要修改对应的状态数据，就可以控制`View`的状态，从而避免在`View`上开发大量的接口。

---

---
url: /interview/newOperator/index.md
---
# new操作符
::: tip 提问

1. `new` 操作符 具体做了什么？
2. 如果实现 `new`？

:::

## new 操作符

1. 首先创建了一个空对象
2. 设置原型，将对象的原型指向函数的原型
3. 让函数的 `this` 指向这个对象的原型，并执行构造函数的代码
4. 判断函数的返回值类型，如果是值类型，返回创建的对象，如果是引用类型，返回这个引用类型的对象。

## 实现

```js
function newFactory(constructor, ...args) {
  if (typeof constructor !== 'function') {
    throw new TypeError('constructor must be a function')
  }

  const object = Object.create(constructor.prototype)
  const result = constructor.apply(object, args)

  if (
    result
    && (typeof result === 'object' || typeof result === 'function')
  ) {
    return result
  }
  else {
    return object
  }
}
```

---

---
url: /interview/PackageBuilder/index.md
---
# 模块打包器
::: tip 提问

1. 什么是模块打包器？
2. 有哪些常用的模块打包器？

:::

## 模块打包器

一个完整的前端项目，由各种各样的资源组成，包括 html 文件、css 文件、javascript 文件、图片文件等等。
我们可以认为这些资源文件就是一个个的模块。
模块打包器可以通过分析入口文件引用了哪些模块，这些模块又引用了哪些模块，通过模块之间的相互引用，获得模块依赖关系图。
通过模块依赖关系图，将这些模块进行合并，打包，执行输出，形成一个完整的可执行的前端项目资源包。

## 常用的模块打包器

* webpack
* rollup
* parcel
* esbuild
* vite
* snowpack

---

---
url: /interview/promise/index.md
---
# promise
::: tip 提问

1. 简单介绍一下 promise
2. 说一下 Promise A+ 规范

:::

参阅 [详解 promise](/article/q40nq4hv)

## promise

promise 是一个 异步编程解决方案，提供了一种 链式调用的方法，以一种更为扁平的方式处理复杂异步编程场景。
在早期使用 异步回调函数时，经常容易出现 在异步回调中写异步回调的回调嵌套地域，导致代码拥冗难以阅读。

`Promise`是一个构造函数，用于创建一个新的 Promise 对象，该构造函数主要用于包装还没添加 promise 支持的函数。

### 状态

promise 创建后，必然出于一下三种状态之一：

* `pending` 待定状态
* `fulfilled` 操作成功
* `rejected` 操作失败

当状态从 `pending` 更新到另外一种状态后，就再也不能变更为其他状态。

### 实例方法

* `.then()` 接受两个函数参数 ，状态从 pending 更新到另一个状态时触发
* `.cache()` 接受一个函数参数，状态从 pending 更新到 rejected 时触发
* `.finally()` 只要状态发生变化，所有 then() 和 catch() 执行完成后，最后执行 finally

### 静态方法

* `resolve(value)` 返回一个 状态为给定的 value 决定的 promise 实例
* `reject(reason)` 返回一个状态为失败的 promise 实例
* `all()` 传入一组 promise 实例并返回一个新的 promise 实例，当传入的 promises 状态均更新为成功时触发
  返回实例的状态更新为成功，否则更新为失败
* `allSettled()` 传入一组 promise 实例并返回一个新的 promise 实例，当传入的 promises 状态均更新到最终状态，
  触发返回实例 promise 的状态更新
* `race()` 传入一组 promise 实例并返回一个新的 promise 实例，只要传入的 promises 有一个状态更新到最终状态，
  触发返回实例 promise 的状态更新

## Promise A+ 规范

Promise A+ 规范 是 一个开放、健全且通用的 Javascript Promise 标准。

规范不设计如何创建、解决和拒绝 promise，而是专注于提供一个通用的 then 方法。

---

---
url: /interview/proto/index.md
---
# 原型和原型链
::: tip 提问

1. 什么是原型
2. 什么是原型链
3. 原型链与继承

:::

## 原型

Javascript 是一种基于原型的语言，同时，javascript 只有一种结构：对象。
每个实例对象都有一个私有属性 `__proto__`指向它的构造函数的原型对象`prototype`

## 原型链

原型对象`prototype`也有自己的原型对象`__proto__`，层层向上，直到有一个的原型对象为 null。根据定义，null 没有原型，并作为这个原型链的最后一个环节。

## 原型链与继承

`javascript` 对象是动态的属性"包裹"（指自身的属性）。同时，对象还有一个指向一个原型对象的链。
当访问一个对象的属性时，不仅会在该对象上查找，也会在该对象的原型上查找，进而在该对象的原型的原型上查找，
依次层层向上查找，直到找到匹配的属性，或者到达原型链的末尾。

当继承的函数被调用时，`this`指向的是当前继承的对象，而不是继承的函数所在的原型对象。

## 获取原型的方法

* `someObj.__proto__`
* `someObj.constructor.prototype`
* `Object.getPrototypeOf(someObj)`

---

---
url: /interview/reactive/index.md
---
# 响应式原理
::: tip 提问

1. 简单介绍一下 Vue 的响应式原理
2. vue2 和 vue3 的响应式对象有什么区别？

:::

## Vue 响应式原理

在 javascript 中，有两种劫持属性访问的方式： `getter/setter` 和 `Proxies`。
在`Vue3` 中，使用了 `Proxy` 来创建响应式对象。

* 在 Vue 中，跟数据关联的其他操作行为，被称为`副作用 effect`，Vue 内部会维护一个使用 `WeakMap` 定义的副作用队列，
  将副作用订阅都存储在其中。

  ```ts
  WeakMap<target, Map<key, Set<effect>>>
  ```

* 在 数据的 `getter` 方法中，使用 `track` 函数检查是否有正在运行的副作用，然后将这个副作用添加到该数据的订阅者 `Set` 中。

* 在数据的 `setter` 方法中，当数据发生改变，则找到该数据的所有订阅的副作用，然后一一执行这些副作用。

* 对于组件实例，将 DOM 渲染也认为是副作用的一种，数据更新时，同样会去执行这个副作用。

## Vue3 和 Vue2 实现响应式原理的区别

* 相比于 Vue2， Vue3 的由于采用了 `Proxy`的方式来实现响应式对象，
  响应式数据能够检测到响应式对象的属性的添加和删除

* 使用`WeakMap`数据结构来保存响应式对象的副作用，在响应式对象没有再被引用时，能够及时的被垃圾回收，减少内存开销。

---

---
url: /interview/rePaintFlow/index.md
---
# 重绘和重排
::: tip 提问

1. 请说说什么是重绘/重排
2. 什么时候会引起重绘/重排
3. 为什么 `transform` 的效率高

:::

## 什么是重排（reflow）？

reflow 的本质时重新计算布局树。

## 什么时候会触发重排？

当进行了会影响布局树的操作后，需要重新计算布局树，会触发 reflow。

为了避免连续的多次操作导致布局树的重复计算，浏览器会将 JS 中的同类操作代码全部完成后统一计算布局树。

## 什么是重绘（repaint）？

repaint 的本质就是重新根据分层信息计算了绘制指令。

## 什么时候会触发重绘？

当改动了可见样式后，就需要重新计算，引发 repaint。

由于元素布局信息也属于可见样式，因此 reflow 也会引起 repaint。

## 为什么 `transform` 的效率高

transform 既不会影响布局也不会影响绘制指令，它影响的只是 draw 阶段。

又由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。

---

---
url: /interview/SetElem/index.md
---
# 集合元素
集合对象是指： `Set`、 `Map` 、`WeakSet`、 `WeakMap`

::: tip 提问

简单介绍一下 `Set`、 `Map` 、`WeakSet`、 `WeakMap`

:::

## Set

`Set` 对象是**值**的集合，Set 中的元素只会出现一次，即 Set 中的元素值是唯一的。

* `Set.prototype.add()` 在当前实例的尾部添加一个元素，并返回当前 Set 实例
* `Set.prototype.clear()` 移除当前实例的所有元素
* `Set.prototype.delete()` 移除当前实例中的指定的元素
* `Set.prototype.has()` 判断当前实例中是否存在指定的元素
* `Set.prototype.entries()` 返回一个迭代器对象，该对象包含按照插入顺序排列所有元素的 `[value, value]`数组
* `Set.prototype.keys()` 同 `values()` 方法
* `Set.prototype.values()` 返回一个迭代器对象，该对象包含按照插入顺序排列的所有元素的值

## Map

`Map` 对象保存键值对，并且能够记住键的原始插入顺序。任何值都可以作为一个键或一个值。

* `Map.prototype.set()` 在当前实例添加或更新一个指定的键和值的键值对
* `Map.prototype.get()` 返回当前实例中的一个指定元素
* `Map.prototype.has()` 判断当前实例中是否存在指定元素，返回 布尔值
* `Map.prototype.delete()` 移除当前实例中指定元素
* `Map.prototype.clear()` 移除当前实例所有元素
* `Map.prototype.entries()` 返回一个迭代器对象，该对象包含按照插入顺序排列所有元素的 `[key, value]`数组
* `Map.prototype.keys()` 返回一个迭代器对象，该对象包含按照插入顺序排列的所有元素的键
* `Map.prototype.values()` 返回一个迭代器对象，该对象包含按照插入顺序排列的所有元素的值

## WeakSet

`WeakSet` 对象是一些对象值的集合，并且其中的每个对象值都只能出现一次，在集合中是唯一的。

`WeakSet` 和 `Set` 的区别：

* 与`Set` 相比，`WeakSet`只能是对象的集合，而不能是任何类型的任意值

* `WeakSet`集合中的对象的引用为弱引用。如果没有其他的对`WeakSet`中的对象的引用，那么这些对象会被当成垃圾回收掉。

* `WeakSet` 是不可枚举的。

* `WeakSet.prototype.add()` 在当前实例的尾部添加一个元素，并返回当前 Set 实例

* `WeakSet.prototype.delete()` 移除当前实例中的指定的元素

* `WeakSet.prototype.has()` 判断当前实例中是否存在指定的元素

## WeakMap

`WeakMap` 对象是一组 键值对 的集合，其中的键是弱引用的，且键必须是对象，而值可以是任意的。

`WeakMap` 和 `Map` 的区别

* `WeakMap` 的键必须是对象，值可以使任意的。

* 由于键是弱引用的，所以当键所指对象没有其他地方引用的时候，它会被 GC 回收掉。

* `WeakMap` 是不可枚举的。

* `WeakMap.prototype.set()` 在当前实例添加或更新一个指定的键和值的键值对

* `WeakMap.prototype.get()` 返回当前实例中的一个指定元素

* `WeakMap.prototype.has()` 判断当前实例中是否存在指定元素，返回 布尔值

* `WeakMap.prototype.delete()` 移除当前实例中指定元素

---

---
url: /interview/thisInFunction/index.md
---
# 函数中的this指向
| 调用方式          | 示例               | 函数中的 this 指向 |
| :---------------- | :----------------- | :----------------- |
| 通过 new 调用     | `new method()`     | 新对象             |
| 直接调用          | `method()`         | 全局对象           |
| 通过对象调用      | `obj.method()`     | 前面的对象         |
| call, apply, bind | `method.call(ctx)` | 第一个参数         |

> \[!note]
> 关于全局对象：
>
> 在浏览器环境中指向`window`
>
> 在 node 环境中指向`global`
>
> 关于箭头函数：
>
> 箭头函数是基于闭包的

---

---
url: /interview/triangle/index.md
---
# 画三角形
::: tip 提问

1. 如何用 css 画一个 三角形
2. 原理是什么？

:::

## 原理

由于 CSS 对于元素的边框，其相邻的边框的连接处，采用的是均分的处理方式，我们可以利用这个特性，
使用元素的边框，画一个三角形。

* 将元素的 display 属性设置为 block 或 inline-block；
* 宽高均设置为 0；
* 设置 border-width 为大于 1px 的值，border-style 为 solid；
* 设置 border-color， 仅保留一条边的颜色，其他边的颜色为透明

```css
.demo {
    display: block;
    width: 0;
    height: 0;
    border-width: 30px;
    border-style: solid;
    border-color: transparent transparent blue transparent;
}
```

:::: normal-demo CSS 三角形
::: code-tabs

@tab HTML

```html
<div class="triangle-demo"></div>
```

@tab CSS

```css
.triangle-demo {
    display: block;
    width: 0;
    height: 0;
    border-width: 30px;
    border-style: solid;
    border-color: transparent transparent cyan transparent;
}
```

:::
::::

---

---
url: /interview/vIfFor/index.md
---
# v-if和v-for
::: tip 提问

1. vue3 中 `v-if` 和 `v-for` 哪个优先级高？
2. 两个同时使用时，该如何优化？

:::

## 优先级

当 `v-if` 和 `v-for` 同时使用时， `v-if` 的优先级总是 高于 `v-for`。

这是 vue3 和 vue2 的其中一个重要的区别点。

在 vue3 中，最好不要同时使用 `v-if` 和 `v-for`。

## 优化

同时使用时，由于优先级的原因，总是先执行判断，确认条件为 true 是，才进行渲染和执行循环。

如果需要对列表中的每一项做条件判断：

* 在 `v-if` 所在的列表项外部包裹 一个 `<template>`， 在 `template` 上定义 `v-for` 和 `key`
* 提前使用 computed 属性过滤掉不需要的列表项，避免在模板渲染中不必要的判断和渲染

---

---
url: /interview/vIfShow/index.md
---
# v-if和v-show
::: tip 提问

1. `v-if` 和 `v-show` 有什么共同点？
2. 有什么区别？
3. 该如何选择使用哪个？

:::

## 共同点

* 都是 Vue 的内置指令
* 都能控制元素的**显示和隐藏**

## 区别

* `v-show` 是通过控制 元素 的 `display`， 通过设置为 `none` 来实现元素的隐藏，
  初始值无论是 true 或 false，都会进行编译，且只会编译一次，后续状态变更仅改变 `display`的值。
  频繁切换开销比较小。

* `v-if` 是 动态的向 DOM 树中插入和删除 DOM 元素，若初始值为 false，则跳过编译。
  后续状态变更，每次都会重新向 DOM 树中插入或删除 DOM 元素。
  频繁切换开销比较大。

## 选择

* 对于不需要频繁切换状态的，选择使用 `v-if`
* 对于频繁切换状态的，选择使用 `v-show`。

---

---
url: /interview/VirtualDOM/index.md
---
# 虚拟DOM
::: tip 提问

1. 什么是 Virtual DOM?
2. Virtual DOM 比 原生 DOM 快在哪里？

:::

## Virtual DOM

本质上，`Virtual DOM` 是一个普通的 javascript 对象。
我们将需要需要插入的文档的 DOM 树结构进行解析，使用一个对象结构进行表述，
比如一个元素对象，包含了 `TagName` , `props` , `attribute` ,`children` 等属性，
然后我们将这个对象结构保存起来，最后再将 DOM 片段插入到文档中。

当页面的状态发生变化，需要对页面的 DOM 结构进行调整的时候，首先根据变更的状态，重新构建一颗对象树，
然后将新的对象数和旧的对象数进行对比，记录下两颗树的差异，最后将有差异的地方应用到 DOM 树中，视图就实现了更新。

## Virtual DOM 比 原生 DOM 快在哪里？

首先，`Virtual DOM` 本身并没有比原生 DOM 直接操作 DOM 要快，但是 `Virtual DOM` 这种方法对于需要进行大量的 DOM 操作，
操作颗粒比较细、多、复杂的场景下，能够很好的提高操作效率。

通过在操作 DOM 前，通过 Diff 算法对比新旧两个`Virtual DOM`，我们可以 确定最小的更新范围，尽可能的减少 DOM 操作带来的回流和重绘的影响。

其目的是是提高了我们的开发时的可维护性，在任意情况下，都能保证在 `Virtual DOM` 带来的尽量小的性能消耗操作 DOM。

## DOM 树的比较

两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为
O(n)。

算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。

在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用
key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。

---

---
url: /interview/vuex/index.md
---
# 对vuex的理解
::: tip 提问

1. 简单说说你对 `vuex` 的理解

:::

### 回答策略

1. 说明 `vuex` 的定义
2. `vuex` 解决了什么问题
3. 什么时候需要 `vuex`
4. 具体用法
5. 简述原理，优缺点等

## 回答

> **官网定义:**
>
> Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

1. `vuex` 是 `vue` 官方开源并维护的状态管理库，它以 **全局的方式集中管理应用状态**，并保证应用状态变更的可预测性。
2. `vuex` 主要解决的问题是多组件之间状态共享的问题，利用各种组件通信方式，我们虽然能够做到状态共享，但是往往需要在多个组件之间保持状态的一致性，这种模式很容易出现问题，也会使程序逻辑变得复杂。
   `vuex` 通过把组件的共享状态抽取出来，以全局单例模式管理，这样任何组件都能用一致的方式获取和修改状态，响应式的数据也能够保证简洁的单向数据流动，我们的代码将变得更结构化且易维护。
3. `vuex` 并非必须的，它帮我们管理共享状态，但却带来更多的概念和框架。
   如果我们不打算开发大型单页应用或者我们的应用并没有大量全局的状态需要维护，完全没有使用 `vuex` 的必要。
   一个简单的 `store` 模式就足够了。反之， `vuex` 将会成为自然而然的选择。
   引用 `Redux` 的作者 `Dan Abramov` 的话说就是：Flux 架构就像眼镜：您自会知道什么时候需要它。
4. 我在使用 `vuex` 过程中有如下理解：首先是对核心概念的理解和运用，将全局状态放入 `state` 对象中，
   它本身一棵状态树，组件中使用 `store` 实例的 state 访问这些状态；
   然后有配套的 `mutation` 方法修改这些状态，并且只能用 `mutation` 修改状态，
   在组件中调用 `commit` 方法提交 `mutation` ；如果应用中有异步操作或者复杂逻辑组合，
   我们需要编写 `action` ，执行结束如果有状态修改仍然需要提交 `mutation` ，
   组件中调用这些 `action` 使用 `dispatch` 方法派发。最后是模块化，
   通过 `modules` 选项组织拆分出去的各个子模块，在访问状态时注意添加子模块的名称，
   如果子模块有设置 `namespace` ，那么在提交 `mutation` 和派发 `action` 时还需要额外的命名空间前缀。
5. `vuex` 在实现单项数据流时需要做到数据的响应式，通过源码的学习发现是借用了 `vue` 的数据响应化特性实现的，它会利用 Vue 将
   `state` 作为 `data` 对其进行响应化处理，从而使得这些状态发生变化时，能够通知组件重新渲染。

---

---
url: /interview/webpack/index.md
---
# webpack
::: tip 提问

1. 对 webpack 的了解
2. webpack 的工作原理
3. loader 和 plugin 有什么区别
4. webpack 优化

:::

## webpack

webpack 是一个用于现代 javascript 应用程序的静态打包工具。

## 工作原理

1. 读取`webpack`配置参数
2. 启动`webpack`，创建`compiler`对象，开始解析项目
3. 从入口文件`entry`开始解析，并找到其导入的**依赖模块**，递归遍历分析，形成**依赖关系树**
4. 对不同的文件类型资源的依赖模块文件，使用对应的`Loader`进行转换，最终转为`webpack`的有效模块
5. 在编译过程中，`webpack`通过**发布订阅模式**，向外抛出一些`hooks`，`webpack`的`Plugin`通过监听各个`hooks`，
   执行插件任务，扩展`webpack`的功能，干预输出结果
6. 根据输出配置`output`，将打包构建好的资源文件输出

## loader

将其他类型的资源文件转换为 webpack 能够处理的有效模块。

## plugin

plugin 是 webpack 的核心功能，其目的是在于解决 loader 无法解决的其他事上。

plugin 可以在 webpack 访问到 webpack 的整个生命周期，并且可以访问到 compile 对象，以及当前编译过程对象`compilation`,
这使得 plugin 拥有非常强大的能力。

## loader 和 plugin 的区别

loader 仅能对其关联的模块类型进行解析转换，不能访问到 webpack 的整个生命周期

plugin 是对 webpack 的扩展，可以访问到 webpack 整个生命周期。

## webpack 优化

以下内容是针对`webpack@5`的优化方向建议：

### 构建流程分析

在进行优化前，首先要搞清楚有哪些地方出现了痛点，需要进行优化。

* 编译速度分析

  借助`speed-measure-webpack-plugin`插件，可以帮助我们获取插件、loader 的耗时。
  消耗时间比较长的，认为可以优化的，则放到优化计划中。

* 打包体积分析

  借助`webpack-bundle-analyzer`插件，可以帮助我们获取打包后生成的 bundle 的体积中，各个模块的位置、体积等信息。

### 编译速度优化

1. 配置缓存方案。

   在 webpack 的配置文件中 声明 配置：`{ cache: { type: 'filesystem } }`,来启用对模块和 chunk 的持久缓存。
   可以大幅度优化 二次启动构建速度、打包速度等。

2. 对使用的 loader，根据其作用，指定 include 或者 exclude，减少 loader 的应用范围。

3. 管理资源

   使用 webpack5 内置的`asset/resource`代替`assets loader`(如， url-loader、file-loader、raw-loader)。

4. 多进程打包编译

   使用`thread-loader`将耗时长的 loader 进行包装，放到其他的线程中进行处理。

### 打包体积优化

重复多次出现的模块，可以抽到共享 chunk 中，非首屏加载必须的模块，可以抽到异步 chunk 中。

（还有对各种资源进行压缩等）

---

---
url: /jotting/index.md
---
# L0v3ch4n的随笔
L0v3ch4n 的一些小想法和生活记录。

---

---
url: /jotting/2024年祭/index.md
---
# 2024年祭
::: center
是谁除夕夜还在写年祭？啊是我啊，那没事了。

现在在边看拜年祭边码字，今年的拜年祭也是文艺复兴了（）。
:::

> \[!note]
> ::: center
>
> 人生也会经历隧道，里面没有多余的光亮。
> :::

好久没写作文了，突然想看看我还有多少流水账水平 hhh.

## Work Hard to do Hard Works

> 不积跬步，无以至千里；不积小流，无以成江海。

今年也算是正式开始写项目了，也是做出了点结果。

先是借软原课程的机会，写了个[OJ 平台](http://oj.l0v3ch4n.top)的雏形，现在也是把 demo 放到服务器上了。

然后就是给校队写了个介绍网站来~~骗~~个优秀团队的奖项（本来以为能出道即巅峰，结果就是石沉大海）。

> 这边宣传一下咱们[\*C\* Team](https://starcstar.club/)，欢迎南航的同学们加入喔！

十二月接了个项目，写一个微信小程序，实现一个与硬件交互的功能。也是第一次学习使用 Uni-app 框架写小程序，拿 vue 写小程序，和之
前硬搓 wxml、wxjs、wxss 的感觉完全不一样，真舒服。一边写一边还学了些关于蓝牙连接的知识，后面也许会写个文章来细嗦踩过的坑。

然后就是被拉去给参与运营的频道写 qq 机器人，也算是了解了官方机器人的写法了 ~~（tx 官方机器人真的好无能，全是限制，有些能力还
不开放）~~ 。现在计划把项目从 Python 向 Node 迁移，或者干脆自己写个框架得了（tx 的摆烂式更新真的受不住）。

::: center

> 也是上线到服务器了。
> :::

## 又菜又爱玩

> 世界好大，出去看看。

今年也是参加了不少比赛，有正经的还有不正经的（废话）。

先是四月份的长城杯，去广州的时候遇到了超绝 14h 延误。

::: center

> 晚上六点延误到第二天八点，超绝 14h 延误。
> :::

最后也是顺利拿到了航司的赔偿，但是最后还是因为天气原因迫降了深圳宝安机场，一行人租了辆车开到赛场。

接着就是上半年的校赛，被 CTFer 们包围了。

::: center

> 哎哎，微信压画质的大手，哎哎。
> :::

暑假，训练。然后进了一把键盘，挺好看的。

暑假结束后参加了魔方比赛，第一次参加魔方比赛，拿了个优秀奖（参加就有）。

::: center

> 呜呜我好菜，呜呜。
> :::

暑假结束之后论文也是见刊了，参加了 NUAA 本科生学术论坛，混到了一等奖。

## 游戏人生

> 人生得意须尽欢，莫使金樽空对月。

元旦那天在原神里和群友跨年了，也是锄了一年的地了。宿舍外面就是大伙围着篝火看着跨年晚会赏着烟花，所有人都觉得 2024 会对自己
好一点。

::: center

> 希望 2025 真的会对我好一点。
> :::

接着就是团建，今年和大家出去玩的机会好多。

> 团建，团建，狠狠团建！

先甩几张合影出来：

有记录最多的就是一年一度的 Asuri 冬至团建了。

::: center

> 今年的冬至团建场地真不错，就是大通铺漏风，睡醒后感冒了。
> :::

::: center

> 好哥哥们一起做的冬至大餐，超级丰盛！
> :::

::: center

> 邵哥哥唱的《安静》全是感情，~~每天都要忍不住循环几遍~~。
> :::

讲真，我台球全是团建的时候玩出来的，现在也还是一个半吊子，蛮喜欢一群人围着球桌指点江山的感觉。

> 我长台贼溜（认真）。

## 后记

写到这里也是快十二点了，马上就是新的一年了，外面也是烟花爆竹声声不绝。立个 Flag，明年一定好好学习，好好生活。

感觉流水账功底流失得差不多了，已经不会扯犊子了 xs。

> \[!important]
> :::center
>
> ## 2025 请对我好一点！！！！！！！！！！！！！！
>
> :::
>
> :::center
> 人生也会经历这样的隧道里面没有多余的光亮，
>
> 但始终会开往前方的下一站不会离了方向。
> :::

---

---
url: /jotting/AugIn2025/index.md
---
# 八月祭
这个月是今年过的比较舒服的一个月了。

从实践中也是学到了好多东西，工程上的问题解决起来太有成就感了。

---

---
url: /jotting/Half2025/index.md
---
# 上半年小祭
差不多 2025 已经走过了一半了。想来感觉又是半年的时光虚度，小记一下。

## 比赛

应该算是退役了，虽说一开始只是感觉好玩入坑 CTF 的，但是上半年的国赛分区赛落幕后大抵还是有些感慨。

总的来说，收收心好好准备考研吧（逃）。

## 实习

上半年往好些公司投了简历，仓促地走完了笔试面试流程，最终只收到了一家微创企业的 offer。
复盘表示自己的技术还是太菜了，目前来说还是爱好者的水平（至少还不能完全靠现有的技术进行自己的养活）。

目前是在做学校的项目式实习，为 oj 系统做点小贡献——现在的小登吃的真是好啊，啥啥优化都给他们碰上了。

## 一些想法

和家里出了些矛盾，最近情绪极易波动。感觉得好好冷静思考一下以后该怎么走了。

这半年来想清楚了好些事情，也是大致上认清了自己的定位——一个简单的、平凡的小人物。

> 实话说，真的不想甘愿平凡，但是也许接受自己的平凡也算一种不凡吧……

---

---
url: /jotting/MarchIn2025/index.md
---
# 3月祭
**“我”死在了过去。**

> 忙忙碌碌，一苇以航。
>
> 若是早知会失去，你又会不会珍惜；若是早知难免分离，你又会不会寻寻觅觅？

三月终究还是对我下了狠手。

月初手忙脚乱地投了简历，仓促地过完了笔试面试。得到了什么，我不清楚。

> 每个人心中都有过一种莫名的冲动，那瞬间即逝足以让生命为之而动容。
>
> 它叫做热血，来形容梦想的热度；只是最后也散场各走各路。

总之就是不停的面试，复盘，然后接受失败。也是遭受了大挫折，emo 了好几天（哎哎）。

> 世界很大我很小
>
> 现实和梦境很容易混淆
>
> 年轻的生命不停地奔跑

回首来看，这些伤痛也未必不是对自己的锤炼呢？
至少现在来看，在这段时间中汲取到的不止是伤痛，还有振翅高飞的动力。

---

---
url: /jotting/NovemberIn2024/index.md
---
# 11月祭
::: center
这个十一月，过得很痛苦。
:::

> \[!note]
> ::: center
>
> 命运明明有千百张面孔，却为何只向我们展示这一副面相？
> :::

## ICPC 南京站志愿者 ~~（编外）~~

月初就参与了 ICPC 亚洲区域赛南京站的志愿者活动，作为半个技术参与了一些准备工作。

### 赛前准备

::: center
我拥有的知识 VS 我所面对的难题
:::

周五晚上给电脑装系统装到凌晨两点（第二天早上九点就需要到会场）。

> 至今也没搞懂为什么串行安装能不出一点错但是开始改用并行就哐哐出错；为什么放桌上能装上放地上就不行。
>
> 到后面都开始敲电子木鱼了（bushi）

::: center

> 计算机，很神奇吧？
> 计算机真的没有玄学吗？
> :::

装完电脑的第二天（哦准确来说是同一天），我重生了，重生在南航当袋鼠。

::: center
重生之我在南航当袋鼠
:::

### 比赛中

然后就是正式比赛的事情惹，jiangly 哥哥 tql！（什么都不懂跟风的）

经过前几天的折腾基本走不动路了，就坐在打印室看看比赛直播解说，顺便抽中了个袋鼠（这下真是黑幕了）。

比赛结束后直奔什么“职业生涯体验活动”光速完成任务，回来正好看滚榜解说 ~~（怎么大伙取名都变这么正经了，没啥节目效果）~~。

> 全窝在打印室休息了都没怎么拍照

### 赛后

首先是跟技术组大大们合了影：

::: center
技术组合影
:::

然后就是搬东西，搬到八点在 106 小憩一会出去吃饭。

::: center
一群袋鼠正在看着你.jpg
:::

### 总结

好累，三天走下来感觉脚都不是我的了。

::: center
这三天的微信步数，猛猛淦
:::

## 软件工程原理第四份报告

好像叫什么……系统设计报告来着。

画软件界面，不知道别人用的是什么设计软件，我~~们组~~用的是`WebStorm`。

总的来说就是别人画界面，我写界面 hhh。

::: center
莫名其妙地就想到了这个灵感，我也不知道是怎么想到的。
:::

一通操作猛如虎，回头一看十个小时。

::: center
我也想知道怎么才能做到在电脑前码这么久的代码。
:::

> 哦这张 Waka 是待会要讲的编译原理课设，但是这也能看出来写了好长时间的前端了。

## 电脑的升级

期间趁着双十一，给电脑扩了 2TB（那时的三星的 990 EVO Plus 还是挺香的）。

顺便组了个双系统，本来想着还是 win 主力，搞个 Linux 玩玩；
结果发现 Linux 变成主力系统，win 变成游戏启动器了（倒反天罡 xs）。
Linux 用下来感觉超级舒服，特别是关机的时候不用怎么管进程关没关（Linux Swap 赛高）。

好现在压力来到 Linux，一开始装的是 Ubuntu，没几天就玩坏了（我真是系统杀手）。
于是花了两天从 0 开始装了一个 ArchLinux（难装是真的难装，但是真的很香）。

![fastfetch.jpg](https://file.l0v3ch4n.top/L0v3ch4n-Docs-images/notes/OS/ArchLinux/setup/fastfetch.jpg)

::: center
I use Arch btw. :laughing:
:::

后面还整了这些贴纸，感觉好有意思。

::: center
看看有几个 logo 是错的呀（憋笑）
:::

## 编译原理课设

说回编译原理课设。这东西写了好久，特别是精心编了好多样例。结果验收的时候就测了几个草草通过了（？）

那几天的 C++时长就是靠这个撑起来的。

> 现在见到了好多精美的设计，~~打算重构了说是~~。

## 计网考试

一刻也没为编译原理课设哀悼，现在赶到战场的是——计网考试！

复习下来就一个感觉：牛哥 nb！

考试那天的中午先摔了一次车（记得上一次摔车还是在上次）。

::: center
皮糙肉厚没啥事，就是现在还是有点痛（悲）
:::

> 最后提前半个小时交卷了，美名其曰 UDP 协议。
>
> ::: center
> 学计网学的
> :::

## NOIP 监考

这不刚监考完就来写这篇月祭了（）

这次是监考高中生，幺蛾子比小初生少多了 ~~（怎么感觉在骂人，我指的是小学生和初中生嗷）~~。
这场考试也有身残志坚者：

::: center
身残志坚者的座驾
:::

监考完感觉能量完全流失了，现在在啃早上剩下的玉米撑着（不嘻嘻）。

## 月末总结

累了，倦了，毁灭吧。

> \[!important]
> :::center
>
> ## 十二月请对我好一点！！！！！！！！！！！！！！
>
> :::
>
> ::: center
> 三证合一，完结撒花
> :::

> \[!tip]
> 哦还有这个罗森的饭，￥ 16.9 就能有两种肉还有蛋的饭在罗森真是稀有物品。
>
> ::: center
> “这个肉真的会是肉吗？“ dw 如是说。
> :::

---

---
url: /language/index.md
---
# 语言学习
主要记录 L0v3ch4n 的一些语言学习记录以及编程语言教程。

## 更新日志

2025-2-3: 编写了 Python《快速开始》部分的内容。

2025-3-12: 编写了 JavaScript《基础语法》部分的内容。

---

---
url: /language/Go/Basic/index.md
---
# 基本语法
## 程序结构

一个最简单的 Go 程序如下：

```go
package main  // 声明包名，可执行程序必须在 main 包下

import "fmt"  // 导入标准库的格式化输出包

func main() { // main 函数是程序执行的入口
    fmt.Println("Hello, World!")
}
```

* **包管理**：Go 通过包来组织代码。`import` 导入所需包，`go.mod` 文件管理项目依赖。
* **入口函数**：`func main()` 是唯一且必需的执行起点。

## 变量与常量

Go 是静态类型语言，但支持类型推断。

```go
// 1. 标准声明： var 变量名 类型 = 值
var name string = "Alice"
var age int = 30

// 2. 类型推断（最常用）：使用 := 短变量声明
city := "Beijing" // 编译器自动推断 city 为 string 类型
score := 95.5     // 推断为 float64 类型

// 3. 批量声明
var (
    isStudent bool   = true
    salary    float64
)

// 4. 常量声明
const Pi = 3.14159
const (
    StatusOK = 200
    StatusNotFound = 404
)
```

**核心要点**：

* 函数内推荐使用短变量声明 `:=`。
* 变量声明后必须使用，否则编译报错（这有助于保持代码整洁）。

## 基本数据类型

Go 的内置基础类型非常清晰：

| 类型                                  | 说明                                 | 示例               |
| :------------------------------------ | :----------------------------------- | :----------------- |
| **`bool`**                            | 布尔值                               | `true`, `false`    |
| **`string`**                          | 字符串                               | `"hello"` (不可变) |
| **`int`, `int8`, `int64`, `uint`...** | 整型系列                             | `42`, `-1`, `0xFF` |
| **`float32`, `float64`**              | 浮点型                               | `3.14`, `1.0e-10`  |
| **`byte`**                            | `uint8`的别名，代表一个 ASCII 字符   |                    |
| **`rune`**                            | `int32`的别名，代表一个 Unicode 码点 |                    |

## 流程控制

Go 的流程控制语句很直观，条件表达式**不需要括号**。

```go
// 1. 条件判断 (if)
if age >= 18 {
    fmt.Println("成年")
} else if age > 12 {
    fmt.Println("青少年")
} else {
    fmt.Println("儿童")
}

// 2. 循环 (for) - Go只有for一种循环关键字
// 类似C语言的for
for i := 0; i < 10; i++ {
    fmt.Println(i)
}
// 类似while循环
sum := 0
for sum < 100 {
    sum += 10
}
// 无限循环
for {
    // ... 通常配合break使用
}

// 3. 分支选择 (switch)
grade := "B"
switch grade {
case "A":
    fmt.Println("优秀")
case "B", "C": // 多条件匹配
    fmt.Println("良好")
default:
    fmt.Println("其他")
}
```

## 复合数据类型：数组、切片、映射

这是最常用、最重要的三种数据结构。

* **数组**：长度固定的序列，不常用。
  ```go
  var arr [3]int = [3]int{1, 2, 3}
  ```

* **切片**：**长度可变的动态数组，这是 Go 中最核心的数据结构**。它基于数组，但提供了强大的灵活性和易用性。

  ```go
  // 创建切片（最常用）
  s := []int{1, 2, 3}
  s = append(s, 4, 5) // 动态追加元素
  fmt.Println(s[1:3]) // 切片操作，输出 [2 3]

  // 使用make创建指定长度和容量的切片
  nums := make([]int, 0, 5) // 长度0，容量5
  ```

* **映射**：键值对集合，在其他语言中常被称为字典或哈希表。

  ```go
  // 创建映射
  m := make(map[string]int)
  m["Alice"] = 25
  m["Bob"] = 30

  // 直接初始化
  scores := map[string]int{"math": 90, "english": 85}

  // 判断键是否存在
  if age, ok := m["Charlie"]; ok {
      fmt.Println(age)
  } else {
      fmt.Println("键不存在")
  }
  ```

## 函数

Go 函数支持多返回值，这是其一大特色，广泛用于错误处理。

```go
// 基本函数
func add(a int, b int) int {
    return a + b
}

// 多返回值（最常见的模式：返回值 + 错误信息）
func divide(a, b float64) (float64, error) {
    if b == 0.0 {
        return 0, errors.New("除数不能为零")
    }
    return a / b, nil // nil 表示没有错误
}

// 调用函数并处理错误
result, err := divide(10, 2)
if err != nil {
    fmt.Println("出错:", err)
} else {
    fmt.Println("结果:", result)
}
```

## 结构体与方法：面向对象的基石

Go 没有“类”的概念，使用**结构体**来封装数据，并通过**方法**为其定义行为。

```go
// 定义结构体
type Person struct {
    Name string
    Age  int
}

// 为结构体定义方法（值接收者）
func (p Person) SayHello() {
    fmt.Printf("你好，我是 %s，今年 %d 岁。\n", p.Name, p.Age)
}

// 方法也可以使用指针接收者（可以修改结构体内部数据）
func (p *Person) HaveBirthday() {
    p.Age++ // 这里使用指针才能实际修改原结构体的Age
}

func main() {
    // 初始化结构体
    p1 := Person{Name: "小明", Age: 20}
    p1.SayHello() // 输出：你好，我是小明，今年20岁。

    p2 := &Person{Name: "小红", Age: 18} // p2 是一个指针
    p2.HaveBirthday()
    fmt.Println(p2.Age) // 输出：19
}
```

**这是理解 Gin 中数据绑定的关键**。在 Gin 中，经常会定义结构体来接收 HTTP 请求的 JSON 数据。

## 接口：实现多态

接口定义了一组方法的集合。**任何实现了接口所有方法的类型，都隐式地满足了该接口**。这是一种强大的抽象方式。

```go
// 定义一个“说话者”接口
type Speaker interface {
    Speak() string
}

// Person 类型实现 Speaker 接口
func (p Person) Speak() string {
    return "我是人，我叫" + p.Name
}

// 另一个类型 Dog
type Dog struct { Name string }
func (d Dog) Speak() string {
    return "汪汪，我是" + d.Name
}

// 函数接收 Speaker 接口类型
func introduce(s Speaker) {
    fmt.Println(s.Speak())
}

func main() {
    p := Person{Name: "Alice"}
    d := Dog{Name: "Buddy"}

    introduce(p) // 输出：我是人，我叫Alice
    introduce(d) // 输出：汪汪，我是Buddy
}
```

## 错误处理

Go 没有传统的`try-catch`异常机制，而是将错误作为普通的值返回（多返回值）。必须显式地检查并处理错误。

```go
file, err := os.Open("filename.txt")
if err != nil {
    // 处理错误：记录日志、返回错误、程序终止等
    log.Fatal("打开文件失败:", err)
}
defer file.Close() // defer 确保函数返回前关闭文件，是资源管理的常用手法

// ... 正常操作文件
```

**`error`是一个内置接口**，任何实现了`Error() string`方法的类型都可以作为错误。

## 10. 并发入门：goroutine 与 channel

这是 Go 语言的杀手锏，但在初学阶段了解其基本概念即可。

* **goroutine**：由 Go 运行时管理的轻量级线程。使用`go`关键字即可启动。
  ```go
  func say(s string) {
      for i := 0; i < 3; i++ {
          time.Sleep(100 * time.Millisecond)
          fmt.Println(s)
      }
  }
  func main() {
      go say("world") // 在新的goroutine中执行
      say("hello")    // 在当前goroutine中执行
  }
  ```
* **channel**：用于在 goroutine 之间安全地传递数据。
  ```go
  ch := make(chan int) // 创建一个传递int类型的channel
  go func() {
      ch <- 42 // 向channel发送数据
  }()
  value := <-ch // 从channel接收数据
  fmt.Println(value) // 输出: 42
  ```

---

---
url: /language/Go/FileOperation/index.md
---
# 文件操作
Go 语言的文件操作主要依赖 `os`、`io`、`io/ioutil` 和 `bufio` 等标准库包。它遵循 **“显式错误处理”** 和 **“对底层控制友好”** 的设计哲学。

## 一、核心包与核心理念

* **`os`**：提供了与操作系统交互的核心函数，包括文件的打开、创建、删除、重命名、获取属性等。
* **`io`**：定义了基本的 I/O 接口，如 `Reader` 和 `Writer`。
* **`io/ioutil`**（Go 1.16+后部分函数移至 `os` 和 `io` 包）：提供了一些实用的工具函数。
* **`bufio`**：提供带缓冲的 I/O，提升读写效率。
* **`path/filepath`**：用于跨操作系统的路径处理。

**核心理念**：

1. **打开的文件是资源**，必须显式关闭（通常使用 `defer`）。
2. **错误必须显式检查**，几乎所有文件操作都会返回 `error`。
3. 提供了**不同粒度**的操作方式，从一次性读取到带缓冲的流式处理。

## 二、基础文件操作

### 1. 打开与关闭文件

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    // 1. 只读方式打开文件
    file, err := os.Open("test.txt")
    if err != nil {
        // 文件不存在或无权限时，err不为nil
        panic(fmt.Sprintf("打开文件失败: %v", err))
    }
    defer file.Close() // 确保函数退出前关闭文件，释放资源

    // 2. 使用OpenFile指定更复杂的模式
    // os.O_RDWR：读写模式
    // os.O_CREATE：如果不存在则创建
    // os.O_APPEND：追加模式
    // os.O_TRUNC：打开时清空文件
    // 0644：Unix风格的文件权限（所有者可读写，其他人只读）
    file2, err := os.OpenFile("data.txt", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644)
    if err != nil {
        panic(err)
    }
    defer file2.Close()

    fmt.Println("文件打开成功")
}
```

### 2. 读取文件

Go 提供了多种读取方式，适应不同场景。

```go
import (
    "os"
    "io/ioutil"
    "bufio"
    "fmt"
)

// 方法1：一次性读取整个文件（适用于小文件）
func readAllAtOnce(filename string) {
    data, err := os.ReadFile(filename) // Go 1.16+ 推荐
    // 或使用旧的：ioutil.ReadFile(filename)
    if err != nil {
        panic(err)
    }
    fmt.Printf("文件内容:\n%s\n", data)
}

// 方法2：使用bufio.Scanner按行读取（最常用）
func readByLine(filename string) {
    file, err := os.Open(filename)
    if err != nil {
        panic(err)
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)
    lineNum := 1
    for scanner.Scan() { // 每次读取一行
        line := scanner.Text()
        fmt.Printf("第%d行: %s\n", lineNum, line)
        lineNum++
    }

    if err := scanner.Err(); err != nil {
        panic(err)
    }
}

// 方法3：使用缓冲区读取（适合大文件或需要控制读取过程）
func readWithBuffer(filename string) {
    file, err := os.Open(filename)
    if err != nil {
        panic(err)
    }
    defer file.Close()

    buffer := make([]byte, 1024) // 1KB的缓冲区
    for {
        n, err := file.Read(buffer) // n是实际读取的字节数
        if n > 0 {
            fmt.Printf("读取到 %d 字节: %s\n", n, string(buffer[:n]))
        }
        if err == io.EOF { // 到达文件末尾
            fmt.Println("文件读取完毕")
            break
        }
        if err != nil {
            panic(err)
        }
    }
}
```

### 3. 写入文件

```go
import "os"

// 方法1：一次性写入整个文件（会覆盖原内容）
func writeAllAtOnce(filename string, content []byte) {
    err := os.WriteFile(filename, content, 0644) // Go 1.16+
    // 旧版：ioutil.WriteFile(filename, content, 0644)
    if err != nil {
        panic(err)
    }
}

// 方法2：使用bufio.Writer缓冲写入（适合多次写入）
func writeWithBuffer(filename string, lines []string) {
    file, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
    if err != nil {
        panic(err)
    }
    defer file.Close()

    writer := bufio.NewWriter(file)
    for _, line := range lines {
        _, err := writer.WriteString(line + "\n")
        if err != nil {
            panic(err)
        }
    }
    writer.Flush() // 必须调用，确保缓冲区数据写入磁盘
}

// 方法3：直接写入（简单场景）
func writeDirectly(filename string) {
    file, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
    if err != nil {
        panic(err)
    }
    defer file.Close()

    _, err = file.WriteString("追加一行内容\n")
    if err != nil {
        panic(err)
    }
}
```

## 三、文件与目录管理

### 1. 检查文件/目录是否存在

```go
func checkFileExists(filename string) bool {
    _, err := os.Stat(filename)
    if err == nil {
        return true
    }
    if os.IsNotExist(err) {
        return false
    }
    // 其他错误（如权限不足）
    panic(err)
}
```

### 2. 获取文件信息

```go
func getFileInfo(filename string) {
    info, err := os.Stat(filename)
    if err != nil {
        panic(err)
    }

    fmt.Printf("文件名: %s\n", info.Name())
    fmt.Printf("大小: %d 字节\n", info.Size())
    fmt.Printf("是否是目录: %v\n", info.IsDir())
    fmt.Printf("修改时间: %v\n", info.ModTime())
    fmt.Printf("权限: %v\n", info.Mode())
}
```

### 3. 目录操作

```go
func directoryOperations() {
    // 创建目录
    err := os.Mkdir("mydir", 0755)
    if err != nil && !os.IsExist(err) {
        panic(err)
    }

    // 创建多级目录
    err = os.MkdirAll("path/to/nested/dir", 0755)
    if err != nil {
        panic(err)
    }

    // 读取目录内容
    entries, err := os.ReadDir(".") // Go 1.16+
    // 旧版：ioutil.ReadDir(".")
    if err != nil {
        panic(err)
    }

    fmt.Println("当前目录内容:")
    for _, entry := range entries {
        name := entry.Name()
        if entry.IsDir() {
            fmt.Printf("[目录] %s/\n", name)
        } else {
            info, _ := entry.Info()
            fmt.Printf("[文件] %s (%d bytes)\n", name, info.Size())
        }
    }

    // 删除文件或空目录
    os.Remove("file.txt")
    os.RemoveAll("path/to/nested/dir") // 删除目录及其所有内容
}
```

### 4. 文件路径处理

**重要**：不要直接用字符串拼接路径，使用 `path/filepath` 包。

```go
import "path/filepath"

func pathExamples() {
    // 拼接路径（自动处理操作系统差异）
    fullPath := filepath.Join("dir", "subdir", "file.txt")
    fmt.Println(fullPath) // 在Windows输出: dir\subdir\file.txt

    // 获取绝对路径
    absPath, _ := filepath.Abs(".")
    fmt.Println("绝对路径:", absPath)

    // 获取文件扩展名
    ext := filepath.Ext("document.pdf")
    fmt.Println("扩展名:", ext) // .pdf

    // 获取基名和目录名
    base := filepath.Base("/home/user/file.txt")
    dir := filepath.Dir("/home/user/file.txt")
    fmt.Printf("文件: %s, 所在目录: %s\n", base, dir) // 文件: file.txt, 所在目录: /home/user
}
```

## 四、实际应用场景示例

### 场景 1：读取配置文件（如 JSON）

```go
import "encoding/json"

type Config struct {
    Port     int    `json:"port"`
    Database string `json:"database"`
}

func loadConfig(filename string) Config {
    data, err := os.ReadFile(filename)
    if err != nil {
        panic(err)
    }

    var config Config
    if err := json.Unmarshal(data, &config); err != nil {
        panic(err)
    }
    return config
}
```

### 场景 2：简单的日志记录器

```go
type Logger struct {
    file *os.File
}

func NewLogger(filename string) (*Logger, error) {
    file, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        return nil, err
    }
    return &Logger{file: file}, nil
}

func (l *Logger) Log(message string) {
    timestamp := time.Now().Format("2006-01-02 15:04:05")
    logEntry := fmt.Sprintf("[%s] %s\n", timestamp, message)
    l.file.WriteString(logEntry)
}

func (l *Logger) Close() {
    l.file.Close()
}

// 使用
logger, _ := NewLogger("app.log")
defer logger.Close()
logger.Log("应用启动")
```

### 场景 3：文件复制

```go
func copyFile(src, dst string) error {
    source, err := os.Open(src)
    if err != nil {
        return err
    }
    defer source.Close()

    destination, err := os.Create(dst)
    if err != nil {
        return err
    }
    defer destination.Close()

    // 使用io.Copy进行高效复制
    _, err = io.Copy(destination, source)
    return err
}
```

## 五、最佳实践与常见陷阱

### 最佳实践

1. **总是检查错误**：Go 的文件操作几乎都会返回错误，必须检查。
2. **使用 defer 关闭文件**：防止资源泄露。
3. **使用`filepath`处理路径**：保证跨平台兼容性。
4. **大文件使用流式处理**：避免一次性加载大文件到内存。
5. **写入时考虑文件锁**：多进程/协程写入同一文件时可能需要同步。

### 常见陷阱

```go
// 陷阱1：忘记检查错误
file, _ := os.Open("file.txt") // 错误被忽略了！
// 正确做法：
file, err := os.Open("file.txt")
if err != nil { /* 处理错误 */ }

// 陷阱2：在循环中频繁打开关闭文件
// 正确做法：打开一次，多次使用

// 陷阱3：使用字符串拼接路径
path := "dir" + "/" + "file.txt" // 在Windows上可能有问题
// 正确做法：
path := filepath.Join("dir", "file.txt")
```

## 六、总结速查表

| 操作               | 推荐方法                             | 适用场景                  |
| ------------------ | ------------------------------------ | ------------------------- |
| **读取整个文件**   | `os.ReadFile()`                      | 配置文件、小文件（<10MB） |
| **按行读取**       | `bufio.NewScanner()`                 | 日志文件、文本处理        |
| **缓冲读取大文件** | `file.Read(buffer)`                  | 大文件、网络传输          |
| **写入整个文件**   | `os.WriteFile()`                     | 保存配置、生成报告        |
| **追加写入**       | `os.OpenFile(..., os.O_APPEND, ...)` | 日志记录                  |
| **缓冲写入**       | `bufio.NewWriter()`                  | 多次写入、性能敏感        |
| **检查存在性**     | `os.Stat()` + `os.IsNotExist()`      | 条件逻辑                  |
| **目录遍历**       | `os.ReadDir()` 或 `filepath.Walk()`  | 批量处理文件              |
| **路径操作**       | `filepath.Join()`, `Dir()`, `Base()` | 所有路径处理              |

---

---
url: /language/JavaScript/index.md
---
# JavaScript学习笔记
## 前言

这里是 2025 年三月的正在为实习笔试、面试焦头烂额的 L0v3ch4n。为了~~完成学校的实习课程~~，也为了为将来的职业规划做点参考，L0v3ch4n 正在投递简历寻找实习。

鉴于之前写的前端项目比较多，他选择了应聘前端开发实习岗位。此笔记首先便是 L0v3ch4n~~临阵磨枪~~
认真学习、巩固知识的记录。其次也是对之前所学的总结（可能也有对未来的展望？）

![node\_modules黑洞](https://www.isoftit.com/static/e5fafbd1079cf6694ea87a4df9eeb5df/4017f/node-modules-meme.jpg)

---

---
url: /language/JavaScript/basic/index.md
---
# 基础语法
## JavaScript 基础语法

### 变量&常量、数据类型

命名规范：小驼峰命名法。

声明：使用`var`, `let`, `const`（常量）修饰符（`let`, `const`为 ES6 语法）。

数据类型：`number`, `string`, `boolean`, `null`, `undefined`

:::tabs

@tab 变量、常量的声明

```javascript
let variableNameByVar = 10
let variableNameByLet = 10
let constName = 10
```

@tab 数据类型

```javascript
let myNum = 10
let myStr = 'this is a string'
let myBool = true // true, false
let myNull = null
let myUndefined
```

:::

### 运算符

1. 四则运算（`+-*/`）
2. 字符串拼接（`+`）
3. 比较运算符

> \[!note]
>
> 1. 字符串拼接在 ES6 中引入了模板语法，能够很方便地进行字符串格式化。
>
> ```javascript
> const name = 'L0v3ch4n'
> const age = 18
> console.log(`My name is ${name}, I am ${age} years old.`)
> // My name is L0v3ch4n, I am 18 years old.
> ```
>
> 2. 判断两个对象是否相等应该使用`===`，不同类型之间做`==`会把两个对象都转化成字符串再进行比较。
>
> ```javascript
> console.log(1 == '1') // true
> console.log(1 === '1') // false
> ```

### 控制语句

:::tabs

@tab if-else if-else 分支语句

```javascript
if (condition1) {
  // statement1
}
else if (condition1) {
  // statement2
}
else {
  // statement
}
```

@tab for 循环

```javascript
for (variable_statement; condition; end_op) {
  // statement
}
```

@tab while 循环

```javascript
while (condition) {
  // statement
}
```

:::

### 函数

:::tabs

@tab function

```javascript
function fn(arguements) {
  // statement
}
```

@tab 箭头函数（ES6）

```javascript
function fn(arguements) {
  // statement
}
```

:::

## 数据结构

### 数组(Array)

```javascript
let arr = [1, 2, 3, 4]
console.log(arr.length) // 数组长度
console.log(arr[1]) // 索引取值
arr.push(5) // 添加元素（在后面）
arr.unshift(0) // 添加元素（在前面）

// 遍历数组
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i])
}
for (const item in arr) {
  console.log(item)
}
for (const item of arr) {
  console.log(item)
}
arr.forEach((item) => {
  console.log(item)
})
arr.map((item) => {
  console.log(item)
})

// 筛选
arr.filter((item) => {
  if (item % 2 === 1)
    return item
})

// reduce
arr.reduce((num1, num2) => {
  return num1 + num2
}) // 数组求和
```

> \[!note] > **判断数组为空的方法**
>
> 1. `length`属性不为 0
> 2. `Array.isArray()`结合`length`
> 3. `for...of / for...in`循环遍历
> 4. `Object.keys()`（ES6）
>    :::tabs
>    @tab length
>
> ```javascript
> // length
> const arr = []
> if (arr.length === 0) {
>   console.log('数组为空')
> }
> else {
>   console.log('数组不为空')
> }
> ```
>
> @tab Array.isArray()\&length
>
> ```javascript
> // Array.isArray()结合length
> if (Array.isArray(arr) && arr.length === 0) {
>   console.log('数组为空')
> }
> else {
>   console.log('数组不为空')
> }
> ```
>
> @tab for...of / for...in 循环遍历
>
> ```javascript
> // for...of / for...in循环遍历
> let isEmpty = false
> for (const _ of arr) {
>   isEmpty = true
>   break
> }
> if (isEmpty) {
>   console.log('数组为空')
> }
> else {
>   console.log('数组不为空')
> }
> ```
>
> @tab Object.keys()
>
> ```javascript
> // Object.keys()
> if (Object.keys(arr).length === 0) {
>   console.log('数组为空')
> }
> else {
>   console.log('数组不为空')
> }
> ```
>
> :::

### 对象

```javascript
let obj = {
  name: 'L0v3ch4n',
  age: 18,
}

for (let k in obj) {
  // k: 字符串类型，obj中的键
  console.log(k, obj[k])
}
```

> \[!note] > **判断对象为空的方法**
>
> 1. 空对象对应的字符串为 `"{}"`
> 2. `for...in`遍历
> 3. `Object.getOwnPropertyNames()`
> 4. `Object.keys()`（ES6）
>    :::tabs
>    @tab 字符串化
>
> ```javascript
> // JSON.stringify()
> const obj = {}
> if (JSON.stringify(obj) == '{}') {
>   console.log('对象为空')
> }
> else {
>   console.log('对象不为空')
> }
> ```
>
> @tab for...in 遍历
>
> ```javascript
> // for...in遍历
> let isEmpty = false
> for (const _ in obj) {
>   isEmpty = true
>   break
> }
> if (isEmpty) {
>   console.log('对象为空')
> }
> else {
>   console.log('对象不为空')
> }
> ```
>
> @tab Object.getOwnPropertyNames()
>
> ```javascript
> // Object.getOwnPropertyNames()
> if (Object.getOwnPropertyNames().length === 0) {
>   console.log('对象为空')
> }
> else {
>   console.log('对象不为空')
> }
> ```
>
> @tab Object.keys()
>
> ```javascript
> // Object.keys()
> if (Object.keys(arr).length === 0) {
>   console.log('对象为空')
> }
> else {
>   console.log('对象不为空')
> }
> ```
>
> :::

---

---
url: /language/JavaScript/ES6/index.md
---
# ES6相关
## 变量和常量

```javascript
let variableByVar = 10
let variableByLet = 10
const constant = 10
```

`let`、`var`的区别

1. 全局污染。`let`定义的变量不会污染全局，`var`定义的会。（`let`定义的变量仍然可以跨越标签使用）
2. 作用域。`let`声明的变量作用域：块级作用域、全局作用域、函数作用域；`var`：全局作用域、函数作用域。
3. 暂时性死区。`var`声明的变量能变量提升（声明前可以调用，返回`undefined`），`let`声明的变量也有提升，但是会形成暂时性死区，无法访问未声明的变量。
4. 重复声明。`var`声明的变量可以重复声明，`let`声明的不可重复声明。

## 新基本数据类型

新增两个基本数据类型`Symbol`、`Bigint`。

> `Symbol`的本质是表示一个唯一标识。每次创建一个`Symbol`，它所代表的值都不可能重复。所以理论上`Symbol`
> 的存在只有一个意义：用于必须使用唯一值的场景。

> `BigInt`数据类型的目的是比`Number`数据类型支持的范围更大的整数值以任意精度表示整数的能力尤为重要。使用`BigInt`
> ，整数溢出将不再是问题。

## 模板字符串

使用反引号\`\`\`包围，变量替换使用`${}`。模板支持换行。

```javascript
const name = 'L0v3ch4n'
const age = 18
console.log(`My name is ${name}, I am ${age} years old.`)
// My name is L0v3ch4n, I am 18 years old.
```

## 解构赋值

```javascript
const [a, b, c] = [1, 2, 3]

const {
  userName,
  age: userAge,
  ...otherInfo
} = {
  name: 'L0v3ch4n',
  age: 18,
  gender: 'male',
  other: 'chors',
}
```

## 扩展操作符

展开的元素是无序的。

```javascript
const arr1 = [1, 2, 3]
const arr2 = [4, 5, 6]
const arr3 = [...arr1, ...arr2]

const obj1 = {
  key1: 'value1',
}
const obj2 = {
  key2: 'value2',
}
const obj3 = {
  kay3: 'value3',
  ...obj1,
  ...obj2,
}
```

## 类

:::tabs
@tab 声明&实例化

```javascript
class A {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
}

const a = new A('L0v3ch4n', 18)
```

@tab 继承

```javascript
class A {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
}

class B extends A {
  constructor(name, age, gender) {
    super.constructor(name, age)
    this.gender = gender
  }
}
```

:::

## 箭头函数

```javascript
const fn1 = n => n + 3
const fn2 = (n1, n2) => n1 + n2
const fn3 = (n1, n2, ...other) => console.log(other)
function fn4(n1, n2, ...other) {
  console.log(other)
  return n1 + n2
}
```

## 异步

### Promise

Promise 会放置在微任务消息队列中，优先级最高；
ES6 中加入了`async`、`await`关键字支持异步（将异步代码以同步形式写出）。
:::tabs
@tab Promise

```javascript
const p1 = new Promise((resolve, reject) => {
  if (success)
    resolve()
  else reject()
})
p1.then((res) => {}).catch((err) => {})
```

@tab async

```javascript
function fn1() {
  return 1
}

async function fn2() {
  let res = await fn1()
  console.log(res)
}
```

:::

### Proxy

代理对象，响应式的基础。用于监控对对象属性的操作。

```javascript
const obj = {
  name: 'L0v3ch4n',
  age: 18,
}
new Proxy(obj, {
  get(target, property, receiver) {
    console.log('Getter')
    return obj[property]
  },
  set(target, property, value, receiver) {
    console.log('Setter')
    obj[property] = value
    container.textContent = obj.name // 界面数据更新逻辑
  },
})
```

## Module

### ESM

:::tabs
@tab a.js (export)

```javascript
export const aTitle = 'a title'

export function aFun() {
  console.log('a')
}

export default {
  name: 'a Module',
}
```

@tab b.js (import)

```javascript
import { aFun, aTitle, name } from './a.js'
```

:::

### Common JS

:::tabs
@tab a.js (export)

```javascript
module.exports = {
  a: 1,
  b: 2,
  c: 3,
}
exports.d = 4
```

@tab b.js (import)

```javascript
const moduleA = require('./a')
```

:::

---

---
url: /language/Python/index.md
---
# Python教程
## 前言

应群友的学习要求，编写此教程（不定时咕咕咕），顺便也为零零散散的 Python 知识点进行归纳总结。

---

---
url: /language/quick-start/index.md
---
# 环境搭建

如果你想运行 Python 代码，你需要安装 Python 解释器。Python 解释器是执行 Python 代码的程序，没有它，Python 代码将无法运行。

## 安装 Python 解释器

::: tabs
@tab  Windows

你可以从[Python 官网](https://www.python.org/)下载 Python 解释器。下载完成后，按照提示进行安装即可。

> \[!important]
> 在安装过程中，请确保选中`Add Python 3.x to PATH`选项，这样你就可以在命令行中直接运行 Python 解释器了。

@tab  Linux

在 Linux 系统中，你可以使用包管理器来安装 Python 解释器。例如，在 Ubuntu 系统中，你可以使用以下命令来安装 Python 解释器：

```bash
sudo apt-get update
sudo apt-get install python3
```

@tab  MacOS

在 macOS 系统中，你可以使用`Homebrew`来安装 Python 解释器。首先，你需要[安装 Homebrew](https://zhuanlan.zhihu.com/p/372576355)，
然后使用以下命令来安装 Python 解释器：

```bash
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
brew install python
```

:::

> \[!tip]
> 如果你已经安装了 Python 解释器，但是仍然无法在命令行中运行 Python 解释器，那么你可能需要将 Python 解释器的路径添加到系统的环境变量中。

在装好 Python 解释器后，你可以在命令行或终端中输入`python -V`来检查 Python 解释器是否配置成功。如果配置成功，你将看到 Python 解释器的版本信息。

## 安装代码编辑器

工欲善其事，必先利其器。为了编写 Python 代码，你需要一个代码编辑器。以下是一些常用的 Python 代码编辑器：

* [VS Code](https://code.visualstudio.com/)
* [PyCharm](https://www.jetbrains.com/pycharm/)
* 记事本（任何能写文字的编辑器）

推荐使用现代 IDE（集成开发环境），如 VS Code 或 PyCharm，它们提供了语法高亮、代码补全、调试等功能，可以帮助你更高效地编写 Python 代码。

## 快速开始

在安装好 Python 解释器和代码编辑器后，你就可以开始编写 Python 代码了。以下是一个简单的 Python 程序：

```python
print("Hello, World!")
```

将以上代码保存为`hello.py`文件，然后在命令行或终端中输入`python hello.py`，你将看到输出`Hello, World!`。

> 在 Python 中，`print`函数用于输出文本。你可以使用`print`函数来输出任何你想要的内容。

恭喜你，你已经迈出了万里长征的第一步（也是最重要的一步）！现在你可以开始学习 Python 的基础知识了。祝你学习愉快！

---

---
url: /memorandum/index.md
---
# 备忘录

---

---
url: /memorandum/CodeSnippet/index.md
---
# Code Snippet
## JavaScript

### 防抖

```javascript
function debounce(func, duration = 500) {
  let timerId
  return function (...args) {
    if (timerId)
      clearTimeout(timerId)
    timerId = setTimeout(() => {
      func.apply(this, args)
    }, duration)
  }
}
```

---

---
url: /memorandum/docker/index.md
---
## Dockerfile 模板

```Dockerfile
# 基础镜像，必需
FROM <image-name>:<version>
# 设置工作目录，必需
WORKDIR /app
# 配置环境变量
ENV ENVIRONMENT_VARIABLE=VALUE
# 执行命令，用于安装环境依赖包
RUN cmd to install dependencies
# 将项目文件复制到工作目录，必需
COPY . /app
# 重置项目入口
ENTRYPOINT []
# 运行项目的一般命令，必需
CMD ["sh", "-c", "cmd to run app"]
```

## docker-compose 模板

以 mysql 和 nacos 容器组合为样例。
::: tabs
@tab  docker-compose.yml
`docker-compose` 主文件

```Dockerfile
version: "3"
services:
  mysql:
    image: mysql/mysql-server:8.0.32
    container_name: mysql
    restart: always
    volumes:
      - ${DATA_DIRECTORY}/data/mysql/data:/var/lib/mysql
    environment:
      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD:-passwd} # mysql数据库root账号的密码
      - TZ=Asia/Shanghai
      - NACOS_USERNAME=${NACOS_USERNAME:-root} # 后续nacos所用管理员账号
      - NACOS_PASSWORD=${NACOS_PASSWORD:-passwd} # 后续nacos所用管理员密码
    ports:
      - ${MYSQL_PUBLIC_PORT:-3306}:3306
    networks:
      network:
        ipv4_address: ${MYSQL_HOST:-172.20.0.2}
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p${MYSQL_ROOT_PASSWORD:-passwd}"]
      interval: 10s
      timeout: 10s
      retries: 10

  nacos:
    image: nacos/nacos-server:1.4.2
    container_name: nacos
    restart: always
    depends_on:
      mysql:
        condition: service_healthy
    environment:
      - JVM_XMX=384m
      - JVM_XMS=384m
      - JVM_XMN=192m
      - MODE=standalone
      - SPRING_DATASOURCE_PLATFORM=mysql
      - MYSQL_SERVICE_HOST=${MYSQL_HOST:-172.20.0.2}
      - MYSQL_SERVICE_PORT=3306
      - MYSQL_SERVICE_USER=root
      - MYSQL_SERVICE_PASSWORD=${MYSQL_ROOT_PASSWORD:-passwd} # 与上面数据库密码一致
      - MYSQL_SERVICE_DB_NAME=nacos
      - NACOS_AUTH_ENABLE=true # 开启鉴权
    ports:
      - ${NACOS_PORT:-8848}:8848
    healthcheck:
      test: curl -f http://${NACOS_HOST:-172.20.0.3}:8848/nacos/index.html || exit 1
      interval: 10s
      timeout: 10s
      retries: 12
    networks:
      network:
        ipv4_address: ${NACOS_HOST:-172.20.0.3}

  autohealth: # 监控不健康的容器进行重启
    restart: always
    container_name: autohealth
    image: willfarrell/autoheal
    environment:
      - AUTOHEAL_CONTAINER_LABEL=all
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock

networks:
  network:
    driver: bridge
    ipam:
      config:
        - subnet: ${SUBNET:-172.20.0.0/16}
```

@tab  .env
相关环境变量配置

```bash
DATA_DIRECTORY=./hoj

# mysql的docker内网ip
MYSQL_HOST=172.20.0.2
# mysql暴露的端口号
MYSQL_PUBLIC_PORT=3306
# mysql的密码
MYSQL_ROOT_PASSWORD=passwd

# nacos的配置
NACOS_HOST=172.20.0.3
NACOS_PORT=8848
NACOS_USERNAME=root
NACOS_PASSWORD=passwd

# docker network的配置
SUBNET=172.20.0.0/16
```

:::

## 常用 Docker 命令

`docker build -t tag:v1` 编译

> `-t` 设置镜像名字和版本号
>
> 命令参考：<https://docs.docker.com/engine/reference/commandline/build/>

`docker run -p 8080:8080 --name container-name tag:v1` 运行

> `-p` 映射容器内端口到宿主机
>
> `--name` 容器名字
>
> `-d` 后台运行
>
> 命令参考文档：<https://docs.docker.com/engine/reference/run/>

`docker ps` 查看当前运行中的容器

`docker images` 查看镜像列表

`docker rm container-id` 删除指定 id 的容器

`docker stop/start container-id` 停止/启动指定 id 的容器

`docker rmi image-id` 删除指定 id 的镜像

`docker volume ls` 查看 volume 列表

`docker network ls` 查看网络列表

`docker logs container-id` 查看指定 id 的容器运行 log

## 常用 docker-compose 命令

`docker-compose up` 运行服务

`docker-compose up -d` 在后台运行

`docker-compose ps` 查看运行状态

`docker-compose stop` 停止运行

`docker-compose restart` 重启

`docker-compose restart service-name` 重启单个服务

`docker-compose exec service-name sh` 进入容器命令行

`docker-compose logs service-name` 查看容器运行 log

---

---
url: /memorandum/git/index.md
---
## 分支

```shell :no-line-numbers
# 删除本地存在远程不存在的分支
git remote prune origin

# 删除已经合并到 master 的分支
git branch --merged master | grep -v '^\*\|  master' | xargs -n 1 git branch -d

# 查看远程分支和本地分支的对应关系
git remote show origin
```

## 提交

```shell :no-line-numbers
# 重写最后一次提交信息
git commit --amend -m "new message"

# 修改最新的提交而不更改提交消息
git commit --amend --no-edit
```

## 配置

```shell :no-line-numbers
# 获取配置帮助信息
git help config
# 配置全局用户名
git config --global user.name "name"
# 配置全局邮箱
git config --global user.email "email"
# 配置全局颜色，对 git 输出进行美化
git config --global color.ui auto
# 在文本编辑器中编辑全局配置文件
git config --global --edit
# 删除全局配置
git config --global --unset <entry-name>
# 查看本地 repo 配置
git config --list
```

### 解决中文乱码

```shell :no-line-numbers
git config --global core.quotepath false
```

不再将 文件权限变更 作为改动

```shell :no-line-numbers
git config core.fileMode false
```

### 设置大小写敏感

```shell :no-line-numbers
# 大小写敏感
git config --get core.ignorecase
# 远程有俩相同目录，通过这种方式清除掉，然后提交记录
git rm -r --cached <dirOrFile>
```

### 代理

```shell :no-line-numbers
# 查看代理
git config --global http.proxy
git config --global https.proxy
git config --global socks.proxy

# 设置代理
# 适用于 privoxy 将 socks 协议转为 http 协议的 http 端口
git config --global http.proxy http://127.0.0.1:1080
git config --global https.proxy http://127.0.0.1:1080
git config --global socks.proxy 127.0.0.1:1080

# 取消代理
git config --global --unset http.proxy
git config --global --unset https.proxy
git config --global --unset socks.proxy

# 只对 github.com 设置代理
git config --global http.https://github.com.proxy socks5://127.0.0.1:1080
git config --global https.https://github.com.proxy socks5://127.0.0.1:1080

# 取消 github.com 代理
git config --global --unset http.https://github.com.proxy
git config --global --unset https.https://github.com.proxy
```

## 统计查询

```shell :no-line-numbers
# 提交数统计
git log --oneline | wc -l
# 查看文件内容的提交者
git blame <file-name>
# 仓库总大小
git count-objects -vH
# 仓库大小
git ls-files | xargs -r du -hs
# 在 commit log 中查找内容
git log --all --grep='<given-text>'
```

### 查看 个人代码量

```shell :no-line-numbers
# username 需要修改为 个人用户名
git log --author="username" --pretty=tformat: --numstat | awk \
'{ add += $1; subs += $2; loc += $1 - $2 } END { printf "added lines: %s, removed lines: %s, total lines: %s\n", add, subs, loc }' -
```

### 每人增删行数

```shell :no-line-numbers
git log --format='%aN' | sort -u |\
  while read name; do echo -en "$name\t";\
  git log --author="$name" --pretty=tformat: --numstat | awk \
  '{ add += $1; subs += $2; loc += $1 - $2 } END { printf "added lines: %s, removed lines: %s, total lines: %s\n", add, subs, loc }' -; done
```

### 查看提交者排名

```shell :no-line-numbers
# 取前十个的排名
git log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 10
```

## submodule 子模块

```shell :no-line-numbers
# 添加包含子模块的仓库
git clone <repo_url> --recursive
# 查看当前仓库中的子模块
git submodule status

# 添加子模块
git submodule add <repo_url> <submodule_path>

# 初始化子模块
git submodule init

# 更新子模块
git submodule update --remote

# 删除子模块
git submodule deinit <path_to_submodule>
git rm <path_to_submodule>
```

切换到子模块的特定提交

```shell :no-line-numbers
cd <path_to_submodule>
git checkout <commit_hash>
```

切换到父仓库的特定提交，并更新子模块

```shell :no-line-numbers
git submodule update --remote
git checkout <commit_hash>
```

获取并切换子模块的最新标签

```shell :no-line-numbers
cd <path_to_submodule>
git fetch --tags
git checkout $(git describe --tags $(git rev-list --tags --max-count=1))
```

子模块递归

```shell :no-line-numbers
# 添加所有已存在的子模块
git submodule foreach --recursive git submodule add <repo_url>

# 更新所有子模块到最新提交
git submodule foreach --recursive git pull origin master

# 检出特定的子模块路径
git submodule foreach --recursive git checkout <branch_name>

# 获取仓库中的所有子模块变化
git submodule foreach --recursive git fetch

# 获取并合并子模块的远程分支
git submodule foreach --recursive git pull origin <branch_name>

# 将子模块还原到父仓库中的初始提交
git submodule foreach --recursive git checkout .

# 获取子模块的更新并忽略本地修改
git submodule foreach --recursive git fetch --all
git submodule foreach --recursive git reset --hard origin/master
```

---

---
url: /memorandum/grep/index.md
---
# grep
## 参数

|                 |                                         | 说明                                                                                                   |
| --------------- | --------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| `-a`            | `--text`                                | 不要忽略二进制数据。                                                                                   |
| `-A <显示行数>` | `--after-context=<显示行数>`            | 除了显示符合范本样式的那一行之外，并显示该行之后的内容。                                               |
| `-b`            | `--byte-offset`                         | 在显示符合范本样式的那一行之外，并显示该行之前的内容。                                                 |
| `-B <显示行数>` | `--before-context=<显示行数>`           | 除了显示符合样式的那一行之外，并显示该行之前的内容。                                                   |
| `-c`            | `--count`                               | 计算符合范本样式的列数。                                                                               |
| `-C <显示行数>` | `--context=<显示行数>` 或 `-<显示行数>` | 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。                                             |
| `-d<进行动作>`  | `--directories=<动作>`                  | 当指定要查找的是目录而非文件时，必须使用这项参数，否则 grep 命令将回报信息并停止动作。                 |
| `-e <范本样式>` | `--regexp=<范本样式>`                   | 指定字符串作为查找文件内容的范本样式。                                                                 |
| `-E`            | `--extended-regexp`                     | 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。                                   |
| `-f <范本文件>` | `--file=<规则文件>`                     | 指定范本文件，其内容有一个或多个范本样式，让 grep 查找符合范本条件的文件内容，格式为每一列的范本样式。 |
| `-F`            | `--fixed-regexp`                        | 将范本样式视为固定字符串的列表。                                                                       |
| `-G`            | `--basic-regexp`                        | 将范本样式视为普通的表示法来使用。                                                                     |
| `-h`            | `--no-filename`                         | 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。                                             |
| `-H`            | `--with-filename`                       | 在显示符合范本样式的那一列之前，标示该列的文件名称。                                                   |
| `-i`            | `--ignore-case`                         | 忽略字符大小写的差别。                                                                                 |
| `-l`            | `--file-with-matches`                   | 列出文件内容符合指定的范本样式的文件名称。                                                             |
| `-L`            | `--files-without-match`                 | 列出文件内容不符合指定的范本样式的文件名称。                                                           |
| `-n`            | `--line-number`                         | 在显示符合范本样式的那一列之前，标示出该列的编号。                                                     |
| `-P`            | `--perl-regexp`                         | PATTERN 是一个 Perl 正则表达式                                                                         |
| `-q`            | `--quiet或--silent`                     | 不显示任何信息。                                                                                       |
| `-R`/`-r`       | `--recursive`                           | 此参数的效果和指定“-d recurse”参数相同。                                                               |
| `-s`            | `--no-messages`                         | 不显示错误信息。                                                                                       |
| `-v`            | `--revert-match`                        | 反转查找。                                                                                             |
| `-V`            | `--version`                             | 显示版本信息。                                                                                         |
| `-w`            | `--word-regexp`                         | 只显示全字符合的列。                                                                                   |
| `-x`            | `--line-regexp`                         | 只显示全列符合的列。                                                                                   |
| `-y`            |                                         | 此参数效果跟“-i”相同。                                                                                 |
| `-o`            |                                         | 只输出文件中匹配到的部分。                                                                             |
| `-m <num>`      | `--max-count=<num>`                     | 找到 num 行结果后停止查找，用来限制匹配行数                                                            |

## 规则表达式

```shell :no-line-numbers
^      # 锚定行的开始 如：'^grep'匹配所有以grep开头的行。
$      # 锚定行的结束 如：'grep$' 匹配所有以grep结尾的行。
.      # 匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。
*      # 匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。
.*     # 一起用代表任意字符。
[]     # 匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。
[^]    # 匹配一个不在指定范围内的字符，如：'[^A-Z]rep' 匹配不包含 A-Z 中的字母开头，紧跟 rep 的行
(..)   # 标记匹配字符，如'(love)'，love被标记为1。
<      # 锚定单词的开始，如:'<grep'匹配包含以grep开头的单词的行。
>      # 锚定单词的结束，如'grep>'匹配包含以grep结尾的单词的行。
x{m}   # 重复字符x，m次，如：'0{5}'匹配包含5个o的行。
x{m,}  # 重复字符x,至少m次，如：'o{5,}'匹配至少有5个o的行。
x{m,n} # 重复字符x，至少m次，不多于n次，如：'o{5,10}'匹配5--10个o的行。
\w     # 匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。
\W     # \w的反置形式，匹配一个或多个非单词字符，如点号句号等。
\b     # 单词锁定符，如: '\bgrep\b'只匹配grep。
```

---

---
url: /memorandum/nginx/index.md
---
## 服务管理

```shell :no-line-numbers
sudo systemctl status nginx  # nginx当前状态
sudo systemctl reload nginx  # 重新加载 nginx
sudo systemctl restart nginx # 重启nginx

sudo nginx -t   # 检查语法
nginx           # 启动
nginx -s reload # 重启
nginx -s stop   # 关闭进程
nginx -s quit   # 平滑关闭nginx
nginx -V        # 查看nginx的安装状态
```

## 全局变量

| 变量                | 说明                                                             |
| ------------------- | ---------------------------------------------------------------- |
| `$args`             | 这个变量等于请求行中的参数，同 `$query_string`                   |
| `$remote_port`      | 客户端的端口                                                     |
| `$content_length`   | 请求头中的 `Content-length` 字段                                 |
| `$remote_user`      | 已经经过 `Auth Basic Module` 验证的用户名                        |
| `$content_type`     | 请求头中的 `Content-Type` 字段                                   |
| `$request_filename` | 当前请求的文件路径，由 `root` 或 alias 指令与 URI 请求生成       |
| `$document_root`    | 当前请求在 `root` 指令中指定的值                                 |
| `$scheme`           | HTTP 方法（如 http，https）                                      |
| `$host`             | 请求主机头字段，否则为服务器名称                                 |
| `$hostname`         | 主机名                                                           |
| `$http_user_agent`  | 客户端`agent`信息                                                |
| `$http_cookie`      | 客户端`cookie`信息                                               |
| `$server_protocol`  | 请求使用的协议，通常是`HTTP/1.0`或`HTTP/1.1`                     |
| `$server_addr`      | 服务器地址，在完成一次系统调用后可以确定这个值                   |
| `$server_name`      | 服务器名称                                                       |
| `$server_port`      | 请求到达服务器的端口号                                           |
| `$limit_rate`       | 这个变量可以限制连接速率                                         |
| `$request_method`   | 客户端请求的动作，如 GET/POST                                    |
| `$request_uri`      | 包含请求参数的原始 URI，不包含主机名，如：`/foo/bar.php?arg=baz` |
| `$remote_addr`      | 客户端的 IP 地址                                                 |
| `$uri`              | 不带请求参数的当前 URI，`$uri`不包含主机名，如 `/foo/bar.html`   |
| `$document_uri`     | 与 `$uri` 相同                                                   |
| `$nginx_version`    | `nginx` 版本                                                     |

## 监听端口

```nginx :no-line-numbers
server {
  listen 80;      # 标准 HTTP 协议
  listen 443 ssl; # 标准 HTTPS 协议
  listen 443 ssl http2; # 对于 http2
  listen [::]:80; # 使用 IPv6 在 80 上收听
  # 仅收听使用 IPv6
  listen [::]:80 ipv6only=on;
}
```

## 域名 (server\_name)

```nginx :no-line-numbers
server {
  # 监听 example.com
  server_name example.com;
  # 监听多个域
  server_name example.com www.example.com;
  # 监听所有子域
  server_name *.example.com;
  # 监听所有顶级域
  server_name example.*;
  # 监听未指定的主机名（监听 IP 地址本身）
  server_name "";
}
```

## 负载均衡

### 简单实例

```nginx :no-line-numbers
upstream node_js {
  server 0.0.0.0:3000;
  server 0.0.0.0:4000;
  server 127.155.142.421;
}
```

### 权重

```nginx :no-line-numbers
upstream test {
  server localhost:8080 weight=9;
  server localhost:8081 weight=1;
}
```

### ip\_hash

解决负载均衡 `session` 的问题

```nginx:no-line-numbers {2}
upstream test {
  ip_hash;
  server localhost:8080;
  server localhost:8081;
}
```

### fair

响应时间短的优先分配

```nginx:no-line-numbers {2}
upstream backend {
  fair;
  server localhost:8080;
  server localhost:8081;
}
```

### url\_hash

按访问 url 的 hash 结果来分配请求

```nginx:no-line-numbers {2,3}
upstream backend {
  hash $request_uri;
  hash_method crc32;
  server localhost:8080;
  server localhost:8081;
}
```

### keepalive

激活缓存以连接到上游服务器

```nginx:no-line-numbers {4}
upstream memcached_backend {
    server 127.0.0.1:11211;
    server 10.0.0.2:11211;
    keepalive 32;
}
```

### server 可选参数

| 参数名         | 说明                             |
| -------------- | -------------------------------- |
| `weight`       | 访问权重数值越高，收到请求越多   |
| `fail_timeout` | 指定的时间内必须提供响应         |
| `max_fails`    | 尝试失败服务器连接的最大次数     |
| `down`         | 标记一个服务器不再接受任何请求   |
| `backup`       | 有服务器宕机，标记的机器接收请求 |

## 反向代理

```nginx :no-line-numbers
server {
  listen 80;
  server_name example.com;

  location / {
    proxy_pass http://0.0.0.0:3000;
    # 其中 0.0.0.0:3000 是绑定在
    # 0.0.0.0端口3000 列表上的 Node.js 服务器
  }
}
```

负载均衡 + 反向代理

```nginx :no-line-numbers
upstream node_js {
  server 0.0.0.0:3000;
  # 其中 0.0.0.0:3000 是绑定在
  # 0.0.0.0端口3000 列表上的 Node.js 服务器
}

server {
  listen 80;
  server_name example.com;

  location / {
    proxy_pass http://node_js;
  }
}
```

升级连接（适用于支持 WebSockets 的应用程序）

```nginx :no-line-numbers
upstream node_js {
  server 0.0.0.0:3000;
}

server {
  listen 80;
  server_name example.com;

  location / {
    proxy_pass http://node_js;
    proxy_redirect off;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;

  }
}
```

## 跨域

```nginx :no-line-numbers
server {
  listen 80;
  server_name api.xxx.com;

  add_header 'Access-Control-Allow-Origin' '*';
  add_header 'Access-Control-Allow-Credentials' 'true';
  add_header 'Access-Control-Allow-Methods' 'GET,POST,HEAD';

  location / {
    proxy_pass http://127.0.0.1:3000;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host  $http_host;
  }
}
```

重定向 URI

```nginx :no-line-numbers
upstream test {
  server 127.0.0.1:8080;
  server localhost:8081;
}
server {
  listen 80;
  server_name api.xxx.com;
  location / {
    root  html;                   # 去请求../html文件夹里的文件
    index  index.html index.htm;  # 首页响应地址
  }
  # 用于拦截请求，匹配任何以 /api/开头的地址，
  # 匹配符合以后，停止往下搜索正则。
  location ^~/api/{
    # 代表重写拦截进来的请求，并且只能对域名后边的除去传递的参数外的字符串起作用
    # 例如www.a.com/api/msg?meth=1&par=2重写，只对/api/msg重写。
    # rewrite后面的参数是一个简单的正则 ^/api/(.*)$，
    # $1代表正则中的第一个()，$2代表第二个()的值，以此类推。
    rewrite ^/api/(.*)$ /$1 break;

    # 把请求代理到其他主机
    # 其中 http://www.b.com/ 写法和 http://www.b.com写法的区别如下
    # 如果你的请求地址是他 http://server/html/test.jsp
    # 配置一： http://www.b.com/ 后面有“/”
    #         将反向代理成 http://www.b.com/html/test.jsp 访问
    # 配置一： http://www.b.com 后面没有有“/”
    #         将反向代理成 http://www.b.com/test.jsp 访问
    proxy_pass http://test;

    # 如果 proxy_pass  URL 是 http://a.xx.com/platform/ 这种情况
    # proxy_cookie_path应该设置成 /platform/ / (注意两个斜杠之间有空格)。
    proxy_cookie_path /platfrom/ /;

    # 设置 Cookie 头通过
    proxy_pass_header Set-Cookie;
  }
}
```

## 屏蔽 IP

```nginx :no-line-numbers
可以放到 http, server, location, limit_except 语句块

include blockip.conf;
在 blockip.conf 里面输入内容，如：

deny 165.91.122.67;

deny IP;            # 屏蔽单个 ip 访问
allow IP;           # 允许单个 ip 访问
deny all;           # 屏蔽所有 ip 访问
allow all;          # 允许所有 ip 访问
deny 123.0.0.0/8;   # 屏蔽整个段即从 123.0.0.1 到 123.255.255.254 访问的命令
deny 124.45.0.0/16; # 屏蔽IP段即从 123.45.0.1 到 123.45.255.254 访问的命令
deny 123.45.6.0/24; # 屏蔽IP段即从 123.45.6.1 到 123.45.6.254 访问的命令

# 如果你想实现这样的应用，除了几个IP外，其他全部拒绝
allow 1.1.1.1;
allow 1.1.1.2;
deny all;
```

## 代理转发重写路径

```nginx :no-line-numbers
location ^~/api/upload {
  rewrite ^/(.*)$ /wfs/v1/upload break;
  proxy_pass http://wfs-api;
}
```

## 图片防盗链

```nginx :no-line-numbers
location ~* \.(gif|jpg|png|swf|flv)$ {
  root html;

  valid_referers none blocked *.nginx.com;

  if ($invalid_referer) {
    rewrite ^/ www.nginx.cn;
    # return 404;
  }
}
```

## 屏蔽文件目录

```nginx :no-line-numbers
通用备份和归档文件

location ~* "\.(old|orig|original|php#|php~|php_bak|save|swo|aspx?|tpl|sh|bash|bak?|cfg|cgi|dll|exe|git|hg|ini|jsp|log|mdb|out|sql|svn|swp|tar|rdf)$" {
    deny all;
}
拒绝访问 .git 和 .svn 目录

location ~ (.git|.svn) {
    deny all;
}
拒绝访问隐藏文件和目录

location ~ /\.(?!well-known\/) {
    deny all;
}
```

## Gzip 配置

```nginx :no-line-numbers
gzip  on;
gzip_buffers 16 8k;
gzip_comp_level 6;
gzip_http_version 1.1;
gzip_min_length 256;
gzip_proxied any;
gzip_vary on;
gzip_types
    text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml
    text/javascript application/javascript application/x-javascript
    text/x-json application/json application/x-web-app-manifest+json
    text/css text/plain text/x-component
    font/opentype application/x-font-ttf application/vnd.ms-fontobject
    image/x-icon;
gzip_disable  "msie6";
```

---

---
url: /memorandum/postgreSQL/index.md
---
# PostgreSQL 常用命令和语法

## 一、基础连接和系统命令

### 1. **连接命令**

```bash
# 基本连接
psql -U 用户名 -d 数据库名 -h 主机 -p 端口
psql postgres                         # 连接默认数据库

# 退出
\q
```

### 2. **信息查看命令**

```sql
\l 或 \list                          -- 列出所有数据库
\c 数据库名                          -- 切换数据库
\d                                 -- 列出当前数据库的表
\d 表名                             -- 查看表结构
\d+ 表名                            -- 查看详细信息（包括索引、外键等）
\dt                                -- 只列出表
\dv                                -- 列出视图
\df                                -- 列出函数
\du 或 \dg                         -- 列出用户/角色
\dn                                -- 列出模式
\dp 或 \z                          -- 查看表权限
\dy                                -- 列出事件触发器
\conninfo                          -- 显示当前连接信息
\?                                 -- 查看psql命令帮助
\h                                 -- 查看SQL命令帮助
\timing                            -- 切换执行时间显示（开/关）
\x auto                            -- 切换扩展显示模式（宽表自动换行）
```

## 二、数据库操作

### 1. **创建和管理数据库**

```sql
-- 创建数据库
CREATE DATABASE 数据库名;

-- 创建带参数的数据库
CREATE DATABASE mydb
  WITH
  OWNER = 用户名
  ENCODING = 'UTF8'
  LC_COLLATE = 'en_US.UTF-8'
  LC_CTYPE = 'en_US.UTF-8'
  TABLESPACE = pg_default
  CONNECTION LIMIT = -1;

-- 重命名数据库
ALTER DATABASE 旧名 RENAME TO 新名;

-- 删除数据库
DROP DATABASE IF EXISTS 数据库名;

-- 复制数据库
CREATE DATABASE 新数据库 TEMPLATE 原数据库;
```

### 2. **备份和恢复**

```bash
# 备份单个数据库
pg_dump -U 用户名 数据库名 > 备份文件.sql

# 备份整个集群
pg_dumpall > 全部备份.sql

# 恢复数据库
psql -U 用户名 -d 数据库名 < 备份文件.sql

# 压缩备份
pg_dump 数据库名 | gzip > 备份文件.sql.gz
```

## 三、表操作

### 1. **创建表**

```sql
-- 基本创建
CREATE TABLE 表名 (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    age INTEGER DEFAULT 0,
    email VARCHAR(255) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);

-- 带约束的表
CREATE TABLE employees (
    emp_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    salary NUMERIC(10,2) CHECK (salary > 0),
    dept_id INTEGER REFERENCES departments(id),
    hire_date DATE DEFAULT CURRENT_DATE,
    CONSTRAINT uk_email UNIQUE (email)
);

-- 从现有表创建新表
CREATE TABLE 新表名 AS SELECT * FROM 原表名;
CREATE TABLE 新表名 (LIKE 原表名 INCLUDING ALL);
```

### 2. **修改表结构**

```sql
-- 添加列
ALTER TABLE 表名 ADD COLUMN 列名 数据类型 约束;

-- 删除列
ALTER TABLE 表名 DROP COLUMN 列名;

-- 修改列类型
ALTER TABLE 表名 ALTER COLUMN 列名 TYPE 新类型;

-- 重命名列
ALTER TABLE 表名 RENAME COLUMN 旧列名 TO 新列名;

-- 添加约束
ALTER TABLE 表名 ADD CONSTRAINT 约束名 PRIMARY KEY (列);
ALTER TABLE 表名 ADD CONSTRAINT 约束名 FOREIGN KEY (列) REFERENCES 其他表(列);
ALTER TABLE 表名 ADD CONSTRAINT 约束名 UNIQUE (列);
ALTER TABLE 表名 ADD CONSTRAINT 约束名 CHECK (条件);

-- 删除约束
ALTER TABLE 表名 DROP CONSTRAINT 约束名;

-- 重命名表
ALTER TABLE 旧表名 RENAME TO 新表名;
```

## 四、数据操作（CRUD）

### 1. **插入数据**

```sql
-- 插入单行
INSERT INTO 表名 (列1, 列2) VALUES (值1, 值2);

-- 插入多行
INSERT INTO 表名 (列1, 列2)
VALUES
    (值1, 值2),
    (值3, 值4),
    (值5, 值6);

-- 从查询结果插入
INSERT INTO 表名1 (列1, 列2)
SELECT 列1, 列2 FROM 表名2 WHERE 条件;

-- 插入并返回结果
INSERT INTO 表名 (列1) VALUES (值1) RETURNING id;
```

### 2. **查询数据**

```sql
-- 基础查询
SELECT * FROM 表名;
SELECT 列1, 列2 FROM 表名;
SELECT DISTINCT 列 FROM 表名;

-- 带条件
SELECT * FROM 表名 WHERE 条件;
SELECT * FROM users WHERE age > 18 AND status = 'active';
SELECT * FROM products WHERE price BETWEEN 10 AND 100;
SELECT * FROM users WHERE name LIKE '张%';

-- 排序
SELECT * FROM 表名 ORDER BY 列1 ASC, 列2 DESC;

-- 限制和偏移
SELECT * FROM 表名 LIMIT 10;
SELECT * FROM 表名 LIMIT 10 OFFSET 20;  -- 跳过前20条，取10条

-- 聚合函数
SELECT
    COUNT(*) as 总数,
    AVG(price) as 平均价格,
    SUM(amount) as 总金额,
    MAX(date) as 最近日期,
    MIN(date) as 最早日期
FROM 表名;

-- 分组和筛选
SELECT
    department,
    COUNT(*) as 员工数,
    AVG(salary) as 平均工资
FROM employees
GROUP BY department
HAVING COUNT(*) > 5;

-- 连接查询
SELECT
    e.name,
    d.department_name
FROM employees e
INNER JOIN departments d ON e.dept_id = d.id;

-- 子查询
SELECT * FROM users
WHERE id IN (SELECT user_id FROM orders WHERE amount > 100);

-- 分页查询（推荐）
SELECT * FROM 表名 ORDER BY id LIMIT 10 OFFSET 0;  -- 第1页
SELECT * FROM 表名 ORDER BY id LIMIT 10 OFFSET 10; -- 第2页
```

### 3. **更新数据**

```sql
-- 基础更新
UPDATE 表名 SET 列1 = 值1, 列2 = 值2 WHERE 条件;

-- 更新所有行
UPDATE 表名 SET status = 'inactive';

-- 使用子查询更新
UPDATE products
SET price = price * 1.1
WHERE category_id IN (
    SELECT id FROM categories WHERE name = 'Electronics'
);

-- 更新并返回结果
UPDATE users SET status = 'active' WHERE id = 1 RETURNING *;
```

### 4. **删除数据**

```sql
-- 删除指定行
DELETE FROM 表名 WHERE 条件;

-- 删除所有行
DELETE FROM 表名;

-- 更快地删除所有行（不可回滚）
TRUNCATE TABLE 表名;

-- 删除并返回结果
DELETE FROM users WHERE id = 1 RETURNING *;
```

## 五、索引操作

### 1. **创建索引**

```sql
-- 创建B-tree索引（默认）
CREATE INDEX idx_name ON 表名 (列名);

-- 创建唯一索引
CREATE UNIQUE INDEX idx_unique_email ON users (email);

-- 创建复合索引
CREATE INDEX idx_name_age ON users (last_name, first_name);

-- 创建部分索引
CREATE INDEX idx_active_users ON users (status) WHERE status = 'active';

-- 创建表达式索引
CREATE INDEX idx_lower_name ON users (LOWER(name));

-- 查看表索引
SELECT * FROM pg_indexes WHERE tablename = '表名';
```

### 2. **删除索引**

```sql
DROP INDEX IF EXISTS 索引名;
```

## 六、事务控制

```sql
-- 开始事务
BEGIN;  -- 或 START TRANSACTION;

-- 提交事务
COMMIT;

-- 回滚事务
ROLLBACK;

-- 保存点
BEGIN;
SAVEPOINT my_savepoint;
-- 一些操作
ROLLBACK TO SAVEPOINT my_savepoint;  -- 回滚到保存点
COMMIT;

-- 事务示例
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

## 七、视图

```sql
-- 创建视图
CREATE VIEW 视图名 AS
SELECT 列1, 列2 FROM 表名 WHERE 条件;

-- 创建可更新视图
CREATE VIEW active_users AS
SELECT * FROM users WHERE status = 'active';

-- 创建物化视图（缓存结果）
CREATE MATERIALIZED VIEW mv_sales_summary AS
SELECT product_id, SUM(quantity) as total_sold
FROM orders
GROUP BY product_id;

-- 刷新物化视图
REFRESH MATERIALIZED VIEW mv_sales_summary;

-- 删除视图
DROP VIEW IF EXISTS 视图名;
```

## 八、函数和存储过程

### 1. **创建函数**

```sql
-- 简单函数
CREATE OR REPLACE FUNCTION get_user_count()
RETURNS INTEGER AS $$
BEGIN
    RETURN (SELECT COUNT(*) FROM users);
END;
$$ LANGUAGE plpgsql;

-- 带参数的函数
CREATE OR REPLACE FUNCTION get_user_by_id(user_id INTEGER)
RETURNS SETOF users AS $$
BEGIN
    RETURN QUERY SELECT * FROM users WHERE id = user_id;
END;
$$ LANGUAGE plpgsql;

-- 调用函数
SELECT get_user_count();
SELECT * FROM get_user_by_id(1);
```

### 2. **创建存储过程**

```sql
CREATE OR REPLACE PROCEDURE update_salary(
    emp_id INTEGER,
    new_salary NUMERIC
)
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE employees SET salary = new_salary WHERE id = emp_id;
    COMMIT;
END;
$$;

-- 调用存储过程
CALL update_salary(1, 50000);
```

## 九、触发器

```sql
-- 创建触发器函数
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器
CREATE TRIGGER update_user_modtime
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();
```

## 十、权限管理

```sql
-- 创建用户/角色
CREATE USER 用户名 WITH PASSWORD '密码';
CREATE ROLE 角色名;

-- 授予权限
GRANT SELECT, INSERT, UPDATE ON 表名 TO 用户名;
GRANT ALL PRIVILEGES ON DATABASE 数据库名 TO 用户名;
GRANT USAGE ON SCHEMA 模式名 TO 用户名;

-- 撤销权限
REVOKE INSERT ON 表名 FROM 用户名;

-- 查看权限
\dp 表名
```

## 十一、高级查询技巧

### 1. **窗口函数**

```sql
SELECT
    name,
    department,
    salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as rank,
    AVG(salary) OVER (PARTITION BY department) as avg_dept_salary
FROM employees;
```

### 2. **CTE（公共表表达式）**

```sql
WITH recent_orders AS (
    SELECT * FROM orders WHERE order_date > CURRENT_DATE - INTERVAL '30 days'
),
high_value_orders AS (
    SELECT * FROM recent_orders WHERE amount > 1000
)
SELECT COUNT(*) FROM high_value_orders;
```

### 3. **JSON操作**

```sql
-- 创建JSON字段
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    attributes JSONB
);

-- 插入JSON数据
INSERT INTO products (name, attributes)
VALUES ('Laptop', '{"color": "black", "ram": 16, "brand": "Dell"}');

-- 查询JSON
SELECT name, attributes->>'brand' as brand FROM products;
SELECT * FROM products WHERE attributes @> '{"brand": "Dell"}';
```

## 十二、实用技巧和最佳实践

### 1. **查看查询计划**

```sql
EXPLAIN SELECT * FROM users WHERE id = 1;
EXPLAIN ANALYZE SELECT * FROM users WHERE id = 1;  -- 实际执行
```

### 2. **导入/导出数据**

```bash
# 导出CSV
psql -c "\copy (SELECT * FROM table) TO 'data.csv' WITH CSV HEADER"

# 导入CSV
psql -c "\copy table FROM 'data.csv' WITH CSV HEADER"
```

### 3. **性能监控**

```sql
-- 查看活跃查询
SELECT * FROM pg_stat_activity;

-- 查看表大小
SELECT
    tablename,
    pg_size_pretty(pg_total_relation_size(tablename)) as total_size
FROM pg_tables
ORDER BY pg_total_relation_size(tablename) DESC;

-- 查看索引使用情况
SELECT * FROM pg_stat_user_indexes;
```

### 4. **维护命令**

```sql
-- 分析表（更新统计信息）
ANALYZE 表名;

-- 重建表（回收空间）
VACUUM FULL 表名;

-- 重建索引
REINDEX TABLE 表名;
```

## 十三、快捷方式速查

| 快捷键 | 功能 |
|--------|------|
| `\e` | 打开文本编辑器编辑查询 |
| `\g` | 再次执行最后一条查询 |
| `\s` | 查看命令历史 |
| `\i 文件` | 执行外部SQL文件 |
| `\o 文件` | 将查询结果输出到文件 |
| `\! 命令` | 执行shell命令 |
| `Ctrl + R` | 搜索命令历史 |
| `Ctrl + D` | 退出psql（等同于\q） |

---

---
url: /Misc/BreakServer/index.md
---
# 记一次炸服务器的经历
> \[!important]
> 系统能运行就已经很厉害了！系统能不出错就不要动它了！
>
> 每次执行命令前务必清楚知道这个命令会做些什么！

## 事故背景

负责的学校 OJ 开发接近尾声，最近正在往服务器上部署。由于有点无法忍受 Ubuntu 18 上版本低得离谱的 Docker 工具，
遂考虑升级 Docker 工具链。于是在 apt 的帮助下，主包成功地把系统更新挂了。

## 数据抢救

于是便紧急学习了如何进行数据抢救，做笔记如下：

### 抢救思路

我们可以从 ISO 的系统入手，将目标机器的文件系统挂载到 ISO 系统中，从而将重要的数据给拿取出来。

### 具体操作

首先先制作 Ubuntu Server Live ISO。

请从 U 盘启动，并选择 **“Try or Install Ubuntu Server”** 选项。通过`Help`菜单会启动到命令行终端界面。

**第一步：识别磁盘和分区，创建挂载点**

1. **列出所有磁盘**：
   使用 `lsblk` 或 `fdisk` 命令来查看系统识别到的硬盘。

   ```bash
   sudo lsblk -f
   ```

   * `lsblk -f` 会显示文件系统类型（如 `ext4`, `ntfs`）和标签（LABEL），这能帮我们更好地识别哪个是原系统分区（比如标有 `OS` 或 `Ubuntu` 的分区）和数据分区。
   * 找到原系统硬盘（比如 `sda`）和它的分区（比如 `sda1`, `sda3`）。

2. **创建挂载点**：
   下面我们需要创建目录作为挂载点，以便访问硬盘里的内容。

   ```bash
   sudo mkdir /mnt/original_disk
   ```

**第二步：挂载原系统分区**

假设数据在 `/dev/sda3` 上：

```bash
sudo mount /dev/sda3 /mnt/original_disk
```

**第三步：挂载备份介质（外接硬盘/U 盘）**

现在，将**另一个**U 盘或移动硬盘插入服务器。再次使用 `lsblk` 命令，它会作为一个新设备出现（比如 `/dev/sdc1`）。

1. **创建挂载点并挂载**：

   ```bash
   sudo mkdir /mnt/backup_drive
   sudo mount /dev/sdc1 /mnt/backup_drive  # 请将 sdc1 替换为实际设备名
   ```

2. **检查挂载结果**：
   使用 `df -h` 命令可以查看所有已挂载的磁盘及其可用空间，确认两个盘都挂载成功了。

**第四步：复制数据**

现在，原系统数据在 `/mnt/original_disk`，备份盘在 `/mnt/backup_drive`。使用 `cp` 或 `rsync` 命令进行复制。

* **使用 `rsync` (可以保留权限、 ownership 等信息)**:

  ```bash
  sudo rsync -av --progress /mnt/original_disk/home/your_username/ /mnt/backup_drive/ubuntu_backup/
  ```

  * `-a`: 归档模式（保留所有属性）
  * `-v`: 显示详细过程
  * `--progress`: 显示传输进度
  * 将 `your_username` 替换为原来的用户名。

* **使用 `cp` (简单直接)**:

  ```bash
  sudo cp -r /mnt/original_disk/home/your_username/Documents /mnt/backup_drive/ubuntu_backup/
  sudo cp -r /mnt/original_disk/home/your_username/Pictures /mnt/backup_drive/ubuntu_backup/
  # ... 复制其他需要的重要文件夹
  ```

**常见的重要目录**

* `/home/username/`（主要数据存放目录）
* `/etc/`（系统配置文件）

**第五步：完成并卸载**

数据复制完成后，安全地卸载磁盘：

```bash
sudo umount /mnt/original_disk
sudo umount /mnt/backup_drive
```

然后便可以关机 (`sudo poweroff`)，拔掉所有 U 盘，数据就已经安全地备份到外接硬盘里了。

## 重装系统

然后就是重装系统了，这也是主包装过的第一个服务器系统。

---

---
url: /Misc/GitHub-Toturial/index.md
---
# GitHub入门指南
## 0xFF 一些概念

**什么是 GitHub？**

> DeepSeek：GitHub 是一个面向开发者的代码托管和协作平台，主要用于**版本控制**和**团队协作开发**。

然而在经历了长期的发展后，GitHub 现已成为了世上资源最丰富的学习资源网站，你可以在这个网站上找到几乎任何资源，包括且不限于：**开源软件**，**书籍**，甚至**表情包**。因此，如果能够熟练使用 GitHub 这一资源宝库，就能收获无尽的知识宝藏。

**什么是开源？**

> 开源（Open Source）是指将软件、硬件或其他创作内容的**源代码（或设计文档）公开**，允许任何人**自由查看、使用、修改和分发**的一种协作模式。其核心是**开放、共享和协作**，打破了传统闭源软件的封闭性。

开源不仅是技术模式，更是一种**协作哲学**。它通过开放共享，让技术发展更民主化，成为推动现代科技创新的核心动力之一。

## 0x00 一些准备

在探索知识宝库之前，我们需要做一些准备工作。

::: tabs
@tab 普通用户
对普通用户而言，我们仅需要注册一个 GitHub 账号。

### 注册 GitHub 账号

1. 访问 [GitHub 官网](https://github.com)
2. 点击右上角的"Sign up"（注册）按钮
3. 填写以下信息：
   * 用户名（Username）：这将是你的 GitHub 身份标识
   * 电子邮箱（Email）：建议使用常用邮箱
   * 密码（Password）：设置一个安全的密码
4. 完成人机验证
5. 选择你的使用计划（建议新手选择免费计划）
6. 完成邮箱验证

### 基本设置

1. 设置个人头像
2. 完善个人简介
3. 设置双因素认证（推荐）

### 开始使用

1. 浏览其他用户的项目
2. 使用搜索功能查找感兴趣的内容
3. 关注感兴趣的项目和用户
4. 参与讨论（Issues 和 Discussions）

@tab 开发者
首先，我们得注册一个 GitHub 账号。详情参考普通用户标签页。

### 安装 Git

1. Windows 用户：

   * 访问 [Git 官网](https://git-scm.com/download/win)
   * 下载并安装 Git for Windows

2. Mac 用户：

   * 打开终端
   * 输入命令：`git --version`
   * 如果没有安装，系统会提示安装

3. Linux 用户：
   * Ubuntu/Debian: `sudo apt-get install git`
   * CentOS/RHEL: `sudo yum install git`

### 配置 Git

```bash
git config --global user.name "你的GitHub用户名"
git config --global user.email "你的GitHub邮箱"
```

### 创建第一个仓库

1. 在 GitHub 上创建新仓库
2. 克隆仓库到本地
3. 添加文件
4. 提交更改
5. 推送到 GitHub

:::

## 0x01 基础操作指南

### 浏览项目

1. 使用搜索框查找项目
2. 使用高级搜索功能（点击搜索框右侧的"Advanced search"）
3. 查看项目 README 文件了解项目信息
4. 查看 Issues 了解项目问题和讨论
5. 查看 Pull Requests 了解项目更新

### 下载项目

1. 直接下载 ZIP 文件
2. 使用 Git 克隆（开发者推荐）
3. 使用 GitHub Desktop（新手友好）

### 参与项目

1. 提交 Issue 报告问题
2. 参与讨论
3. 提交 Pull Request 贡献代码
4. 关注项目更新

## 0x02 进阶技巧

### 使用 GitHub Pages

1. 创建个人博客
2. 发布项目文档
3. 展示项目演示

### 使用 GitHub Actions

1. 自动化测试
2. 自动部署
3. 持续集成

### 使用 GitHub Packages

1. 发布软件包
2. 管理依赖
3. 版本控制

## 0x03 注意事项

1. 遵守开源协议
2. 注意代码安全
3. 保护个人信息
4. 遵守社区规范
5. 及时更新密码
6. 定期备份数据

## 0x05 推荐资源

### 官方资源

1. [GitHub Docs](https://docs.github.com)
2. [GitHub Skills](https://skills.github.com)
3. [GitHub Guides](https://guides.github.com)

### 学习资源

1. [GitHub Learning Lab](https://lab.github.com)
2. [GitHub Education](https://education.github.com)
3. [GitHub Community](https://github.community)

---

---
url: /Misc/GitHub-Workflow/index.md
---
# GitHub工作流
## 0xFF 前沿

最近在教同学学习 git，顺便也回去巩固了 github 工作流的最佳实践。现记录于下。

## 0x00 准备工作

### 1. 下载 Git

[参考链接](https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git)

::: tabs
@tab  Windows
在 Windows 上安装 Git 有几种安装方法。 官方版本可以在 Git 官方网站下载。 打开 <https://git-scm.com/download/win>，
下载会自动开始。

要注意这是一个名为 Git for Windows 的项目（也叫做 msysGit），和 Git 是分别独立的项目；更多信息请访问 <http://msysgit.github.io/>。

@tab  MacOS
在 Mac 上安装 Git 有多种方式。 最简单的方法是安装 Xcode Command Line Tools。 Mavericks （10.9） 或更高版本的系统中，在 Terminal 里尝试首次运行 'git' 命令即可。

```bash
git --version
```

如果没有安装过命令行开发者工具，将会提示你安装。

如果你想安装更新的版本，可以使用二进制安装程序。 官方维护的 macOS Git 安装程序可以在 Git 官方网站下载，
网址为 <https://git-scm.com/download/mac>。

@tab  Linux
如果你想在 Linux 上用二进制安装程序来安装基本的 Git 工具，可以使用发行版包含的基础软件包管理工具来安装。
以 Fedora 为例，如果你在使用它（或与之紧密相关的基于 RPM 的发行版，如 RHEL 或 CentOS），你可以使用 dnf：

```bash
sudo dnf install git-all
```

如果你在基于 Debian 的发行版上，如 Ubuntu，请使用 apt：

```bash
sudo apt install git-all
```

要了解更多选择，Git 官方网站上有在各种 Unix 发行版的系统上安装步骤，网址为 <https://git-scm.com/download/linux>。
:::

---

---
url: /Misc/TS-tricks/index.md
---
# TS类型体操技巧
## 1. keyof 和 in

### keyof

`keyof` 关键字用于提取类型中的键的联合类型。

```ts twoslash
type R = keyof {
  a: 1
  b: 2
  c: 3
}
```

### in

`in` 关键字用于遍历联合类型。

```ts twoslash
type R = {
  [key in ('a' | 'b' | 'c')]: true
}
```

### in + keyof

`in + keyof` 组合可以进行对类型中键的遍历。

```ts twoslash
interface R {
  a: 1
  b: 2
  c: 3
}
type RR = {
  [key in keyof R]: true
}
```

## 2. extends

`extends` 关键字有三种使用方法。

### 1）类的继承

```ts twoslash
class Animal {
  eat(){ console.log(1) }
}

class Dog extends Animal {
  sleep(){ console.log(2) }
}

let dahuang = new Dog();
// @noErrors
dahuang.
//      ^|

type R = Dog extends Animal ? true : false;
```

### 2）类型约束

`extends` 关键字可以对类型进行约束。

```ts twoslash
function func<T extends { length: number }>(a: T, b: T): T {
  if (a.length >= b.length)
    return a
  else return b
}
let test1 = func([1], [1, 2])
// @errors: 2345
let test2 = func([1], 1)
```

### 3）类型判断

`extends` 关键字配合 `? :` 三目运算符使用，可以进行条件判断。`A extends B ? a : b` 意为判断 `A` 是否为 `B` 的子类型，若为真则返回 `a`，否则`b`。

```ts twoslash
type R = 1 extends number ? true : false
type RR = symbol extends string ? true : false
```

## 3. infer

`infer` 关键字用于设置变量。

```ts twoslash
type R<T extends readonly any[]> = T extends [infer First, ...any] ? First : never
type RR = R<[1, 2, 3, 4]>
```

## 4. 数组/元组的遍历

`T[number]` 即可实现对数组/元组类型的遍历，获取其内容的联合类型。

```ts twoslash
type Test<T extends readonly (number | string | symbol)[]> = {
  [key in T[number]]: T[number]
}
type R = Test<[1, 2, '3', symbol]>
```

---

---
url: /OS/index.md
---
# 系统相关笔记
这里主要记录 L0v3ch4n 的一些在操作系统上犯过的蠢、踩过的坑。

包括且不限于：

1. 把`zh_CN`打成了`zh.CN`导致语言本地化失败。
2. 很好的 Linux,使我的声卡找不到。
3. 插上耳机猛干项目，期间碰掉耳机听到扬声器正在“大肆宣扬”。

---

---
url: /OS/ArchLinux/setup/index.md
---
## 0xFF 前言

前前后后两天多，ArchLinux 和一些常用软件的安装也算是基本完成了。

![fastfetch](https://file.l0v3ch4n.top/L0v3ch4n-Docs-images/notes/OS/ArchLinux/setup/fastfetch.jpg)

回想这次的~~挑战~~安装过程，感觉 ArchLinux 的安装过程还是相对比较顺利的 （毕竟网上教程有好多，
跟着[Wiki](https://wiki.archlinuxcn.org/wiki/%E9%A6%96%E9%A1%B5)很多问题也能找到解决方案 ）。

在这边浅浅记录一下本次安装过程中碰到的亿些小问题，也方便今后巩固和回顾。

## 0x00 安装前的准备

### 物料准备

* 一台电脑（不然系统装哪里去）
* 一块 U 盘（8G 就足够了）
* 一根网线（能连无线网就不用这个了）

### 制作启动盘

1. 下载[ArchLinux 镜像](https://archlinux.org/download/)
2. 使用[Rufus](https://rufus.ie/zh/)烧录镜像到 U 盘
3. 重启电脑，进入 BIOS，将 U 盘设置为第一启动项，然后保存并重启
4. 选择 Arch Install 选项，等待 Live 环境启动完成

### Live 环境中的安装前准备

现在我们就在 Live 环境中了，我们需要在安装之前进行一些准备操作。

1. 关闭 reflector 服务
   目前 ArchLinux 中的 reflector 服务会自动更新镜像源，导致我们无法手动选择镜像源，因此我们需要先关闭 reflector 服务。

   ```bash
    systemctl stop reflector.service
   ```

2. 编辑`pacman`镜像源配置文件，将需要的镜像源放于文件头部

   ```bash
    vim /etc/pacman.d/mirrorlist
   ```

3. 硬盘分区、格式化
   这里我使用的是`fdisk`
   进行分区，具体分区操作可以参考[ArchLinux Wiki](https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97#%E5%BB%BA%E7%AB%8B%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA)。

   我的分区表是这样子：

   | 已安装系统上的挂载点 | 分区大小   | 格式化类型                                 | 备注                                      |
   | -------------------- | ---------- | ------------------------------------------ | ----------------------------------------- |
   | /boot                | 1G         | fat32                                      | 启动引导分区，不小于 512M                 |
   | \[SWAP]               | 64G        | Linux swap                                 | Linux 交换分区，按内存大小确定，不小于 4G |
   | /                    | 剩下的空间 | ext4（也可以用 btrfs，快照的大小会比较小） | 根目录，设备剩余空间，至少 23-32GiB       |

   ![lsblk](https://file.l0v3ch4n.top/L0v3ch4n-Docs-images/notes/OS/ArchLinux/setup/lsblk.png)

4. 挂载分区
   使用`mount`命令将分区挂载到对应的挂载点。
   ```bash
   mount /dev/sda1 /mnt # 挂载根分区
   mkdir /mnt/boot # 创建boot目录
   mount /dev/sda2 /mnt/boot # 挂载boot分区
   ```

5. 连接网络
   这里我用的是无线连接，使用`iwctl`命令连接到无线网络。
   ```bash
   iwctl # 进入iwctl命令行
   device list # 列出所有无线网卡设备
   station <interface> scan # 扫描无线网络
   station <interface> get-networks # 获取无线网络列表
   station <interface> connect <ssid> <password> # 连接到无线网络
   exit # 退出iwctl命令行
   ```

## 0x01 正式安装

经过以上挣扎，我们终于可以开始安装系统了。

### 安装必需的软件包和编辑器

我比较喜欢`vim`来在命令行中编辑文件，当然你也可以选择`nano`,`vi`等用得习惯的编辑器。

```bash
pacstrap -K /mnt base linux linux-firmware intel-ucode vim
# 编辑器不要忘了装，新系统中是没有编辑器的
# amd CPU用户需要下载amd-ucode
```

## 0x02 系统配置

### 生成`fstab`文件

```bash
genfstab -U /mnt >> /mnt/etc/fstab
cat /mnt/etc/fstab # 检查写入是否成功
```

### 切换到新系统环境

使用`chroot`命令切换到新系统环境。

```bash
arch-chroot /mnt
```

### 安装辅助软件包

这时候也可以安装一些辅助软件包，这能帮助你更方便地使用、配置系统。

```bash
pacman -S sudo networkmanager xorg xorg-server pipewire-pluse intel-media-driver
```

根据喜好安装 WM，我这边安装的是 KDE Plasma。

```bash
pacman -S sddm plasma-meta kde-applications
```

还有一些日常使用会用到的东西

```bash
pacman -S git openssh zsh fakeroot noto-fonts-cjk
```

安装输入法

```bash
pacman -S fcitx5-im fcitx5-chinese-addons fcitx5-pinyin-moegirl
```

在`/etc/environment`中添加以下内容

```bash
XIM="fcitx"
GTK_IM_MODULE=fcitx
QT_IM_MODULE=fcitx
XMODIFIERS=@im=fcitx
SDL_IM_MODULE=fcitx
GLFW_IM_MODULE=ibus
INPUT_METHOD=fcitx
```

### 设置时区

```bash
ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
```

### 设置语言

```bash
vim /etc/locale.gen # 取消 en_US.UTF-8 UTF-8 和 zh_CN.UTF-8 UTF-8 的注释
locale-gen # 生成语言环境
echo "LANG=zh_CN.UTF-8" > /etc/locale.conf # 设置语言环境
```

### 网络配置

1. 编辑`hostname`文件

   ```bash
   echo yourhostname > /etc/hostname # 设置主机名
   ```

2. 编辑本地主机名文件`/etc/hosts`

   ```bash
   vim /etc/hosts
   ```

   在文件中加入以下内容：

   ```bash
   127.0.0.1   localhost
   ::1         localhost
   127.0.1.1   yourhostname.localdomain yourhostname
   ```

### 设置 root 密码

```bash
passwd # 设置root密码
```

配置用户

```bash
useradd -m -G wheel,audio,video,storage -s /bin/bash yourusername # 创建用户
passwd yourusername # 设置用户密码
```

编辑 sudoers 文件，给用户 sudo 权限

```bash
vim /etc/sudoers
```

在文件中找到`root ALL=(ALL:ALL) ALL`这一行，在下方添加`yourusername ALL=(ALL:ALL) ALL`，保存并退出。

### 设置开机自启动项

```bash
systemctl enable NetworkManager # 开机自启动网络管理器
systemctl enable sddm # 开机自启动显示管理器
```

### 安装`grub`引导程序

```bash
pacman -S grub efibootmgr # 安装grub和efibootmgr
grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB # 安装grub
grub-mkconfig -o /boot/grub/grub.cfg # 生成grub配置文件
```

## 0x03 重启

至此，崭新的带有桌面环境的 ArchLinux 系统就安装完成了。

我们可以通过`exit`命令退出 chroot 环境，然后使用`umount -R /mnt`命令取消挂载分区，
最后使用`reboot`命令重启系统。（记得在启动进入 BIOS 之前拔出 U 盘！！！）

尽情玩耍吧！

## 参考教程

[ArchWiki#安装指南](https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97)

[archlinux 基础安装](https://arch.icekylin.online/guide/rookie/basic-install)

[全盘加密安装 Arch Linux 的一切（困难模式）](https://www.bilibili.com/video/BV1DTT2zSE5R/)

@[bilibili time="0" width="100%" height="400px" ratio="16:9" auto="0"](BV1DTT2zSE5R)

---

---
url: /project/index.md
---
# 项目开发笔记
这里主要记录 L0v3ch4n 的一些在开发项目时做的一些笔记。

目前已完成的项目：

1. 智能电池柜微信小程序
2. \*C\*团队介绍网站

正在开发的项目：

1. OJ 平台

---

---
url: /project/OJ/FrontendInit/index.md
---
# 前端初始化
切换 node 版本的工具：[nvm](https://github.com/nvm-sh/nvm)

## 通过 vue-cli 脚手架创建项目

```shell
npm install -g @vue/cli
vue create my-project
```

## 引入组件库

采用 Arco Design Vue 组件库。

安装：

```shell
npm install --save-dev @arco-design/web-vue
```

引入

```typescript
import ArcoVue from '@arco-design/web-vue'
// main.ts
import { createApp } from 'vue'
import App from './App.vue'
import '@arco-design/web-vue/dist/arco.css'

const app = createApp(App)
app.use(ArcoVue)
app.mount('#app')
```

---

---
url: /project/OJ/MarkDownEditorDev/index.md
---
# 整合MarkDown编辑器
为了方便进行文本编辑，计划封装整合一个 MarkDown 编辑器方便调用。 选用`ByteMD`框架。

## 安装

```shell
npm install @bytemd/vue-next
```

## 引入

```typescript
// main.ts
import 'bytemd/dist/index.css'
```

```vue
// @/components/MdEditor.vue
<script lang="ts" setup>
import gfm from '@bytemd/plugin-gfm'
import highlight from '@bytemd/plugin-highlight'
import math from '@bytemd/plugin-math'

const plugins = [
  gfm(),
  highlight(),
  math(),
  // Add more plugins here
]

function handleChange(v: string) {
  value.value = v
}
</script>

<template>
  <Editor :value="value" :plugins="plugins" @change="handleChange" />
</template>
```

## 组件间传参

遇到了问题：父组件无法拿到子组件中的值。

解决方法：通过在父组件中定义取值方法，将更新值的方法传入子组件，并在子组件中绑定事件以达成实时更新当前的值。
:::tabs
@tab 父组件

```vue
<script lang="ts" setup>
function onContentChange(v: string) {
  // [!code highlight]
  question.value.content = v // [!code highlight]
} // [!code highlight]
</script>

<template>
  <MdEditor :handle-change="onContentChange" :value="question.content" />
</template>
```

@tab 子组件

```vue
<script lang="ts" setup>
import gfm from '@bytemd/plugin-gfm'
import highlight from '@bytemd/plugin-highlight'
import math from '@bytemd/plugin-math'
import { defineProps, withDefaults } from 'vue'

/**
   定义组件属性类型
 */
interface Props {
  value: string
  mode?: string
  handleChange: (v: string) => void
}

/**
   给组件指定初始值
 */
const props = withDefaults(defineProps<Props>(), {
  value: () => '',
  mode: () => 'split',
  handleChange: (v: string) => {
    console.log(v)
  },
})

const plugins = [
  gfm(),
  highlight(),
  math(),
  // Add more plugins here
]
</script>

<template>
  <Editor
    :mode="mode"
    :plugins="plugins"
    :value="value"
    @change="handleChange"
  />
</template>
```

:::
还有一种组件间传参的方法：`v-model`：
:::tabs
@tab 父组件

```vue
<template>
  <MdEditor v-model:value="question.content" />
</template>
```

@tab 子组件

```vue
<script lang="ts" setup>
import gfm from '@bytemd/plugin-gfm'
import highlight from '@bytemd/plugin-highlight'
import math from '@bytemd/plugin-math'
import { defineEmits, defineProps, withDefaults } from 'vue'

/**
   定义组件属性类型
 */
interface Props {
  value: string
  mode?: string
  handleChange: (v: string) => void
}

/**
   给组件指定初始值
 */
const props = withDefaults(defineProps<Props>(), {
  value: () => '',
  mode: () => 'split',
})

const emit = defineEmits(['update:value'])

const plugins = [gfm(), highlight(), math()]

// [!code highlight]
function handleChange(v: string) {
  // [!code highlight]
  emit('update:value', v) // [!code highlight]
} // [!code highlight]
</script>

<template>
  <Editor
    :mode="mode"
    :plugins="plugins"
    :value="value"
    @change="handleChange"
  />
</template>
```

:::

---

---
url: /secrets/index.md
---
# 加密文章
这里是 L0v3ch4n 不想被人知道的小秘密。

---

---
url: /TypeGymnastics/index.md
---
# TypeScript类型体操
## 简介

[type-challenges](https://github.com/type-challenges/type-challenges) 是一个能够让你更好的
了解 `typescript` 类型系统的开源项目。

本笔记用于整理记录 L0v3ch4n 的类型体操学习过程。

根据 [type-challenges](https://github.com/type-challenges/type-challenges) 的题目难度，
分为了五个难度：

* `热身`  1 / 1
* `简单`  13 / 13
* `中等`  0 / 103
* `困难`  0 / 43
* `地狱`  0 / 14

## VSCode 插件

[VS Code 插件 **Type-Challenges**](https://marketplace.visualstudio.com/items?itemName=YRM.type-challenges){.read-more}

插件提供了开源项目的所有题目，以及测试用例，可以通过在 `VSCode` 中安装该插件，在 `VSCode` 中进行答题，
以获得良好的 编辑器类型检查帮助。

## 说明

在这个项目中，每一个挑战都将作为单独的文章进行编写。其内容包括:

* **题目**：提出的挑战
* **解题思路**
* **答案**
* **验证**：借助 [typescript twoslash](https://theme-plume.vuejs.press/guide/markdown/twoslash/) 的帮助，你可以在这里查看答案中每一处的类型，以及验证结果是否符合预期
* **参考**：列出这个挑战需要使用的 `typescript` 知识点

## 类型工具

在 验证 过程中，将会使用到以下的类型工具：

```ts
/**
 * 类型断言
 */
export type Expect<T extends true> = T
export type ExpectTrue<T extends true> = T
export type ExpectFalse<T extends false> = T
export type IsTrue<T extends true> = T
export type IsFalse<T extends false> = T

/**
 * 比较两个类型是否完全相等
 */
export type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
  ? true
  : false
export type NotEqual<X, Y> = true extends Equal<X, Y> ? false : true

/**
 * 判断类型是否为 `any`
 */
export type IsAny<T> = 0 extends 1 & T ? true : false
export type NotAny<T> = true extends IsAny<T> ? false : true

export type Debug<T> = { [K in keyof T]: T[K] }
export type MergeInsertions<T> = T extends object ? { [K in keyof T]: MergeInsertions<T[K]> } : T

/**
 * 判断两个类型是否相似
 */
export type Alike<X, Y> = Equal<MergeInsertions<X>, MergeInsertions<Y>>

/**
 * 判断一个类型是否继承于另一个类型
 */
export type ExpectExtends<VALUE, EXPECTED> = EXPECTED extends VALUE ? true : false
/**
 * 判断一个函数的参数是否符合预期
 */
export type ExpectValidArgs<
  FUNC extends (...args: any[]) => any,
  ARGS extends any[]
> = ARGS extends Parameters<FUNC> ? true : false

/**
 * 将联合类型转换为交叉类型
 */
export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I
) => void
  ? I
  : never
```

---

---
url: /TypeGymnastics/easy/Awaited/index.md
---
# Awaited
## 题目

假如我们有一个 Promise 对象，这个 Promise 对象会返回一个类型。在 TS 中，我们用 `Promise<T>` 中的 T 来描述这个 Promise 返回的类型。请你实现一个类型，可以获取这个类型。

例如：`Promise<ExampleType>`，请你返回 ExampleType 类型。

```ts
type ExampleType = Promise<string>

type Result = MyAwaited<ExampleType> // string
```

> 这个挑战来自于 [@maciejsikora](https://github.com/maciejsikora) 的文章：[original article](https://dev.to/macsikora/advanced-typescript-exercises-question-1-45k4)

## 解题思路

考虑到样例中不是只有 `Promise` 类型，其中有实现了 `then` 方法的对象，我们采用 `PromiseLise` 类型。

递归地对传入类型进行拆解，形式为 `PromiseLike<R>`，对 `R` 进一步判断是否需要继续拆解，若仍为 `PromiseLike` 类型则继续，否则返回 `R`。

## 答案

```ts
type MyAwaited<T> = T extends PromiseLike<infer R>
  ? R extends PromiseLike<any>
    ? MyAwaited<R>
    : R
  : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type MyAwaited<T> = T extends PromiseLike<infer R> ? R extends PromiseLike<any> ? MyAwaited<R> : R : never
// ---cut---
type X = Promise<string>
type Y = Promise<{ field: number }>
type Z = Promise<Promise<string | number>>
type Z1 = Promise<Promise<Promise<string | boolean>>>
interface T { then: (onfulfilled: (arg: number) => any) => any }

type cases = [
  Expect<Equal<MyAwaited<X>, string>>,
  Expect<Equal<MyAwaited<Y>, { field: number }>>,
  Expect<Equal<MyAwaited<Z>, string | number>>,
  Expect<Equal<MyAwaited<Z1>, string | boolean>>,
  Expect<Equal<MyAwaited<T>, number>>,
]
```

## 参考

> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
> * [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /TypeGymnastics/easy/Concat/index.md
---
# Concat
## 题目

在类型系统里实现 JavaScript 内置的 `Array.concat` 方法，这个类型接受两个参数，返回的新数组类型应该按照输入参数从左到右的顺序合并为一个新的数组。

例如：

```ts
type Result = Concat<[1], [2]> // expected to be [1, 2]
```

## 解题思路

利用数组的展开语法即可。

## 答案

```ts
type Concat<T extends readonly any[], U extends readonly any[]> = [...T, ...U]
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type Concat<T extends readonly any[], U extends readonly any[]> = [...T, ...U]
// ---cut---
const tuple = [1] as const

type cases = [
  Expect<Equal<Concat<[], []>, []>>,
  Expect<Equal<Concat<[], [1]>, [1]>>,
  Expect<Equal<Concat<typeof tuple, typeof tuple>, [1, 1]>>,
  Expect<Equal<Concat<[1, 2], [3, 4]>, [1, 2, 3, 4]>>,
  Expect<Equal<Concat<['1', 2, '3'], [false, boolean, '4']>, ['1', 2, '3', false, boolean, '4']>>,
]

// @ts-expect-error
type error = Concat<null, undefined>
```

## 参考

> * [可变元组 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /TypeGymnastics/easy/Exclude/index.md
---
# Exclude
## 题目

实现内置的 `Exclude<T, U>` 类型，但不能直接使用它本身。

> 从联合类型 `T` 中排除 `U` 中的类型，来构造一个新的类型。

例如：

```ts
type Result = MyExclude<'a' | 'b' | 'c', 'a'> // 'b' | 'c'
```

## 解题思路

判断 `T` 的类型是否 是 `U` 的类型进行取舍即可。

## 答案

```ts
type MyExclude<T, U> = T extends U ? never : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type MyExclude<T, U> = T extends U ? never : T
// ---cut---
type cases = [
  Expect<Equal<MyExclude<'a' | 'b' | 'c', 'a'>, 'b' | 'c'>>,
  Expect<Equal<MyExclude<'a' | 'b' | 'c', 'a' | 'b'>, 'c'>>,
  Expect<Equal<MyExclude<string | number | (() => void), Function>, string | number>>,
]
```

## 参考

> [分配条件类型 Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)

---

---
url: /TypeGymnastics/easy/First-of-Array/index.md
---
# First of Array
## 题目

实现一个`First<T>`泛型，它接受一个数组`T`并返回它的第一个元素的类型。

例如：

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

type head1 = First<arr1> // 应推导出 'a'
type head2 = First<arr2> // 应推导出 3
```

## 解题思路

1. `infer R` 可以定义类似变量的概念，以形式进行匹配。
2. `T extends R ? ... : ...` 可作为类似三元表达式的效果，用于判断 `T` 是否为 `R` 的子集。

## 答案

```ts
type First<T extends any[]> = T extends [infer first, ...infer rest] ? first : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type First<T extends any[]> = T extends [infer first, ...infer rest] ? first : never
// ---cut---
type cases = [
  Expect<Equal<First<[3, 2, 1]>, 3>>,
  Expect<Equal<First<[() => 123, { a: string }]>, () => 123>>,
  Expect<Equal<First<[]>, never>>,
  Expect<Equal<First<[undefined]>, undefined>>,
]

type errors = [
  // @ts-expect-error
  First<'notArray'>,
  // @ts-expect-error
  First<{ 0: 'arrayLike' }>,
]
```

## 参考

> * [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)

---

---
url: /TypeGymnastics/easy/If/index.md
---
# If
## 题目

实现一个 `IF` 类型，它接收一个条件类型 `C` ，一个判断为真时的返回类型 `T` ，以及一个判断为假时的返回类型 `F`。 `C` 只能是 `true` 或者 `false`， `T` 和 `F` 可以是任意类型。

例如：

```ts
type A = If<true, 'a', 'b'> // expected to be 'a'
type B = If<false, 'a', 'b'> // expected to be 'b'
```

## 解题思路

`extends` 关键字配合 `? :` 三目运算符使用，可以进行条件判断。`A extends B ? a : b` 意为判断 `A` 是否为 `B` 的子类型，若为真则返回 `a`，否则`b`。

## 答案

```ts
type If<C extends boolean, T, F> = C extends true ? T : F
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type If<C extends boolean, T, F> = C extends true ? T : F
// ---cut---
type cases = [
  Expect<Equal<If<true, 'a', 'b'>, 'a'>>,
  Expect<Equal<If<false, 'a', 2>, 2>>,
  Expect<Equal<If<boolean, 'a', 2>, 'a' | 2>>,
]

// @ts-expect-error
type error = If<null, 'a', 'b'>
```

## 参考

> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)

---

---
url: /TypeGymnastics/easy/Includes/index.md
---
# Includes
## 题目

在类型系统里实现 JavaScript 的 `Array.includes` 方法，这个类型接受两个参数，返回的类型要么是 `true` 要么是 `false`。

例如：

```ts
type isPillarMen = Includes<['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Dio'> // expected to be `false`
```

## 解题思路

第一次尝试是这样的：

```ts
type Includes<T extends readonly any[], U> = T extends [infer First, ...infer Rest]
  ? U extends First
    ? true
    : Includes<Rest, U>
  : false
```

但是存在一个问题，即 `{}` 和 `{ 1, 2 }` 是同类型的，并非相等。故需要引入 `Equal` 进行相等判断。

```ts
// 利用函数进行延迟求值
type MyEqual<T, U> = (
  <P>() => P extends T ? 1 : 2
) extends (
  <P>() => P extends U ? 1 : 2
) ? true : false
```

## 答案

```ts
type MyEqual<T, U> = (
  <P>() => P extends T ? 1 : 2
) extends (
  <P>() => P extends U ? 1 : 2
) ? true : false

type Includes<T extends readonly any[], U> = T extends [infer First, ...infer Rest]
  ? MyEqual<U, First> extends true
    ? true
    : Includes<Rest, U>
  : false
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type MyEqual<T, U> = (
  <P>() => P extends T ? 1 : 2
) extends (
  <P>() => P extends U ? 1 : 2
) ? true : false

type Includes<T extends readonly any[], U> = T extends [infer First, ...infer Rest]
  ? MyEqual<U, First> extends true
    ? true
    : Includes<Rest, U>
  : false
// ---cut---
type cases = [
  Expect<Equal<Includes<['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Kars'>, true>>,
  Expect<Equal<Includes<['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Dio'>, false>>,
  Expect<Equal<Includes<[1, 2, 3, 5, 6, 7], 7>, true>>,
  Expect<Equal<Includes<[1, 2, 3, 5, 6, 7], 4>, false>>,
  Expect<Equal<Includes<[1, 2, 3], 2>, true>>,
  Expect<Equal<Includes<[1, 2, 3], 1>, true>>,
  Expect<Equal<Includes<[{}], { a: 'A' }>, false>>,
  Expect<Equal<Includes<[boolean, 2, 3, 5, 6, 7], false>, false>>,
  Expect<Equal<Includes<[true, 2, 3, 5, 6, 7], boolean>, false>>,
  Expect<Equal<Includes<[false, 2, 3, 5, 6, 7], false>, true>>,
  Expect<Equal<Includes<[{ a: 'A' }], { readonly a: 'A' }>, false>>,
  Expect<Equal<Includes<[{ readonly a: 'A' }], { a: 'A' }>, false>>,
  Expect<Equal<Includes<[1], 1 | 2>, false>>,
  Expect<Equal<Includes<[1 | 2], 1>, false>>,
  Expect<Equal<Includes<[null], undefined>, false>>,
  Expect<Equal<Includes<[undefined], null>, false>>,
]
```

## 参考

> * [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
> * [泛型约束 Generics Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
> * [条件类型分支 Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)
> * [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /TypeGymnastics/easy/Length-of-Tuple/index.md
---
# Length of Tuple
## 题目

创建一个`Length`泛型，这个泛型接受一个只读的元组，返回这个元组的长度。

例如：

```ts
type tesla = ['tesla', 'model 3', 'model X', 'model Y']
type spaceX = ['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT']

type teslaLength = Length<tesla> // expected 4
type spaceXLength = Length<spaceX> // expected 5
```

## 解题思路

获取元组的 `length` 属性即可。

注意若要获取 `length` 属性，需要限定泛型的类型。

## 答案

```ts
type Length<T extends readonly any[]> = T['length']
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type Length<T extends readonly any[]> = T['length']
// ---cut---
const tesla = ['tesla', 'model 3', 'model X', 'model Y'] as const
const spaceX = ['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT'] as const

type cases = [
  Expect<Equal<Length<typeof tesla>, 4>>,
  Expect<Equal<Length<typeof spaceX>, 5>>,
  // @ts-expect-error
  Length<5>,
  // @ts-expect-error
  Length<'hello world'>,
]
```

## 参考

> * [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /TypeGymnastics/easy/Parameters/index.md
---
# Parameters
## 题目

实现内置的 `Parameters<T>` 类型，而不是直接使用它，可参考[TypeScript官方文档](https://www.typescriptlang.org/docs/handbook/utility-types.html#parameterstype)。

例如：

```ts
function foo(arg1: string, arg2: number): void {}

type FunctionParamsType = MyParameters<typeof foo> // [arg1: string, arg2: number]
```

## 解题思路

使用 `infer` 关键字进行形式匹配。

## 答案

```ts
type MyParameters<T extends (...args: any[]) => any> = T extends (
  ...args: infer R
) => any ? R : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type MyParameters<T extends (...args: any[]) => any> = T extends (...args: infer R) => any ? R : never
// ---cut---
function foo(arg1: string, arg2: number): void {}
function bar(arg1: boolean, arg2: { a: 'A' }): void {}
function baz(): void {}

type cases = [
  Expect<Equal<MyParameters<typeof foo>, [string, number]>>,
  Expect<Equal<MyParameters<typeof bar>, [boolean, { a: 'A' }]>>,
  Expect<Equal<MyParameters<typeof baz>, []>>,
]
```

## 参考

> * [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
> * [条件类型内推断 Inferring Within Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /TypeGymnastics/easy/Pick/index.md
---
# Pick
## 题目

不使用 `Pick<T, K>` ，实现 TS 内置的 `Pick<T, K>` 的功能。

**从类型 `T` 中选出符合 `K` 的属性，构造一个新的类型**。

例如：

```ts
interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = MyPick<Todo, 'title' | 'completed'>

const todo: TodoPreview = {
  title: 'Clean room',
  completed: false,
}
```

## 解题思路

通过 `keyof` 关键字获取 `T` 的键数组，再利用 `in` 关键字遍历键数组获取每个键。

## 答案

```ts
type MyPick<T, K extends keyof T> = {
  [key in K]: T[key]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type MyPick<T, K extends keyof T> = {
  [key in K]: T[key]
}
// ---cut---
type cases = [
  Expect<Equal<Expected1, MyPick<Todo, 'title'>>>,
  Expect<Equal<Expected2, MyPick<Todo, 'title' | 'completed'>>>,
  // @ts-expect-error
  MyPick<Todo, 'title' | 'completed' | 'invalid'>,
]

interface Todo {
  title: string
  description: string
  completed: boolean
}

interface Expected1 {
  title: string
}

interface Expected2 {
  title: string
  completed: boolean
}
```

## 参考

> * [查找类型 Lookup Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)
> * [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
> * [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /TypeGymnastics/easy/Push/index.md
---
# Push
## 题目

在类型系统里实现通用的 `Array.push` 。

例如：

```typescript
type Result = Push<[1, 2], '3'> // [1, 2, '3']
```

## 解题思路

展开数组即可。

## 答案

```ts
type Push<T extends any[], U> = [...T, U]
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type Push<T extends any[], U> = [...T, U]
// ---cut---
type cases = [
  Expect<Equal<Push<[], 1>, [1]>>,
  Expect<Equal<Push<[1, 2], '3'>, [1, 2, '3']>>,
  Expect<Equal<Push<['1', 2, '3'], boolean>, ['1', 2, '3', boolean]>>,
]
```

## 参考

> * [可变元组 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
> * [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
> * [泛型约束 Generics Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)

---

---
url: /TypeGymnastics/easy/Readonly/index.md
---
# Readonly
## 题目

不要使用内置的`Readonly<T>`，自己实现一个。

泛型 `Readonly<T>` 会接收一个 *泛型参数*，并返回一个完全一样的类型，只是所有属性都会是只读 (readonly) 的。

也就是不可以再对该对象的属性赋值。

例如：

```ts
interface Todo {
  title: string
  description: string
}

const todo: MyReadonly<Todo> = {
  title: 'Hey',
  description: 'foobar'
}

todo.title = 'Hello' // Error: cannot reassign a readonly property
todo.description = 'barFoo' // Error: cannot reassign a readonly property
```

## 解题思路

在遍历键数组的基础上为每个键值添加 `readonly` 标记。

## 答案

```ts
type MyReadonly<T> = {
  readonly [key in keyof T]: T[key]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type MyReadonly<T> = {
  readonly [key in keyof T]: T[key]
}
// ---cut---
type cases = [
  Expect<Equal<MyReadonly<Todo1>, Readonly<Todo1>>>,
]

interface Todo1 {
  title: string
  description: string
  completed: boolean
  meta: {
    author: string
  }
}
```

## 参考

> * [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)

---

---
url: /TypeGymnastics/easy/Tuple-to-Object/index.md
---
# Tuple to Object
## 题目

将一个元组类型转换为对象类型，这个对象类型的键/值和元组中的元素对应。

例如：

```ts
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

type result = TupleToObject<typeof tuple> // expected { 'tesla': 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}
```

## 解题思路

`T[number]` 即可遍历 `T` 元组中的元素。

## 答案

```ts
type TupleToObject<T extends readonly (number | string | symbol)[]> = {
  [P in T[number]]: P
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type TupleToObject<T extends readonly (number | string | symbol)[]> = {
  [P in T[number]]: P
}
// ---cut---
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const
const tupleNumber = [1, 2, 3, 4] as const
const sym1 = Symbol(1)
const sym2 = Symbol(2)
const tupleSymbol = [sym1, sym2] as const
const tupleMix = [1, '2', 3, '4', sym1] as const

type cases = [
  Expect<Equal<TupleToObject<typeof tuple>, { 'tesla': 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y' }>>,
  Expect<Equal<TupleToObject<typeof tupleNumber>, { 1: 1, 2: 2, 3: 3, 4: 4 }>>,
  Expect<Equal<TupleToObject<typeof tupleSymbol>, { [sym1]: typeof sym1, [sym2]: typeof sym2 }>>,
  Expect<Equal<TupleToObject<typeof tupleMix>, { 1: 1, 2: '2', 3: 3, 4: '4', [sym1]: typeof sym1 }>>,
]

// @ts-expect-error
type error = TupleToObject<[[1, 2], {}]>
```

## 参考

> * [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
> * [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /TypeGymnastics/easy/Unshift/index.md
---
# Unshift
## 题目

实现类型版本的 `Array.unshift`。

例如：

```typescript
type Result = Unshift<[1, 2], 0> // [0, 1, 2]
```

## 解题思路

待补充

## 答案

```ts
type Unshift<T extends any[], U> = [U, ...T]
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type Unshift<T extends any[], U> = [U, ...T]
// ---cut---
type cases = [
  Expect<Equal<Unshift<[], 1>, [1]>>,
  Expect<Equal<Unshift<[1, 2], 0>, [0, 1, 2]>>,
  Expect<Equal<Unshift<['1', 2, '3'], boolean>, [boolean, '1', 2, '3']>>,
]
```

## 参考

> * [可变元组 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
> * [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
> * [泛型约束 Generics Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)

---

---
url: /TypeGymnastics/extreme/Assert-Array-Index/index.md
---
# Assert Array Index
## 题目

Sometimes we want to use the good old `for`-loop with an index to traverse the array, but in this case TypeScript does not check in any way that we are accessing the elements of the array at its real index (not exceeding the length of the array), and that we are not using an arbitrary number as an index, or index from another array (for nested loops, for traversing matrices or graphs):

```ts
const matrix = [
  [3, 4],
  [5, 6],
  [7, 8],
]

// This example contains no type errors when the noUncheckedIndexedAccess option is off.
for (let i = 0; i < matrix.length; i += 1) {
  const columns: number[] = matrix[i]

  for (let j = 0; j < columns.length; j += 1) {
    const current: number = columns[i] // oops! i instead of j

    console.log(
      current.toFixed(), // TypeError: Cannot read property 'toFixed' of undefined
    )
  }
}
```

You can enable the [noUncheckedIndexedAccess](https://www.typescriptlang.org/tsconfig#noUncheckedIndexedAccess) option (in `tsconfig.json`), but then each time you access an array element, you will need to check that this element exists, which is somewhat verbose and inconvenient, especially since in the case of such a `for`-traversal, we are sure that the index does not exceed the length of the array:

```ts
const numbers = [5, 7]

for (let i = 0; i < numbers.length; i += 1) {
  const current = numbers[i]

  if (current !== undefined) {
    console.log(current.toFixed())
  }
}
```

Write an `assert`-function `assertArrayIndex(array, key)` that can be applied to any `array` (with an arbitrary unique string `key`, which is needed to distinguish arrays at the type level) to allow access to the elements of this array only by the index obtained from array by the special generic type `Index<typeof array>` (this functionality requires enabling the [noUncheckedIndexedAccess](https://www.typescriptlang.org/tsconfig#noUncheckedIndexedAccess) option in `tsconfig.json`):

```ts
const numbers = [5, 7]

assertArrayIndex(numbers, 'numbers')

for (let i = 0 as Index<typeof numbers>; i < numbers.length; i += 1) {
  console.log(numbers[i].toFixed())
}
```

When accessing by such an index, it must be guaranteed that an element in the array exists, and when accessing an array by any other indices, there is no such guarantee (the element may not exist):

```ts
const matrix = [
  [3, 4],
  [5, 6],
  [7, 8],
]

assertArrayIndex(matrix, 'rows')

let sum = 0

for (let i = 0 as Index<typeof matrix>; i < matrix.length; i += 1) {
  const columns: number[] = matrix[i]

  // @ts-expect-error: number | undefined in not assignable to number
  const x: number[] = matrix[0]

  assertArrayIndex(columns, 'columns')

  for (let j = 0 as Index<typeof columns>; j < columns.length; j += 1) {
    sum += columns[j]

    // @ts-expect-error: number | undefined in not assignable to number
    const y: number = columns[i]

    // @ts-expect-error: number | undefined in not assignable to number
    const z: number = columns[0]

    // @ts-expect-error: number[] | undefined in not assignable to number[]
    const u: number[] = matrix[j]
  }
}
```

The `assertArrayIndex` function cannot be called on tuples (since the accessing the elements is already well typed in them):

```ts
const tuple = [5, 7] as const

// @ts-expect-error
assertArrayIndex(tuple, 'tuple')
```

(Additional design considerations for the proposed API: [#925](https://github.com/type-challenges/type-challenges/issues/925#issuecomment-780889329).)

## 解题思路

待补充

## 答案

```ts
function assertArrayIndex(array: readonly unknown[], key: string) {}

type Index<Array> = any
```

## 验证

```ts
const matrix = [
  [3, 4],
  [5, 6],
  [7, 8],
]

assertArrayIndex(matrix, 'rows')

let sum = 0

for (let i = 0 as Index<typeof matrix>; i < matrix.length; i += 1) {
  const columns: number[] = matrix[i]

  // @ts-expect-error: number | undefined in not assignable to number
  const x: number[] = matrix[0]

  assertArrayIndex(columns, 'columns')

  for (let j = 0 as Index<typeof columns>; j < columns.length; j += 1) {
    sum += columns[j]

    // @ts-expect-error: number | undefined in not assignable to number
    const y: number = columns[i]

    // @ts-expect-error: number | undefined in not assignable to number
    const z: number = columns[0]

    // @ts-expect-error: number[] | undefined in not assignable to number[]
    const u: number[] = matrix[j]
  }
}

const a: string[] = []

assertArrayIndex(a, 'a')

for (let p = 0 as Index<typeof a>; p < a.length; p += 1) {
  const value: string = a[p]

  // @ts-expect-error: string | undefined is not assignable to string
  const z: string = a[2]
}

a.push('qux')
// @ts-expect-error: number is not assignable to string
a.push(3)

for (const value of a) {
  const other: string = value
}

const b: number[] = []

assertArrayIndex(b, 'b')

for (let p = 0 as Index<typeof a>; p < b.length; p += 1) {
  // @ts-expect-error: number | undefined is not assignable to string
  const value: string = b[p]
}

const c: string[] = []

assertArrayIndex(c, 'c')

for (let p = 0; p < c.length; p += 1) {
  // @ts-expect-error: string | undefined is not assignable to string
  let value: string = c[p]

  // @ts-expect-error: string | undefined is not assignable to string
  value = c[0 as Index<typeof a>]
}

const d: readonly number[] = []

assertArrayIndex(d, 'd')

for (let p = 0 as Index<typeof d>; p < d.length; p += 1) {
  const value: number = d[p]

  // @ts-expect-error: only permits reading
  d[2] = 3
}

// @ts-expect-error: push does not exist on readonly
d.push(3)

const e: [number] = [0]

// @ts-expect-error: [number] is not assignable to never
assertArrayIndex(e, 'e')

const f: readonly [boolean] = [false]

// @ts-expect-error: [boolean] is not assignable to never
assertArrayIndex(f, 'f')

const tuple = [5, 7] as const

// @ts-expect-error: readonly [5, 7] is not assignable to never
assertArrayIndex(tuple, 'tuple')
```

## 参考

无

---

---
url: /TypeGymnastics/extreme/CountReversePairs/index.md
---
# CountReversePairs
## 题目

Given an integer array nums, return the number of reverse pairs in the array.

A reverse pair is a pair (i, j) where:

* 0 <= i < j < nums.length and
* nums\[i] > nums\[j].

## 解题思路

待补充

## 答案

```ts
type CountReversePairs<T extends number[]> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<CountReversePairs<[5, 2, 6, 1]>, 4>>,
  Expect<Equal<CountReversePairs<[1, 2, 3, 4]>, 0>>,
  Expect<Equal<CountReversePairs<[-1, -1]>, 0>>,
  Expect<Equal<CountReversePairs<[-1]>, 0>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/extreme/Currying-2/index.md
---
# Currying 2
## 题目

[Currying](https://en.wikipedia.org/wiki/Currying) 是一种将带有多个参数的函数转换为每个带有一个参数的函数序列的技术。

但是在前端的日常开发中，柯里化函数参数个数动态化却是非常常见的，例如 `Function.bind(this, [...params])`

```ts
function func(a: number, b: number, c: number) {
  return a + b + c
}

const bindFunc = func(null, 1, 2)

const result = bindFunc(3) // result: 6
```

因此，在 `柯里化` 的基础上，我们更需要的是 `动态参数化的柯里化函数`

```ts
const add = (a: number, b: number, c: number) => a + b + c
const three = add(1, 1, 1)

const curriedAdd = DynamicParamsCurrying(add)
const six = curriedAdd(1, 2, 3)
const seven = curriedAdd(1, 2)(4)
const eight = curriedAdd(2)(3)(4)
```

传递给 `DynamicParamsCurrying` 的函数可能有多个参数，您需要实现它的类型。

在此挑战中，curriedAdd函数每次可接受最少一个参数，但是所有参数个数总和及类型与原函数相同。分配完所有参数后，它应返回其结果。

## 解题思路

待补充

## 答案

```ts
declare function DynamicParamsCurrying(fn: any): any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

const curried1 = DynamicParamsCurrying((a: string, b: number, c: boolean) => true)
const curried2 = DynamicParamsCurrying((a: string, b: number, c: boolean, d: boolean, e: boolean, f: string, g: boolean) => true)

const curried1Return1 = curried1('123')(123)(true)
const curried1Return2 = curried1('123', 123)(false)
const curried1Return3 = curried1('123', 123, true)

const curried2Return1 = curried2('123')(123)(true)(false)(true)('123')(false)
const curried2Return2 = curried2('123', 123)(true, false)(true, '123')(false)
const curried2Return3 = curried2('123', 123)(true)(false)(true, '123', false)
const curried2Return4 = curried2('123', 123, true)(false, true, '123')(false)
const curried2Return5 = curried2('123', 123, true)(false)(true)('123')(false)
const curried2Return6 = curried2('123', 123, true, false)(true, '123', false)
const curried2Return7 = curried2('123', 123, true, false, true)('123', false)
const curried2Return8 = curried2('123', 123, true, false, true)('123')(false)
const curried2Return9 = curried2('123', 123, true, false, true, '123')(false)
const curried2Return10 = curried2('123', 123, true, false, true, '123', false)

// @ts-expect-error
const curried1ReturnWrong = curried1('123')(123)('wrong arg type')
// @ts-expect-error
const curried1ReturnWrong2 = curried1('123')()(123)(true)

type cases = [
  Expect<Equal<typeof curried1Return1, boolean>>,
  Expect<Equal<typeof curried1Return2, boolean>>,
  Expect<Equal<typeof curried1Return3, boolean>>,

  Expect<Equal<typeof curried2Return1, boolean>>,
  Expect<Equal<typeof curried2Return2, boolean>>,
  Expect<Equal<typeof curried2Return3, boolean>>,
  Expect<Equal<typeof curried2Return4, boolean>>,
  Expect<Equal<typeof curried2Return5, boolean>>,
  Expect<Equal<typeof curried2Return6, boolean>>,
  Expect<Equal<typeof curried2Return7, boolean>>,
  Expect<Equal<typeof curried2Return8, boolean>>,
  Expect<Equal<typeof curried2Return9, boolean>>,
  Expect<Equal<typeof curried2Return10, boolean>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/extreme/DistributeUnions/index.md
---
# DistributeUnions
## 题目

Implement a type `Distribute Unions`, that turns a type of data structure containing union types into a union of
all possible types of permitted data structures that don't contain any union. The data structure can be any
combination of objects and tuples on any level of nesting.

For example:

```ts
type T1 = DistributeUnions<[1 | 2, 'a' | 'b']>
// =>   [1, 'a'] | [2, 'a'] | [1, 'b'] | [2, 'b']

type T2 = DistributeUnions<{ type: 'a', value: number | string } | { type: 'b', value: boolean }>
//  =>  | { type 'a', value: number }
//      | { type 'a', value: string }
//      | { type 'b', value: boolean }

type T3 = DistributeUnions<[{ value: 'a' | 'b' }, { x: { y: 2 | 3 } }] | 17>
//  =>  | [{ value: 'a' },  { x: { y: 2  } }]
//      | [{ value: 'a' },  { x: { y: 3  } }]
//      | [{ value: 'b' },  { x: { y: 2  } }]
//      | [{ value: 'b' },  { x: { y: 3  } }]
//      | 17
```

For context, this type can be very useful if you want to exclude a case on deep data structures:

```ts
type ExcludeDeep<A, B> = Exclude<DistributeUnions<A>, B>

type T0 = ExcludeDeep<[{ value: 'a' | 'b' }, { x: { y: 2 | 3 } }] | 17, [{ value: 'a' }, any]>
//  =>  | [{ value: 'b' },  { x: { y: 2  } }]
//      | [{ value: 'b' },  { x: { y: 3  } }]
//      | 17
```

## 解题思路

待补充

## 答案

```ts
type DistributeUnions<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  // Already distributed unions should stay the same:
  Expect<Equal<DistributeUnions<1>, 1>>,
  Expect<Equal<DistributeUnions<string>, string>>,
  Expect<Equal<DistributeUnions<1 | 2>, 1 | 2>>,
  Expect<Equal<DistributeUnions<'b' | { type: 'a' } | [1]>, 'b' | { type: 'a' } | [1]>>,
  // tuples:
  Expect<Equal<DistributeUnions<[1 | 2, 3]>, [1, 3] | [2, 3]>>,
  Expect<Equal<DistributeUnions<[1 | 2, 'a' | 'b']>, [1, 'a'] | [1, 'b'] | [2, 'a'] | [2, 'b']>>,
  Expect<
    Equal<
      DistributeUnions<[1 | 2, 'a' | 'b', false | true]>,
      | [1, 'a', false]
      | [1, 'a', true]
      | [1, 'b', false]
      | [1, 'b', true]
      | [2, 'a', false]
      | [2, 'a', true]
      | [2, 'b', false]
      | [2, 'b', true]
    >
  >,
  // objects
  Expect<
    Equal<
      DistributeUnions<{ x: 'a' | 'b', y: 'c' | 'd' }>,
  { x: 'a', y: 'c' } | { x: 'a', y: 'd' } | { x: 'b', y: 'c' } | { x: 'b', y: 'd' }
    >
  >,
  Expect<
    Equal<
      DistributeUnions<{ type: 'a', value: number | string } | { type: 'b', value: boolean }>,
      | { type: 'a', value: string }
      | { type: 'a', value: number }
      | { type: 'b', value: false }
      | { type: 'b', value: true }
    >
  >,
  Expect<
    Equal<
      DistributeUnions<
        | {
          type: 'a'
          option: { kind: 'none' } | { kind: 'some', value: 'x' | 'y' }
        }
        | { type: 'b', msg: string }
      >,
      | { type: 'b', msg: string }
      | { type: 'a', option: { kind: 'none' } }
      | { type: 'a', option: { kind: 'some', value: 'x' } }
      | { type: 'a', option: { kind: 'some', value: 'y' } }
    >
  >,
  // mixed structures:
  Expect<
    Equal<
      DistributeUnions<[false | true, { value: 'a' | 'b' }, { x: { y: 2 | 3 } }]>,
      | [false, { value: 'a' }, { x: { y: 2 } }]
      | [false, { value: 'a' }, { x: { y: 3 } }]
      | [false, { value: 'b' }, { x: { y: 2 } }]
      | [false, { value: 'b' }, { x: { y: 3 } }]
      | [true, { value: 'a' }, { x: { y: 2 } }]
      | [true, { value: 'a' }, { x: { y: 3 } }]
      | [true, { value: 'b' }, { x: { y: 2 } }]
      | [true, { value: 'b' }, { x: { y: 3 } }]
    >
  >,
  Expect<
    Equal<
      DistributeUnions<17 | [10 | { value: 'a' | 'b' }, { x: { y: 2 | 3 } }]>,
      | 17
      | [10, { x: { y: 2 } }]
      | [10, { x: { y: 3 } }]
      | [{ value: 'a' }, { x: { y: 2 } }]
      | [{ value: 'a' }, { x: { y: 3 } }]
      | [{ value: 'b' }, { x: { y: 2 } }]
      | [{ value: 'b' }, { x: { y: 3 } }]
    >
  >,
]
```

## 参考

无

---

---
url: /TypeGymnastics/extreme/Dynamic-Route/index.md
---
# Dynamic Route
## 题目

Given below routes, infer its dynamic params.
| Route                          | Params Type Definition                                                                                     |
|--------------------------------|------------------------------------------------------------------------------------------------------------|
| `/blog/[slug]/page.js`         | `{ slug: string }`                                                                                         |
| `/shop/[...slug]/page.js`      | `{ slug: string[] }`                                                                                       |
| `/shop/[[...slug]]/page.js`    | `{ slug?: string[] }`                                                                                      |
| `/[categoryId]/[itemId]/page.js` | `{ categoryId: string, itemId: string }`                                                                 |
| `/app/[...foo]/[...bar]`       | `never` - It's ambiguous as we cannot decide if `b` on `/app/a/b/c` is belongs to `foo` or `bar`.          |
| `/[[...foo]]/[slug]/[...bar]`  | `never`                                                                                                    |
| `/[first]/[[...foo]]/stub/[...bar]/[last]` | `{ first: string, foo?: string[], bar: string[], last: string }`                               |

## 解题思路

待补充

## 答案

```ts
type DynamicRoute<T extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<DynamicRoute<'/shop'>, {}>>,
  Expect<Equal<DynamicRoute<'/shop/[]'>, {}>>,
  Expect<Equal<DynamicRoute<'/shop/[slug]'>, { slug: string }>>,
  Expect<Equal<DynamicRoute<'/shop/[slug]/'>, { slug: string }>>,
  Expect<
    Equal<DynamicRoute<'/shop/[slug]/[foo]'>, { slug: string, foo: string }>
  >,
  Expect<
    Equal<
      DynamicRoute<'/shop/[slug]/stub/[foo]'>,
      { slug: string, foo: string }
    >
  >,
  Expect<
    Equal<
      DynamicRoute<'/shop/[slug]/stub/[foo]'>,
      { slug: string, foo: string }
    >
  >,
  Expect<
    Equal<
      DynamicRoute<'/shop/[slug]/stub/[...foo]'>,
      { slug: string, foo: string[] }
    >
  >,
  Expect<
    Equal<
      DynamicRoute<'/shop/[slug]/stub/[[...foo]]'>,
      { slug: string, foo?: string[] }
    >
  >,
  Expect<
    Equal<
      DynamicRoute<'/shop/[slug]/stub/[[...foo]]/[]'>,
      { slug: string, foo?: string[] }
    >
  >,
  Expect<
    Equal<
      DynamicRoute<'/shop/[slug]/stub/[[...foo]]/[...]'>,
      { 'slug': string, 'foo'?: string[], '...': string }
    >
  >,
  Expect<
    Equal<
      DynamicRoute<'/shop/[slug]/stub/[[...foo]]/[...]/[]index.html'>,
      { 'slug': string, 'foo'?: string[], '...': string }
    >
  >,
  Expect<
    Equal<
      DynamicRoute<'/shop/[slug]/stub/[[...foo]]/[...]/[...]index.html'>,
      { 'slug': string, 'foo'?: string[], '...': string }
    >
  >,
  Expect<Equal<DynamicRoute<'/[slug]/[[...foo]]/[...bar]'>, never>>,
  Expect<Equal<DynamicRoute<'/[[...foo]]/[slug]/[...bar]'>, never>>,
  Expect<Equal<DynamicRoute<'/[[...foo]]/[...bar]/static'>, never>>,
  Expect<
    Equal<
      DynamicRoute<'[[...foo]]/stub/[...bar]'>,
      { foo?: string[], bar: string[] }
    >
  >,
  Expect<
    Equal<
      DynamicRoute<'[first]/[[...foo]]/stub/[...bar]/[last]'>,
      { first: string, foo?: string[], bar: string[], last: string }
    >
  >,
]
```

## 参考

无

---

---
url: /TypeGymnastics/extreme/Get-Readonly-Keys/index.md
---
# Get Readonly Keys
## 题目

实现泛型`GetReadonlyKeys<T>`，`GetReadonlyKeys<T>`返回由对象 T 所有只读属性的键组成的联合类型。

例如

```ts
interface Todo {
  readonly title: string
  readonly description: string
  completed: boolean
}

type Keys = GetReadonlyKeys<Todo> // expected to be "title" | "description"
```

## 解题思路

待补充

## 答案

```ts
type GetReadonlyKeys<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<'title', GetReadonlyKeys<Todo1>>>,
  Expect<Equal<'title' | 'description', GetReadonlyKeys<Todo2>>>,
]

interface Todo1 {
  readonly title: string
  description: string
  completed: boolean
}

interface Todo2 {
  readonly title: string
  readonly description: string
  completed?: boolean
}
```

## 参考

无

---

---
url: /TypeGymnastics/extreme/Inclusive-Range/index.md
---
# Inclusive Range
## 题目

Recursion depth in type system is one of the limitations of TypeScript, the number is around 45.

*We need to go deeper*. And we could go deeper.

In this challenge, you are given one lower boundary and one higher boundary, by which a range of natural numbers is inclusively sliced. You should develop a technique that enables you to do recursion deeper than the limitation, since both boundary vary from 0 to 200.

Note that when `Lower > Higher`, output an empty tuple.

## 解题思路

待补充

## 答案

```ts
type InclusiveRange<Lower extends number, Higher extends number> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<InclusiveRange<200, 1>, []>>,
  Expect<Equal<InclusiveRange<10, 5>, []>>,
  Expect<Equal<InclusiveRange<5, 5>, [5]>>,
  Expect<Equal<InclusiveRange<0, 10>, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]>>,
  Expect<Equal<InclusiveRange<1, 200>, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200]>>,
  Expect<Equal<InclusiveRange<22, 146>, [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/extreme/Integers-Comparator/index.md
---
# Integers Comparator
## 题目

Implement a type-level integers comparator. We've provided an enum for indicating the comparison result, like this:

* If `a` is greater than `b`, type should be `Comparison.Greater`.
* If `a` and `b` are equal, type should be `Comparison.Equal`.
* If `a` is lower than `b`, type should be `Comparison.Lower`.

**Note that `a` and `b` can be positive integers or negative integers or zero, even one is positive while another one is negative.**

## 解题思路

待补充

## 答案

```ts
enum Comparison {
  Greater,
  Equal,
  Lower,
}

type Comparator<A extends number, B extends number> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Comparator<5, 5>, Comparison.Equal>>,
  Expect<Equal<Comparator<5, 6>, Comparison.Lower>>,
  Expect<Equal<Comparator<5, 8>, Comparison.Lower>>,
  Expect<Equal<Comparator<5, 0>, Comparison.Greater>>,
  Expect<Equal<Comparator<-5, 0>, Comparison.Lower>>,
  Expect<Equal<Comparator<0, 0>, Comparison.Equal>>,
  Expect<Equal<Comparator<0, -5>, Comparison.Greater>>,
  Expect<Equal<Comparator<5, -3>, Comparison.Greater>>,
  Expect<Equal<Comparator<5, -7>, Comparison.Greater>>,
  Expect<Equal<Comparator<-5, -7>, Comparison.Greater>>,
  Expect<Equal<Comparator<-5, -3>, Comparison.Lower>>,
  Expect<Equal<Comparator<-25, -30>, Comparison.Greater>>,
  Expect<Equal<Comparator<15, -23>, Comparison.Greater>>,
  Expect<Equal<Comparator<40, 37>, Comparison.Greater>>,
  Expect<Equal<Comparator<-36, 36>, Comparison.Lower>>,
  Expect<Equal<Comparator<27, 27>, Comparison.Equal>>,
  Expect<Equal<Comparator<-38, -38>, Comparison.Equal>>,

  Expect<Equal<Comparator<1, 100>, Comparison.Lower>>,
  Expect<Equal<Comparator<100, 1>, Comparison.Greater>>,
  Expect<Equal<Comparator<-100, 1>, Comparison.Lower>>,
  Expect<Equal<Comparator<1, -100>, Comparison.Greater>>,
  Expect<Equal<Comparator<-100, -1>, Comparison.Lower>>,
  Expect<Equal<Comparator<-1, -100>, Comparison.Greater>>,

  // Extra tests if you like to challenge yourself!
  Expect<Equal<Comparator<9007199254740992, 9007199254740992>, Comparison.Equal>>,
  Expect<Equal<Comparator<-9007199254740992, -9007199254740992>, Comparison.Equal>>,
  Expect<Equal<Comparator<9007199254740991, 9007199254740992>, Comparison.Lower>>,
  Expect<Equal<Comparator<9007199254740992, 9007199254740991>, Comparison.Greater>>,
  Expect<Equal<Comparator<-9007199254740992, -9007199254740991>, Comparison.Lower>>,
  Expect<Equal<Comparator<-9007199254740991, -9007199254740992>, Comparison.Greater>>,
  Expect<Equal<Comparator<3.1415, 3.1415>, Comparison.Equal>>,
  Expect<Equal<Comparator<3.1415, 3.1414>, Comparison.Greater>>,
  Expect<Equal<Comparator<0, 3.1414>, Comparison.Lower>>,
  Expect<Equal<Comparator<31.415, 3.1415>, Comparison.Greater>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/extreme/JSON-Parser/index.md
---
# JSON Parser
## 题目

You're required to implement a type-level partly parser to parse JSON string into a object literal type.

Requirements:

* `Numbers` and `Unicode escape (\uxxxx)` in JSON can be ignored. You needn't to parse them.

## 解题思路

待补充

## 答案

```ts
type Pure<T> = {
  [P in keyof T]: T[P] extends object ? Pure<T[P]> : T[P]
}

type SetProperty<T, K extends PropertyKey, V> = {
  [P in (keyof T) | K]: P extends K ? V : P extends keyof T ? T[P] : never
}

type Token = any
type ParseResult<T, K extends Token[]> = [T, K]
type Tokenize<T extends string, S extends Token[] = []> = Token[]
type ParseLiteral<T extends Token[]> = ParseResult<any, T>

type Parse<T extends string> = Pure<ParseLiteral<Tokenize<T>>[0]>
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<(
    Parse<`
      {
        "a": "b",
        "b": false,
        "c": [true, false, "hello", {
          "a": "b",
          "b": false
        }],
        "nil": null
      }
    `>
  ), (
    {
      nil: null
      c: [true, false, 'hello', {
        a: 'b'
        b: false
      }]
      b: false
      a: 'b'
    }

  )>>,
  Expect<Equal<Parse<'{}'>, {}>>,

  Expect<Equal<Parse<'[]'>, []>>,

  Expect<Equal<Parse<'[1]'>, never>>,

  Expect<Equal<Parse<'true'>, true>>,

  Expect<Equal<
    Parse<'["Hello", true, false, null]'>,
    ['Hello', true, false, null]
  >>,

  Expect<Equal<
    (
      Parse<`
      {
        "hello\\r\\n\\b\\f": "world"
      }`>
    ), (
      {
        'hello\r\n\b\f': 'world'
      }
    )
  >>,

  Expect<Equal<Parse<'{ 1: "world" }'>, never>>,

  Expect<Equal<Parse<`{ "hello

  world": 123 }`>, never>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/extreme/Multiply/index.md
---
# Multiply
## 题目

**This challenge continues from [476 - Sum](https://tsch.js.org/476), it is recommended that you finish that one first, and modify your code based on it to start this challenge.**

Implement a type `Multiply<A, B>` that multiplies two non-negative integers and returns their product as a string. Numbers can be specified as string, number, or bigint.

For example,

```ts
type T0 = Multiply<2, 3> // '6'
type T1 = Multiply<3, '5'> // '15'
type T2 = Multiply<'4', 10> // '40'
type T3 = Multiply<0, 16> // '0'
type T4 = Multiply<'13', '21'> // '273'
type T5 = Multiply<'43423', 321543n> // '13962361689'
```

## 解题思路

待补充

## 答案

```ts
type Multiply<A extends string | number | bigint, B extends string | number | bigint> = string
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Multiply<2, 3>, '6'>>,
  Expect<Equal<Multiply<3, '5'>, '15'>>,
  Expect<Equal<Multiply<'4', 10>, '40'>>,
  Expect<Equal<Multiply<0, 16>, '0'>>,
  Expect<Equal<Multiply<'13', '21'>, '273'>>,
  Expect<Equal<Multiply<'43423', 321543n>, '13962361689'>>,
  Expect<Equal<Multiply<9999, 1>, '9999'>>,
  Expect<Equal<Multiply<4325234, '39532'>, '170985150488'>>,
  Expect<Equal<Multiply<100_000n, '1'>, '100000'>>,
  Expect<Equal<Multiply<259, 9125385>, '2363474715'>>,
  Expect<Equal<Multiply<9, 99>, '891'>>,
  Expect<Equal<Multiply<315, '100'>, '31500'>>,
  Expect<Equal<Multiply<11n, 13n>, '143'>>,
  Expect<Equal<Multiply<728, 0>, '0'>>,
  Expect<Equal<Multiply<'0', 213>, '0'>>,
  Expect<Equal<Multiply<0, '0'>, '0'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/extreme/Parameter-Intersection/index.md
---
# Parameter Intersection
## 题目

Given two parameter arrays, compute a third tuple representing the type of args required to satisfy both of the original tuples.

Your solution should correctly handle fixed and non-fixed length arrays, optional elements and variadic elements. For example:

```ts
type Result = IntersectParameters<
  [{ a: 0 }, { b: 1 }?, { c: 2 }?, ...{ d: 3 }[]],
  [{ e: 4 }?, { f: 5 }?, ...{ g: 6 }[]]
>

type Expected = [
  {
    a: 0
    e: 4
  },
	{
	  b: 1
	  f: 5
	}?,
	{
	  c: 2
	  g: 6
	}?,
	...{
	  d: 3
	  g: 6
	}[]
]
```

## 解题思路

待补充

## 答案

```ts
type IntersectParameters<
  l extends readonly unknown[],
  r extends readonly unknown[],
> = l & r
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type result1 = IntersectParameters<[], []>
type TwoEmpty = Expect<Equal<[], result1>>

type result2 = IntersectParameters<[], [string, number, ...boolean[]]>
type OneEmpty = Expect<Equal<[string, number, ...boolean[]], result2>>

type result3 = IntersectParameters<['a'], [string, number]>
type LongerParametersPreserved = Expect<Equal<['a', number], result3>>

type result4 = IntersectParameters<[unknown], []>
// Avoids evaluating unknown to {}
type UnknownPreserved = Expect<Equal<[unknown], result4>>

type result5 = IntersectParameters<[('a' | 'b' | 'c')?], [string, 1 | 2 | 3]>
type OneOptional = Expect<Equal<['a' | 'b' | 'c', 1 | 2 | 3], result5>>

type result6 = IntersectParameters<[{ a: 0 }?], [{ b: 1 }?]>
type BothOptional = Expect<Equal<[{ a: 0, b: 1 }?], result6>>

type result7 = IntersectParameters<[{ a: 0 }?], []>
type OptionalAndNotPresent = Expect<Equal<[{ a: 0 }?], result7>>

type result8 = IntersectParameters<{ a: 0 }[], { b: 1 }[]>
type TwoNonFixedLength = Expect<Equal<{ a: 0, b: 1 }[], result8>>

type result9 = IntersectParameters<[{ a: 0 }, { b: 1 }], { c: 2 }[]>
type OneNonFixedLength = Expect<
  Equal<
    [
      {
        a: 0
        c: 2
      },
      {
        b: 1
        c: 2
      },
      ...{
        c: 2
      }[],
    ],
    result9
  >
>

type result10 = IntersectParameters<
  [{ a: 0 }, ...{ b: 1 }[]],
  [{ c: 2 }, { d: 3 }]
>
type OneTrailingRest = Expect<
  Equal<
    [
      {
        a: 0
        c: 2
      },
      {
        b: 1
        d: 3
      },
      ...{
        b: 1
      }[],
    ],
    result10
  >
>

type result11 = IntersectParameters<
  [{ a: 0 }, ...{ b: 1 }[]],
  [{ c: 2 }, { d: 3 }, ...{ e: 4 }[]]
>
type TwoTrailingRest = Expect<
  Equal<
    [
      {
        a: 0
        c: 2
      },
      {
        b: 1
        d: 3
      },
      ...{
        b: 1
        e: 4
      }[],
    ],
    result11
  >
>

type result12 = IntersectParameters<
  [{ a: 0 }, { b: 1 }?, { c: 2 }?, ...{ d: 3 }[]],
  [{ e: 4 }?, { f: 5 }?, ...{ g: 6 }[]]
>
type KitchenSink = Expect<
  Equal<
    [
      {
        a: 0
        e: 4
      },
            {
              b: 1
              f: 5
            }?,
            {
              c: 2
              g: 6
            }?,
            ...{
              d: 3
              g: 6
            }[],
    ],
    result12
  >
>

type result13 = IntersectParameters<['a', 'b'], [string, ...string[]]>
type ExtraVariadicArgsPreserved = Expect<
  Equal<['a', 'b', ...string[]], result13>
>
```

## 参考

无

---

---
url: /TypeGymnastics/extreme/Query-String-Parser/index.md
---
# Query String Parser
## 题目

You're required to implement a type-level parser to parse URL query string into a object literal type.

Some detailed requirements:

* Value of a key in query string can be ignored but still be parsed to `true`. For example, `'key'` is without value, so the parser result is `{ key: true }`.
* Duplicated keys must be merged into one. If there are different values with the same key, values must be merged into a tuple type.
* When a key has only one value, that value can't be wrapped into a tuple type.
* If values with the same key appear more than once, it must be treated as once. For example, `key=value&key=value` must be treated as `key=value` only.

## 解题思路

待补充

## 答案

```ts
type ParseQueryString = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<ParseQueryString<''>, {}>>,
  Expect<Equal<ParseQueryString<'k1'>, { k1: true }>>,
  Expect<Equal<ParseQueryString<'k1&k1'>, { k1: true }>>,
  Expect<Equal<ParseQueryString<'k1&k2'>, { k1: true, k2: true }>>,
  Expect<Equal<ParseQueryString<'k1=v1'>, { k1: 'v1' }>>,
  Expect<Equal<ParseQueryString<'k1=v1&k1=v2'>, { k1: ['v1', 'v2'] }>>,
  Expect<Equal<ParseQueryString<'k1=v1&k2=v2'>, { k1: 'v1', k2: 'v2' }>>,
  Expect<Equal<ParseQueryString<'k1=v1&k2=v2&k1=v2'>, { k1: ['v1', 'v2'], k2: 'v2' }>>,
  Expect<Equal<ParseQueryString<'k1=v1&k2'>, { k1: 'v1', k2: true }>>,
  Expect<Equal<ParseQueryString<'k1=v1&k1=v1'>, { k1: 'v1' }>>,
  Expect<Equal<ParseQueryString<'k1=v1&k1=v2&k1=v1'>, { k1: ['v1', 'v2'] }>>,
  Expect<Equal<ParseQueryString<'k1=v1&k2=v1&k1=v2&k1=v1'>, { k1: ['v1', 'v2'], k2: 'v1' }>>,
  Expect<Equal<ParseQueryString<'k1=v1&k2=v2&k1=v2&k1=v3'>, { k1: ['v1', 'v2', 'v3'], k2: 'v2' }>>,
  Expect<Equal<ParseQueryString<'k1=v1&k1'>, { k1: ['v1', true] }>>,
  Expect<Equal<ParseQueryString<'k1&k1=v1'>, { k1: [true, 'v1'] }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/extreme/Slice/index.md
---
# Slice
## 题目

Implement the JavaScript `Array.slice` function in the type system. `Slice<Arr, Start, End>` takes the three argument. The output should be a subarray of `Arr` from index `Start` to `End`. Indexes with negative numbers should be counted from reversely.

For example

```ts
type Arr = [1, 2, 3, 4, 5]
type Result = Slice<Arr, 2, 4> // expected to be [3, 4]
```

## 解题思路

待补充

## 答案

```ts
type Slice<Arr, Start, End> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type Arr = [1, 2, 3, 4, 5]

type cases = [
  // basic
  Expect<Equal<Slice<Arr, 0, 1>, [1]>>,
  Expect<Equal<Slice<Arr, 0, 0>, []>>,
  Expect<Equal<Slice<Arr, 2, 4>, [3, 4]>>,

  // optional args
  Expect<Equal<Slice<[]>, []>>,
  Expect<Equal<Slice<Arr>, Arr>>,
  Expect<Equal<Slice<Arr, 0>, Arr>>,
  Expect<Equal<Slice<Arr, 2>, [3, 4, 5]>>,

  // negative index
  Expect<Equal<Slice<Arr, 0, -1>, [1, 2, 3, 4]>>,
  Expect<Equal<Slice<Arr, -3, -1>, [3, 4]>>,

  // invalid
  Expect<Equal<Slice<Arr, 10>, []>>,
  Expect<Equal<Slice<Arr, 1, 0>, []>>,
  Expect<Equal<Slice<Arr, 10, 20>, []>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/extreme/Sort/index.md
---
# Sort
## 题目

In this challenge, you are required to sort natural number arrays in either ascend order or descent order.

Ascend order examples:

```ts
Sort<[]> // []
Sort<[1]> // [1]
Sort<[2, 4, 7, 6, 6, 6, 5, 8, 9]> //  [2, 4, 5, 6, 6, 6, 7, 8, 9]
```

The `Sort` type should also accept a boolean type. When it is `true`, the sorted result should be in descent order. Some examples:

```ts
Sort<[3, 2, 1], true> // [3, 2, 1]
Sort<[3, 2, 0, 1, 0, 0, 0], true> // [3, 2, 1, 0, 0, 0, 0]
```

Extra challenges:

1. Support natural numbers with 15+ digits.
2. Support float numbers.

## 解题思路

待补充

## 答案

```ts
type Sort = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Sort<[]>, []>>,
  Expect<Equal<Sort<[1]>, [1]>>,
  Expect<Equal<Sort<[2, 1]>, [1, 2]>>,
  Expect<Equal<Sort<[0, 0, 0]>, [0, 0, 0]>>,
  Expect<Equal<Sort<[1, 2, 3]>, [1, 2, 3]>>,
  Expect<Equal<Sort<[3, 2, 1]>, [1, 2, 3]>>,
  Expect<Equal<Sort<[3, 2, 1, 2]>, [1, 2, 2, 3]>>,
  Expect<Equal<Sort<[3, 2, 0, 1, 0, 0, 0]>, [0, 0, 0, 0, 1, 2, 3]>>,
  Expect<Equal<Sort<[2, 4, 7, 6, 6, 6, 5, 8, 9]>, [2, 4, 5, 6, 6, 6, 7, 8, 9]>>,
  Expect<Equal<Sort<[1, 1, 2, 1, 1, 1, 1, 1, 1]>, [1, 1, 1, 1, 1, 1, 1, 1, 2]>>,
  Expect<Equal<Sort<[], true>, []>>,
  Expect<Equal<Sort<[1], true>, [1]>>,
  Expect<Equal<Sort<[2, 1], true>, [2, 1]>>,
  Expect<Equal<Sort<[0, 0, 0], true>, [0, 0, 0]>>,
  Expect<Equal<Sort<[1, 2, 3], true>, [3, 2, 1]>>,
  Expect<Equal<Sort<[3, 2, 1], true>, [3, 2, 1]>>,
  Expect<Equal<Sort<[3, 2, 1, 2], true>, [3, 2, 2, 1]>>,
  Expect<Equal<Sort<[3, 2, 0, 1, 0, 0, 0], true>, [3, 2, 1, 0, 0, 0, 0]>>,
  Expect<Equal<Sort<[2, 4, 7, 6, 6, 6, 5, 8, 9], true>, [9, 8, 7, 6, 6, 6, 5, 4, 2]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/extreme/Subtract/index.md
---
# Subtract
## 题目

Implement the type Subtraction that is `-` in Javascript by using BuildTuple.

If the minuend is less than the subtrahend, it should be `never`.

It's a simple version.

For example

```ts
Subtract<2, 1> // expect to be 1
Subtract<1, 2> // expect to be never
```

## 解题思路

待补充

## 答案

```ts
// M => minuend, S => subtrahend
type Subtract<M extends number, S extends number> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Subtract<1, 1>, 0>>,
  Expect<Equal<Subtract<2, 1>, 1>>,
  Expect<Equal<Subtract<1, 2>, never>>,
  // @ts-expect-error
  Expect<Equal<Subtract<1000, 999>, 1>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/extreme/Sum/index.md
---
# Sum
## 题目

Implement a type `Sum<A, B>` that summing two non-negative integers and returns the sum as a string. Numbers can be specified as a string, number, or bigint.

For example,

```ts
type T0 = Sum<2, 3> // '5'
type T1 = Sum<'13', '21'> // '34'
type T2 = Sum<'328', 7> // '335'
type T3 = Sum<1_000_000_000_000n, '123'> // '1000000000123'
```

## 解题思路

待补充

## 答案

```ts
type Sum<A extends string | number | bigint, B extends string | number | bigint> = string
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Sum<2, 3>, '5'>>,
  Expect<Equal<Sum<'13', '21'>, '34'>>,
  Expect<Equal<Sum<'328', 7>, '335'>>,
  Expect<Equal<Sum<1_000_000_000_000n, '123'>, '1000000000123'>>,
  Expect<Equal<Sum<9999, 1>, '10000'>>,
  Expect<Equal<Sum<4325234, '39532'>, '4364766'>>,
  Expect<Equal<Sum<728, 0>, '728'>>,
  Expect<Equal<Sum<'0', 213>, '213'>>,
  Expect<Equal<Sum<0, '0'>, '0'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/extreme/Tag/index.md
---
# Tag
## 题目

Despite the structural typing system in TypeScript, it is sometimes convenient to mark some types with tags, and so that these tags do not interfere with the ability to assign values  of these types to each other.

For example, using tags, you can check that some value passes through the calls of the required functions, and in the correct order:

```ts
function doA<T extends string>(x: T) {
  const result = x

  return result as Tag<typeof result, 'A'>
}

function doB<T extends string>(x: T) {
  const result = x

  return result as Tag<typeof result, 'B'>
}

const a = doA('foo')
const b = doB(a)

type Check0 = IsTrue<HasTags<typeof b, ['A', 'B']>>
```

Write a function `Tag<B, T extends string>` that takes a type `B` other than `null` and `undefined` and returns a type labeled with the string literal type `T`.

The labeled types must be mutually assignable with the corresponding original types:

```ts
declare let x: string
declare let y: Tag<string, 'A'>

x = y = x
```

When tagging a type already marked with a tag, a new tag must be added to the end of the list of all tags of the type:

```ts
type T0 = Tag<{ foo: string }, 'A'>
type T1 = Tag<T0, 'B'>

type Check1 = IsTrue<HasExactTags<T1, ['A', 'B']>>
```

Add some functions to check for type tags.

`GetTags<B>` retrieves a list of all tags of a type `B`:

```ts
type T2 = Tag<number, 'C'>

type Check2 = IsTrue<Equal<GetTags<T2>, ['C']>>
```

`HasTag<B, T extends string>` checks if type `B` is tagged with tag `T` (and returns `true` or `false`):

```ts
type T3 = Tag<0 | 1, 'D'>

type Check3 = IsTrue<HasTag<T3, 'D'>>
```

`HasTags<B, T extends readonly string[]>` checks if type `B` is tagged in succession with tags from tuple `T`:

```ts
type T4 = Tag<Tag<Tag<{}, 'A'>, 'B'>, 'C'>

type Check4 = IsTrue<HasTags<T4, ['B', 'C']>>
```

`HasExactTags<B, T extends readonly string[]>` checks if the list of all tags of type `B` is exactly equal to the `T` tuple:

```ts
type T5 = Tag<Tag<unknown, 'A'>, 'B'>

type Check5 = IsTrue<HasExactTags<T5, ['A', 'B']>>
```

Finally, add type `UnTag<B>`, which removes all tags from type `B`:

```ts
type T6 = Tag<{ bar: number }, 'A'>
type T7 = UnTag<T6>

type Check6 = IsFalse<HasTag<T7, 'A'>>
```

## 解题思路

待补充

## 答案

```ts
type GetTags<B> = any

type Tag<B, T extends string> = any

type UnTag<B> = any

type HasTag<B, T extends string> = any
type HasTags<B, T extends readonly string[]> = any
type HasExactTags<B, T extends readonly string[]> = any
```

## 验证

```ts
import type { Equal, Expect, IsTrue } from '@type-challenges/utils'

/**
 * Tests of assignable of tagged variables.
 */
interface I {
  foo: string
}

declare let x0: I
declare let x1: Tag<I, 'a'>
declare let x2: Tag<I, 'b'>
declare let x3: Tag<Tag<I, 'a'>, 'b'>
declare let x4: Tag<Tag<I, 'b'>, 'a'>
declare let x5: Tag<Tag<I, 'c'>, 'a'>
declare let x6: Tag<Tag<I, 'c'>, 'b'>
declare let x7: UnTag<Tag<Tag<I, 'c'>, 'b'>>

x0 = x1 = x0 = x2 = x0 = x3 = x0 = x4 = x0 = x5 = x0 = x6 = x0 = x7 = x0
x1 = x2 = x1 = x3 = x1 = x4 = x1 = x5 = x1 = x6 = x1 = x7 = x1
x2 = x3 = x2 = x4 = x2 = x5 = x2 = x6 = x2 = x7 = x2
x3 = x4 = x3 = x5 = x3 = x6 = x3 = x7 = x3
x4 = x5 = x4 = x6 = x4 = x7 = x4
x5 = x6 = x5 = x7 = x5
x6 = x7 = x6

declare let y0: string
declare let y1: Tag<string, 'a'>
declare let y2: Tag<string, 'b'>
declare let y3: Tag<Tag<string, 'a'>, 'b'>
declare let y4: Tag<Tag<string, 'b'>, 'a'>
declare let y5: Tag<Tag<string, 'c'>, 'a'>
declare let y6: Tag<Tag<string, 'c'>, 'b'>
declare let y7: UnTag<Tag<Tag<string, 'c'>, 'b'>>

y0 = y1 = y0 = y2 = y0 = y3 = y0 = y4 = y0 = y5 = y0 = y6 = y0 = y7 = y0
y1 = y2 = y1 = y3 = y1 = y4 = y1 = y5 = y1 = y6 = y1 = y7 = y1
y2 = y3 = y2 = y4 = y2 = y5 = y2 = y6 = y2 = y7 = y2
y3 = y4 = y3 = y5 = y3 = y6 = y3 = y7 = y3
y4 = y5 = y4 = y6 = y4 = y7 = y4
y5 = y6 = y5 = y7 = y5
y6 = y7 = y6

// @ts-expect-error
x0 = y0
// @ts-expect-error
x1 = y1
// @ts-expect-error
x2 = y2
// @ts-expect-error
x3 = y3
// @ts-expect-error
x4 = y4
// @ts-expect-error
x5 = y5
// @ts-expect-error
x6 = y6
// @ts-expect-error
x7 = y7

declare const UNIQUE_SYMBOL: unique symbol
type US = typeof UNIQUE_SYMBOL

/**
 * Tests of API (Tag, GetTags, Untag, HasTag, HasTags, HasExactTags).
 */
type cases = [
  /**
   * Tag.
   */
  IsTrue<Equal<Tag<null, 'foo'>, null>>,
  IsTrue<Equal<Tag<undefined, 'foo'>, undefined>>,
  IsTrue<Equal<'x', keyof Tag<{ x: 0 }, 'foo'> & string>>,

  /**
   * GetTags.
   */
  IsTrue<Equal<GetTags<null>, []>>,
  IsTrue<Equal<GetTags<any>, []>>,
  IsTrue<Equal<GetTags<undefined>, []>>,
  IsTrue<Equal<GetTags<Tag<any, 'foo'>>, ['foo']>>,
  IsTrue<Equal<GetTags<Tag<null | 1, 'foo'>>, ['foo']>>,
  IsTrue<Equal<GetTags<Tag<0, 'foo'> | 1>, []>>,
  IsTrue<Equal<GetTags<Tag<{}, 'foo'> | Tag<1, 'foo'>>, ['foo']>>,
  IsTrue<Equal<GetTags<Tag<string, 'foo'>>, ['foo']>>,
  IsTrue<Equal<GetTags<Tag<never, 'foo'>>, ['foo']>>,
  IsTrue<Equal<GetTags<Tag<Tag<string, 'foo'>, 'bar'>>, ['foo', 'bar']>>,
  IsTrue<
    Equal<
      GetTags<Tag<Tag<Tag<{}, 'foo'>, 'bar'>, 'baz'>>,
      ['foo', 'bar', 'baz']
    >
  >,

  /**
   * UnTag.
   */
  IsTrue<Equal<UnTag<null>, null>>,
  IsTrue<Equal<UnTag<undefined>, undefined>>,
  IsTrue<Equal<UnTag<Tag<{}, 'foo'>>, {}>>,
  IsTrue<Equal<UnTag<Tag<Tag<{ x: 0 }, 'foo'>, 'bar'>>, { x: 0 }>>,
  IsTrue<Equal<keyof UnTag<Tag<Tag<number, 'foo'>, 'bar'>>, keyof number>>,

  /**
   * HasTag.
   */
  Expect<Equal<HasTag<null, 'foo'>, false>>,
  Expect<Equal<HasTag<undefined, 'foo'>, false>>,
  Expect<Equal<HasTag<Tag<any, 'foo'>, 'foo'>, true>>,
  Expect<Equal<HasTag<Tag<1, 'foo'> | {}, 'foo'>, false>>,
  Expect<Equal<HasTag<Tag<{}, 'foo'>, 'foo'>, true>>,
  Expect<Equal<HasTag<Tag<0, 'foo'> | Tag<1, 'foo'>, 'foo'>, true>>,
  Expect<Equal<HasTag<Tag<0, 'foo'> | Tag<1, 'bar'>, 'foo'>, false>>,
  Expect<Equal<HasTag<Tag<Tag<{}, 'foo'>, 'bar'>, 'foo'>, true>>,
  Expect<Equal<HasTag<Tag<Tag<symbol, 'bar'>, 'foo'>, 'foo'>, true>>,
  Expect<Equal<HasTag<Tag<Tag<{}, 'bar'>, 'baz'>, 'foo'>, false>>,
  Expect<Equal<HasTag<Tag<true, 'foo'>, 'foo'>, true>>,
  Expect<Equal<HasTag<Tag<null, 'foo'>, 'foo'>, false>>,
  Expect<Equal<HasTag<Tag<Tag<undefined, 'foo'>, 'bar'>, 'bar'>, false>>,
  Expect<Equal<HasTag<Tag<Tag<false, 'foo'>, 'bar'>, 'foo'>, true>>,
  Expect<Equal<HasTag<Tag<Tag<never, 'bar'>, 'foo'>, 'foo'>, true>>,
  Expect<Equal<HasTag<Tag<{}, 'foo'>, 'foo'>, true>>,
  Expect<Equal<HasTag<Tag<{}, 'foo'>, 'bar'>, false>>,
  Expect<Equal<HasTag<{}, 'foo'>, false>>,

  /**
   * HasTags.
   */
  Expect<Equal<HasTags<null, ['foo']>, false>>,
  Expect<Equal<HasTags<undefined, ['foo']>, false>>,
  Expect<Equal<HasTags<Tag<any, 'bar'>, ['foo']>, false>>,
  Expect<Equal<HasTags<Tag<{}, 'bar'>, ['foo']>, false>>,
  Expect<Equal<HasTags<Tag<{}, 'foo'>, ['foo']>, true>>,
  Expect<Equal<HasTags<Tag<any, 'foo'>, ['foo']>, true>>,
  Expect<Equal<HasTags<Tag<{} | undefined, 'foo'>, ['foo']>, true>>,
  Expect<Equal<HasTags<Tag<Tag<string, 'foo'>, 'bar'>, ['foo', 'bar']>, true>>,
  Expect<Equal<HasTags<Tag<Tag<3n, 'foo'>, 'bar'>, ['foo', 'bar']>, true>>,
  Expect<Equal<HasTags<Tag<Tag<{}, 'bar'>, 'foo'>, ['foo', 'bar']>, false>>,
  Expect<Equal<HasTags<Tag<Tag<Tag<{}, 'baz'>, 'foo'>, 'bar'>, ['foo', 'bar']>, true>>,
  Expect<Equal<HasTags<Tag<Tag<Tag<symbol, 'baz'>, 'foo'>, 'bar'>, ['foo', 'bar']>, true>>,
  Expect<Equal<HasTags<Tag<Tag<Tag<{}, 'foo'>, 'bar'>, 'baz'>, ['foo', 'bar']>, true>>,
  Expect<Equal<HasTags<Tag<Tag<Tag<0, 'foo'>, 'bar'>, 'baz'>, ['foo', 'bar']>, true>>,
  Expect<Equal<HasTags<Tag<Tag<Tag<{}, 'foo'>, 'baz'>, 'bar'>, ['foo', 'bar']>, false>>,
  Expect<Equal<HasTags<Tag<Tag<unknown, 'foo'>, 'bar'>, ['foo', 'bar']>, true>>,

  /**
   * HasExactTags.
   */
  Expect<Equal<HasExactTags<0, []>, true>>,
  Expect<Equal<HasExactTags<null, []>, true>>,
  Expect<Equal<HasExactTags<undefined, []>, true>>,
  Expect<Equal<HasExactTags<Tag<number, 'foo'>, ['foo']>, true>>,
  Expect<Equal<HasExactTags<Tag<any, 'foo'>, ['bar']>, false>>,
  Expect<Equal<HasExactTags<Tag<Tag<any, 'foo'>, 'bar'>, ['foo', 'bar']>, true>>,
  Expect<Equal<HasExactTags<Tag<'', 'foo'>, ['foo']>, true>>,
  Expect<Equal<HasExactTags<Tag<US, 'foo'>, ['foo']>, true>>,
  Expect<Equal<HasExactTags<Tag<{}, 'foo'>, ['bar']>, false>>,
  Expect<Equal<HasExactTags<Tag<Tag<Tag<{}, 'foo'>, 'bar'>, 'baz'>, ['foo', 'bar']>, false>>,
  Expect<Equal<HasExactTags<Tag<Tag<Tag<{}, 'foo'>, 'bar'>, 'baz'>, ['foo', 'bar', 'baz']>, true>>,
  Expect<Equal<HasExactTags<Tag<Tag<void, 'foo'>, 'bar'>, ['foo', 'bar']>, true>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Assign/index.md
---
# Assign
## 题目

You have a target object and a source array of objects. You need to copy property from source to target, if it has the same property as the source, you should always keep the source property, and drop the target property. (Inspired by the `Object.assign` API)

### example

```ts
interface Target {
  a: 'a'
}

interface Origin1 {
  b: 'b'
}

// type Result = Assign<Target, [Origin1]>
interface Result {
  a: 'a'
  b: 'b'
}
```

```ts
interface Target {
  a: 'a'
  d: {
    hi: 'hi'
  }
}

interface Origin1 {
  a: 'a1'
  b: 'b'
}

interface Origin2 {
  b: 'b2'
  c: 'c'
}

interface Answer {
  a: 'a1'
  b: 'b2'
  c: 'c'
  d: {
    hi: 'hi'
  }
}
```

## 解题思路

待补充

## 答案

```ts
type Assign<T extends Record<string, unknown>, U> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

// case1
interface Case1Target {}

interface Case1Origin1 {
  a: 'a'
}

interface Case1Origin2 {
  b: 'b'
}

interface Case1Origin3 {
  c: 'c'
}

interface Case1Answer {
  a: 'a'
  b: 'b'
  c: 'c'
}

// case2
interface Case2Target {
  a: [1, 2, 3]
}

interface Case2Origin1 {
  a: {
    a1: 'a1'
  }
}

interface Case2Origin2 {
  b: [2, 3, 3]
}

interface Case2Answer {
  a: {
    a1: 'a1'
  }
  b: [2, 3, 3]
}

// case3

interface Case3Target {
  a: 1
  b: ['b']
}

interface Case3Origin1 {
  a: 2
  b: {
    b: 'b'
  }
  c: 'c1'
}

interface Case3Origin2 {
  a: 3
  c: 'c2'
  d: true
}

interface Case3Answer {
  a: 3
  b: {
    b: 'b'
  }
  c: 'c2'
  d: true
}

// case 4
interface Case4Target {
  a: 1
  b: ['b']
}

interface Case4Answer {
  a: 1
  b: ['b']
}

type cases = [
  Expect<Equal<Assign<Case1Target, [Case1Origin1, Case1Origin2, Case1Origin3]>, Case1Answer>>,
  Expect<Equal<Assign<Case2Target, [Case2Origin1, Case2Origin2]>, Case2Answer>>,
  Expect<Equal<Assign<Case3Target, [Case3Origin1, Case3Origin2]>, Case3Answer>>,
  Expect<Equal<Assign<Case4Target, ['', 0]>, Case4Answer>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Binary-Addition/index.md
---
# Binary Addition
## 题目

Implement `BinaryAdd` to add two binary numbers together. The numbers should not be translated out of binary at any point.

Note the two inputs will always have the same length.

## 解题思路

待补充

## 答案

```ts
type Bit = 1 | 0

type BinaryAdd<A extends Bit[], B extends Bit[]> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<
    BinaryAdd<[1], [1]>,
    [1, 0]
  >>,
  Expect<Equal<
    BinaryAdd<[0], [1]>,
    [1]
  >>,
  Expect<Equal<
    BinaryAdd<[1, 1, 0], [0, 0, 1]>,
    [1, 1, 1]
  >>,
  Expect<Equal<
    BinaryAdd<[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]>,
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]
  >>,
  Expect<Equal<
    BinaryAdd<[1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 0, 0, 1, 1, 0, 0]>,
    [1, 0, 0, 1, 1, 1, 0, 1, 0]
  >>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Binary-to-Decimal/index.md
---
# Binary to Decimal
## 题目

Implement `BinaryToDecimal<S>` which takes an exact string type `S` consisting 0 and 1 and returns an exact number type corresponding with `S` when `S` is regarded as a binary.
You can assume that the length of `S` is equal to or less than 8 and `S` is not empty.

```ts
type Res1 = BinaryToDecimal<'10'> // expected to be 2
type Res2 = BinaryToDecimal<'0011'> // expected to be 3
```

## 解题思路

待补充

## 答案

```ts
type BinaryToDecimal<S extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<BinaryToDecimal<'10'>, 2>>,
  Expect<Equal<BinaryToDecimal<'0011'>, 3>>,
  Expect<Equal<BinaryToDecimal<'00000000'>, 0>>,
  Expect<Equal<BinaryToDecimal<'11111111'>, 255>>,
  Expect<Equal<BinaryToDecimal<'10101010'>, 170>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/BitwiseXOR/index.md
---
# BitwiseXOR
## 题目

Implement `BitwiseXOR<S1,S2>` which takes two binary string literal type and returns a binary string that represents the bitwise XOR of S1 and S2

For example:

```typescript
BitwiseXOR<'0', '1'> // expect '1'
BitwiseXOR<'1', '1'> // expect '0'
BitwiseXOR<'10', '1'> // expect '11'
```

## 解题思路

待补充

## 答案

```ts
type BitwiseXOR<S1 extends string, S2 extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<BitwiseXOR<'0', '1'>, '1'>>,
  Expect<Equal<BitwiseXOR<'1', '1'>, '0'>>,
  Expect<Equal<BitwiseXOR<'10', '1'>, '11'>>,
  Expect<Equal<BitwiseXOR<'110', '1'>, '111'>>,
  Expect<Equal<BitwiseXOR<'101', '11'>, '110'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/C-printf-Parser/index.md
---
# C-printf Parser
## 题目

There is a function in C language: `printf`. This function allows us to print something with formatting. Like this:

```c
printf("The result is %d.", 42);
```

This challenge requires you to parse the input string and extract the format placeholders like `%d` and `%f`. For example, if the input string is `"The result is %d."`, the parsed result is a tuple `['dec']`.

Here is the mapping:

```typescript
interface ControlsMap {
  c: 'char'
  s: 'string'
  d: 'dec'
  o: 'oct'
  h: 'hex'
  f: 'float'
  p: 'pointer'
}
```

## 解题思路

待补充

## 答案

```ts
interface ControlsMap {
  c: 'char'
  s: 'string'
  d: 'dec'
  o: 'oct'
  h: 'hex'
  f: 'float'
  p: 'pointer'
}

type ParsePrintFormat = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<ParsePrintFormat<''>, []>>,
  Expect<Equal<ParsePrintFormat<'Any string.'>, []>>,
  Expect<Equal<ParsePrintFormat<'The result is %d.'>, ['dec']>>,
  Expect<Equal<ParsePrintFormat<'The result is %%d.'>, []>>,
  Expect<Equal<ParsePrintFormat<'The result is %%%d.'>, ['dec']>>,
  Expect<Equal<ParsePrintFormat<'The result is %f.'>, ['float']>>,
  Expect<Equal<ParsePrintFormat<'The result is %h.'>, ['hex']>>,
  Expect<Equal<ParsePrintFormat<'The result is %q.'>, []>>,
  Expect<Equal<ParsePrintFormat<'Hello %s: score is %d.'>, ['string', 'dec']>>,
  Expect<Equal<ParsePrintFormat<'The result is %'>, []>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/CamelCase/index.md
---
# CamelCase
## 题目

实现 `CamelCase<T>` ，将 `snake_case` 类型的表示的字符串转换为 `camelCase` 的表示方式。

例如

```ts
type camelCase1 = CamelCase<'hello_world_with_types'> // 预期为 'helloWorldWithTypes'
type camelCase2 = CamelCase<'HELLO_WORLD_WITH_TYPES'> // 期望与前一个相同
```

## 解题思路

待补充

## 答案

```ts
type CamelCase<S extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<CamelCase<'foobar'>, 'foobar'>>,
  Expect<Equal<CamelCase<'FOOBAR'>, 'foobar'>>,
  Expect<Equal<CamelCase<'foo_bar'>, 'fooBar'>>,
  Expect<Equal<CamelCase<'foo__bar'>, 'foo_Bar'>>,
  Expect<Equal<CamelCase<'foo_$bar'>, 'foo_$bar'>>,
  Expect<Equal<CamelCase<'foo_bar_'>, 'fooBar_'>>,
  Expect<Equal<CamelCase<'foo_bar__'>, 'fooBar__'>>,
  Expect<Equal<CamelCase<'foo_bar_$'>, 'fooBar_$'>>,
  Expect<Equal<CamelCase<'foo_bar_hello_world'>, 'fooBarHelloWorld'>>,
  Expect<Equal<CamelCase<'HELLO_WORLD_WITH_TYPES'>, 'helloWorldWithTypes'>>,
  Expect<Equal<CamelCase<'-'>, '-'>>,
  Expect<Equal<CamelCase<''>, ''>>,
  Expect<Equal<CamelCase<'😎'>, '😎'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Camelize/index.md
---
# Camelize
## 题目

实现 Camelize 类型: 将对象属性名从 蛇形命名(下划线命名) 转换为 小驼峰命名

```ts
Camelize<{
  some_prop: string
  prop: { another_prop: string }
  array: [{ snake_case: string }]
}>

// expected to be
// {
//   someProp: string,
//   prop: { anotherProp: string },
//   array: [{ snakeCase: string }]
// }
```

## 解题思路

待补充

## 答案

```ts
type Camelize<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<
    Camelize<{
      some_prop: string
      prop: { another_prop: string }
      array: [
        { snake_case: string },
        { another_element: { yet_another_prop: string } },
        { yet_another_element: string },
      ]
    }>,
    {
      someProp: string
      prop: { anotherProp: string }
      array: [
        { snakeCase: string },
        { anotherElement: { yetAnotherProp: string } },
        { yetAnotherElement: string },
      ]
    }
  >>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Capitalize-Nest-Object-Keys/index.md
---
# Capitalize Nest Object Keys
## 题目

Capitalize the key of the object, and if the value is an array, iterate through the objects in the array.

## 解题思路

待补充

## 答案

```ts
type CapitalizeNestObjectKeys<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface foo {
  foo: string
  bars: [{ foo: string }]
}

interface Foo {
  Foo: string
  Bars: [{
    Foo: string
  }]
}

type cases = [
  Expect<Equal<Foo, CapitalizeNestObjectKeys<foo>>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Capitalize-Words/index.md
---
# Capitalize Words
## 题目

实现`CapitalizeWords<T>`，它将**字符串的每个单词**的第一个字母转换为大写，其余部分保持原样。

例如

```ts
type capitalized = CapitalizeWords<'hello world, my friends'> // 预期为 'Hello World, My Friends'
```

## 解题思路

待补充

## 答案

```ts
type CapitalizeWords<S extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<CapitalizeWords<'foobar'>, 'Foobar'>>,
  Expect<Equal<CapitalizeWords<'FOOBAR'>, 'FOOBAR'>>,
  Expect<Equal<CapitalizeWords<'foo bar'>, 'Foo Bar'>>,
  Expect<Equal<CapitalizeWords<'foo bar hello world'>, 'Foo Bar Hello World'>>,
  Expect<Equal<CapitalizeWords<'foo bar.hello,world'>, 'Foo Bar.Hello,World'>>,
  Expect<Equal<CapitalizeWords<'aa!bb@cc#dd$ee%ff^gg&hh*ii(jj)kk_ll+mm{nn}oo|pp🤣qq'>, 'Aa!Bb@Cc#Dd$Ee%Ff^Gg&Hh*Ii(Jj)Kk_Ll+Mm{Nn}Oo|Pp🤣Qq'>>,
  Expect<Equal<CapitalizeWords<''>, ''>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/ClassPublicKeys/index.md
---
# ClassPublicKeys
## 题目

Implement the generic `ClassPublicKeys<T>` which returns all public keys of a class.

For example:

```ts
class A {
  public str: string
  protected num: number
  private bool: boolean
  getNum() {
    return Math.random()
  }
}

type publicKeys = ClassPublicKeys<A> // 'str' | 'getNum'
```

## 解题思路

待补充

## 答案

```ts
type ClassPublicKeys = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

class A {
  public str: string
  protected num: number
  private bool: boolean
  constructor() {
    this.str = 'naive'
    this.num = 19260917
    this.bool = true
  }

  getNum() {
    return Math.random()
  }
}

type cases = [
  Expect<Equal<ClassPublicKeys<A>, 'str' | 'getNum'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Currying-1/index.md
---
# Currying 1
## 题目

> 在此挑战中建议使用TypeScript 4.0

[柯里化](https://en.wikipedia.org/wiki/Currying) 是一种将带有多个参数的函数转换为每个带有一个参数的函数序列的技术。

例如：

```ts
const add = (a: number, b: number) => a + b
const three = add(1, 2)

const curriedAdd = Currying(add)
const five = curriedAdd(2)(3)
```

传递给 `Currying` 的函数可能有多个参数，您需要正确输入它的类型。

在此挑战中，柯里化后的函数每次仅接受一个参数。接受完所有参数后，它应返回其结果。

## 解题思路

待补充

## 答案

```ts
declare function Currying(fn: any): any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

const curried1 = Currying((a: string, b: number, c: boolean) => true)
const curried2 = Currying((a: string, b: number, c: boolean, d: boolean, e: boolean, f: string, g: boolean) => true)
const curried3 = Currying(() => true)

type cases = [
  Expect<Equal<
    typeof curried1,
    (a: string) => (b: number) => (c: boolean) => true
  >>,
  Expect<Equal<
    typeof curried2,
    (a: string) => (b: number) => (c: boolean) => (d: boolean) => (e: boolean) => (f: string) => (g: boolean) => true
  >>,
  Expect<Equal<typeof curried3, () => true>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Deep-object-to-unique/index.md
---
# Deep object to unique
## 题目

TypeScript has structural type system, but sometimes you want a function to accept only some previously well-defined unique objects (as in the nominal type system), and not any objects that have the required fields.

Create a type that takes an object and makes it and all deeply nested objects in it unique, while preserving the string and numeric keys of all objects, and the values of all properties on these keys.

The original type and the resulting unique type must be mutually assignable, but not identical.

For example,

```ts
import { Equal } from '@type-challenges/utils'

interface Foo { foo: 2, bar: { 0: 1 }, baz: { 0: 1 } }

type UniqFoo = DeepObjectToUniq<Foo>

declare let foo: Foo
declare let uniqFoo: UniqFoo

uniqFoo = foo // ok
foo = uniqFoo // ok

type T0 = Equal<UniqFoo, Foo> // false
type T1 = UniqFoo['foo'] // 2
type T2 = Equal<UniqFoo['bar'], UniqFoo['baz']> // false
type T3 = UniqFoo['bar'][0] // 1
type T4 = Equal<keyof Foo & string, keyof UniqFoo & string> // true
```

## 解题思路

待补充

## 答案

```ts
type DeepObjectToUniq<O extends object> = any
```

## 验证

```ts
import type { Equal, IsFalse, IsTrue } from '@type-challenges/utils'

interface Quz { quz: 4 }

interface Foo { foo: 2, baz: Quz, bar: Quz }
interface Bar { foo: 2, baz: Quz, bar: Quz & { quzz?: 0 } }

type UniqQuz = DeepObjectToUniq<Quz>
type UniqFoo = DeepObjectToUniq<Foo>
type UniqBar = DeepObjectToUniq<Bar>

declare let foo: Foo
declare let uniqFoo: UniqFoo

uniqFoo = foo
foo = uniqFoo

type cases = [
  IsFalse<Equal<UniqQuz, Quz>>,
  IsFalse<Equal<UniqFoo, Foo>>,
  IsTrue<Equal<UniqFoo['foo'], Foo['foo']>>,
  IsTrue<Equal<UniqFoo['bar']['quz'], Foo['bar']['quz']>>,
  IsFalse<Equal<UniqQuz, UniqFoo['baz']>>,
  IsFalse<Equal<UniqFoo['bar'], UniqFoo['baz']>>,
  IsFalse<Equal<UniqBar['baz'], UniqFoo['baz']>>,
  IsTrue<Equal<keyof UniqBar['baz'], keyof UniqFoo['baz']>>,
  IsTrue<Equal<keyof Foo, keyof UniqFoo & string>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/DeepPick/index.md
---
# DeepPick
## 题目

Implement a type DeepPick, that extends Utility types `Pick`.
A type takes two arguments.

For example:

```ts
interface obj {
  name: 'hoge'
  age: 20
  friend: {
    name: 'fuga'
    age: 30
    family: {
      name: 'baz'
      age: 1
    }
  }
}

type T1 = DeepPick<obj, 'name'> // { name : 'hoge' }
type T2 = DeepPick<obj, 'name' | 'friend.name'> // { name : 'hoge' } & { friend: { name: 'fuga' }}
type T3 = DeepPick<obj, 'name' | 'friend.name' | 'friend.family.name'> // { name : 'hoge' } &  { friend: { name: 'fuga' }} & { friend: { family: { name: 'baz' }}}
```

## 解题思路

待补充

## 答案

```ts
type DeepPick = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface Obj {
  a: number
  b: string
  c: boolean
  obj: {
    d: number
    e: string
    f: boolean
    obj2: {
      g: number
      h: string
      i: boolean
    }
  }
  obj3: {
    j: number
    k: string
    l: boolean
  }
}

type cases = [
  Expect<Equal<DeepPick<Obj, ''>, unknown>>,
  Expect<Equal<DeepPick<Obj, 'a'>, { a: number }>>,
  Expect<Equal<DeepPick<Obj, 'a' | ''>, { a: number } & unknown>>,
  Expect<Equal<DeepPick<Obj, 'a' | 'obj.e'>, { a: number } & { obj: { e: string } }>>,
  Expect<Equal<DeepPick<Obj, 'a' | 'obj.e' | 'obj.obj2.i'>, { a: number } & { obj: { e: string } } & { obj: { obj2: { i: boolean } } }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Drop-String/index.md
---
# Drop String
## 题目

Drop the specified chars from a string.

For example:

```ts
type Butterfly = DropString<'foobar!', 'fb'> // 'ooar!'
```

## 解题思路

待补充

## 答案

```ts
type DropString<S, R> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<DropString<'butter fly!', ''>, 'butter fly!'>>,
  Expect<Equal<DropString<'butter fly!', ' '>, 'butterfly!'>>,
  Expect<Equal<DropString<'butter fly!', 'but'>, 'er fly!'>>,
  Expect<Equal<DropString<' b u t t e r f l y ! ', 'but'>, '     e r f l y ! '>>,
  Expect<Equal<DropString<'    butter fly!        ', ' '>, 'butterfly!'>>,
  Expect<Equal<DropString<' b u t t e r f l y ! ', ' '>, 'butterfly!'>>,
  Expect<Equal<DropString<' b u t t e r f l y ! ', 'but'>, '     e r f l y ! '>>,
  Expect<Equal<DropString<' b u t t e r f l y ! ', 'tub'>, '     e r f l y ! '>>,
  Expect<Equal<DropString<' b u t t e r f l y ! ', 'b'>, '  u t t e r f l y ! '>>,
  Expect<Equal<DropString<' b u t t e r f l y ! ', 't'>, ' b u   e r f l y ! '>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/FizzBuzz/index.md
---
# FizzBuzz
## 题目

The FizzBuzz problem is a classic test given in coding interviews. The task is simple:

Print integers 1 to N, except:

* Print "Fizz" if an integer is divisible by 3;
* Print "Buzz" if an integer is divisible by 5;
* Print "FizzBuzz" if an integer is divisible by both 3 and 5.

For example, for N = 20, the output should be:
`1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16, 17, Fizz, 19, Buzz`

In the challenge below, we will want to generate this as an array of string literals.

For large values of N, you will need to ensure that any types generated do so efficiently (e.g. by
correctly using the tail-call optimisation for recursion).

## 解题思路

待补充

## 答案

```ts
type FizzBuzz<N extends number> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<FizzBuzz<1>, ['1']>>,
  Expect<Equal<FizzBuzz<5>, ['1', '2', 'Fizz', '4', 'Buzz']>>,
  Expect<Equal<FizzBuzz<20>, [
    '1',
    '2',
    'Fizz',
    '4',
    'Buzz',
    'Fizz',
    '7',
    '8',
    'Fizz',
    'Buzz',
    '11',
    'Fizz',
    '13',
    '14',
    'FizzBuzz',
    '16',
    '17',
    'Fizz',
    '19',
    'Buzz',
  ]>>,
  Expect<Equal<FizzBuzz<100>, [
    '1',
    '2',
    'Fizz',
    '4',
    'Buzz',
    'Fizz',
    '7',
    '8',
    'Fizz',
    'Buzz',
    '11',
    'Fizz',
    '13',
    '14',
    'FizzBuzz',
    '16',
    '17',
    'Fizz',
    '19',
    'Buzz',
    'Fizz',
    '22',
    '23',
    'Fizz',
    'Buzz',
    '26',
    'Fizz',
    '28',
    '29',
    'FizzBuzz',
    '31',
    '32',
    'Fizz',
    '34',
    'Buzz',
    'Fizz',
    '37',
    '38',
    'Fizz',
    'Buzz',
    '41',
    'Fizz',
    '43',
    '44',
    'FizzBuzz',
    '46',
    '47',
    'Fizz',
    '49',
    'Buzz',
    'Fizz',
    '52',
    '53',
    'Fizz',
    'Buzz',
    '56',
    'Fizz',
    '58',
    '59',
    'FizzBuzz',
    '61',
    '62',
    'Fizz',
    '64',
    'Buzz',
    'Fizz',
    '67',
    '68',
    'Fizz',
    'Buzz',
    '71',
    'Fizz',
    '73',
    '74',
    'FizzBuzz',
    '76',
    '77',
    'Fizz',
    '79',
    'Buzz',
    'Fizz',
    '82',
    '83',
    'Fizz',
    'Buzz',
    '86',
    'Fizz',
    '88',
    '89',
    'FizzBuzz',
    '91',
    '92',
    'Fizz',
    '94',
    'Buzz',
    'Fizz',
    '97',
    '98',
    'Fizz',
    'Buzz',
  ]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Get-Optional/index.md
---
# Get Optional
## 题目

实现高级工具类型 `GetOptional<T>`，该类型保留所有可选属性

例如

```ts
type I = GetOptional<{ foo: number, bar?: string }> // expected to be { bar?: string }
```

## 解题思路

待补充

## 答案

```ts
type GetOptional<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<GetOptional<{ foo: number, bar?: string }>, { bar?: string }>>,
  Expect<Equal<GetOptional<{ foo: undefined, bar?: undefined }>, { bar?: undefined }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Get-Required/index.md
---
# Get Required
## 题目

实现高级工具类型 `GetRequired<T>`，该类型保留所有必需的属性

例如

```ts
type I = GetRequired<{ foo: number, bar?: string }> // expected to be { foo: number }
```

## 解题思路

待补充

## 答案

```ts
type GetRequired<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<GetRequired<{ foo: number, bar?: string }>, { foo: number }>>,
  Expect<Equal<GetRequired<{ foo: undefined, bar?: undefined }>, { foo: undefined }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/InorderTraversal/index.md
---
# InorderTraversal
## 题目

Implement the type version of binary tree inorder traversal.

For example:

```typescript
const tree1 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: {
      val: 3,
      left: null,
      right: null,
    },
    right: null,
  },
} as const

type A = InorderTraversal<typeof tree1> // [1, 3, 2]
```

## 解题思路

待补充

## 答案

```ts
interface TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
}
type InorderTraversal<T extends TreeNode | null> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

const tree1 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: {
      val: 3,
      left: null,
      right: null,
    },
    right: null,
  },
} as const

const tree2 = {
  val: 1,
  left: null,
  right: null,
} as const

const tree3 = {
  val: 1,
  left: {
    val: 2,
    left: null,
    right: null,
  },
  right: null,
} as const

const tree4 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: null,
    right: null,
  },
} as const

type cases = [
  Expect<Equal<InorderTraversal<null>, []>>,
  Expect<Equal<InorderTraversal<typeof tree1>, [1, 3, 2]>>,
  Expect<Equal<InorderTraversal<typeof tree2>, [1]>>,
  Expect<Equal<InorderTraversal<typeof tree3>, [2, 1]>>,
  Expect<Equal<InorderTraversal<typeof tree4>, [1, 2]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Intersection/index.md
---
# Intersection
## 题目

Implement the type version of Lodash.intersection with a little difference. `Intersection<T>` takes an Array T containing several arrays or any type element including the union type, and returns a new union containing all intersection elements.

```ts
type Res = Intersection<[[1, 2], [2, 3], [2, 2]]> // expected to be 2
type Res1 = Intersection<[[1, 2, 3], [2, 3, 4], [2, 2, 3]]> // expected to be 2 | 3
type Res2 = Intersection<[[1, 2], [3, 4], [5, 6]]> // expected to be never
type Res3 = Intersection<[[1, 2, 3], [2, 3, 4], 3]> // expected to be 3
type Res4 = Intersection<[[1, 2, 3], 2 | 3 | 4, 2 | 3]> // expected to be 2 | 3
type Res5 = Intersection<[[1, 2, 3], 2, 3]> // expected to be never
```

## 解题思路

待补充

## 答案

```ts
type Intersection<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Intersection<[[1, 2], [2, 3], [2, 2]]>, 2>>,
  Expect<Equal<Intersection<[[1, 2, 3], [2, 3, 4], [2, 2, 3]]>, 2 | 3>>,
  Expect<Equal<Intersection<[[1, 2], [3, 4], [5, 6]]>, never>>,
  Expect<Equal<Intersection<[[1, 2, 3], [2, 3, 4], 3]>, 3>>,
  Expect<Equal<Intersection<[[1, 2, 3], 2 | 3 | 4, 2 | 3]>, 2 | 3>>,
  Expect<Equal<Intersection<[[1, 2, 3], 2, 3]>, never>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/IsAny/index.md
---
# IsAny
## 题目

Sometimes it's useful to detect if you have a value with `any` type. This is especially helpful while working with third-party Typescript modules, which can export `any` values in the module API. It's also good to know about `any` when you're suppressing implicitAny checks.

So, let's write a utility type `IsAny<T>`, which takes input type `T`. If `T` is `any`, return `true`, otherwise, return `false`.

## 解题思路

待补充

## 答案

```ts
type IsAny<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<IsAny<any>, true>>,

  Expect<Equal<IsAny<undefined>, false>>,
  Expect<Equal<IsAny<unknown>, false>>,
  Expect<Equal<IsAny<never>, false>>,
  Expect<Equal<IsAny<string>, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/IsNegativeNumber/index.md
---
# IsNegativeNumber
## 题目

Sometimes when working with numeric literals, we need to rule out (or enforce) that the provided number is a positive integer.

To do that, we first need a way to tell if the number is negative.

Write a type-level function `IsNegativeNumber` that accepts a number `N` and returns:

* `true` if `N` is negative
* `false` if `N` is positive
* `false` if `N` is `0`,
* `never` if `N` is `number`
* `never` if `N` is a union

## 解题思路

待补充

## 答案

```ts
type IsNegativeNumber<T extends number> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<IsNegativeNumber<0>, false>>,
  Expect<Equal<IsNegativeNumber<number>, never>>,
  Expect<Equal<IsNegativeNumber<-1 | -2>, never>>,
  Expect<Equal<IsNegativeNumber<-1>, true>>,
  Expect<Equal<IsNegativeNumber<-1.9>, true>>,
  Expect<Equal<IsNegativeNumber<-100_000_000>, true>>,
  Expect<Equal<IsNegativeNumber<1>, false>>,
  Expect<Equal<IsNegativeNumber<1.9>, false>>,
  Expect<Equal<IsNegativeNumber<100_000_000>, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/IsPalindrome/index.md
---
# IsPalindrome
## 题目

Implement type `IsPalindrome<T>` to check whether  a string or number is palindrome.

For example:

```typescript
IsPalindrome<'abc'> // false
IsPalindrome<121> // true
```

## 解题思路

待补充

## 答案

```ts
type IsPalindrome<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<IsPalindrome<'abc'>, false>>,
  Expect<Equal<IsPalindrome<'b'>, true>>,
  Expect<Equal<IsPalindrome<'abca'>, false>>,
  Expect<Equal<IsPalindrome<'abba'>, true>>,
  Expect<Equal<IsPalindrome<'abcba'>, true>>,
  Expect<Equal<IsPalindrome<121>, true>>,
  Expect<Equal<IsPalindrome<2332>, true>>,
  Expect<Equal<IsPalindrome<19260817>, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/IsRequiredKey/index.md
---
# IsRequiredKey
## 题目

Implement a generic `IsRequiredKey<T, K>`  that return whether `K` are required keys of `T` .

For example

```typescript
type A = IsRequiredKey<{ a: number, b?: string }, 'a'> // true
type B = IsRequiredKey<{ a: number, b?: string }, 'b'> // false
type C = IsRequiredKey<{ a: number, b?: string }, 'b' | 'a'> // false
```

## 解题思路

待补充

## 答案

```ts
type IsRequiredKey<T, K extends keyof T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<IsRequiredKey<{ a: number, b?: string }, 'a'>, true>>,
  Expect<Equal<IsRequiredKey<{ a: undefined, b: string }, 'a'>, true>>,
  Expect<Equal<IsRequiredKey<{ a: number, b?: string }, 'b'>, false>>,
  Expect<Equal<IsRequiredKey<{ a: number, b?: string }, 'b' | 'a'>, false>>,
  Expect<Equal<IsRequiredKey<{ a: undefined, b: undefined }, 'b' | 'a'>, true>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Length-of-String-2/index.md
---
# Length of String 2
## 题目

Implement a type `LengthOfString<S>` that calculates the length of the template string (as in [298 - Length of String](https://tsch.js.org/298)):

```ts
type T0 = LengthOfString<'foo'> // 3
```

The type must support strings several hundred characters long (the usual recursive calculation of the string length is limited by the depth of recursive function calls in TS, that is, it supports strings up to about 45 characters long).

## 解题思路

待补充

## 答案

```ts
type LengthOfString<S extends string> = number
```

## 验证

```ts
import type { Equal, IsTrue } from '@type-challenges/utils'

type cases = [
  IsTrue<Equal<LengthOfString<''>, 0>>,
  IsTrue<Equal<LengthOfString<'1'>, 1>>,
  IsTrue<Equal<LengthOfString<'12'>, 2>>,
  IsTrue<Equal<LengthOfString<'123'>, 3>>,
  IsTrue<Equal<LengthOfString<'1234'>, 4>>,
  IsTrue<Equal<LengthOfString<'12345'>, 5>>,
  IsTrue<Equal<LengthOfString<'123456'>, 6>>,
  IsTrue<Equal<LengthOfString<'1234567'>, 7>>,
  IsTrue<Equal<LengthOfString<'12345678'>, 8>>,
  IsTrue<Equal<LengthOfString<'123456789'>, 9>>,
  IsTrue<Equal<LengthOfString<'1234567890'>, 10>>,
  IsTrue<Equal<LengthOfString<'12345678901'>, 11>>,
  IsTrue<Equal<LengthOfString<'123456789012'>, 12>>,
  IsTrue<Equal<LengthOfString<'1234567890123'>, 13>>,
  IsTrue<Equal<LengthOfString<'12345678901234'>, 14>>,
  IsTrue<Equal<LengthOfString<'123456789012345'>, 15>>,
  IsTrue<Equal<LengthOfString<'1234567890123456'>, 16>>,
  IsTrue<Equal<LengthOfString<'12345678901234567'>, 17>>,
  IsTrue<Equal<LengthOfString<'123456789012345678'>, 18>>,
  IsTrue<Equal<LengthOfString<'1234567890123456789'>, 19>>,
  IsTrue<Equal<LengthOfString<'12345678901234567890'>, 20>>,
  IsTrue<Equal<LengthOfString<'123456789012345678901'>, 21>>,
  IsTrue<Equal<LengthOfString<'1234567890123456789012'>, 22>>,
  IsTrue<Equal<LengthOfString<'12345678901234567890123'>, 23>>,
  IsTrue<Equal<LengthOfString<'aaaaaaaaaaaaggggggggggggggggggggkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'>, 272>>,
  IsTrue<Equal<LengthOfString<'000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'>, 999>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Length-of-String-3/index.md
---
# Length of String 3
## 题目

Implement a type `LengthOfString<S>` just like `Array#length`:

Differing to two previous challenges about strings' length, this times the type must support strings about $10^6$ characters long, which makes it more challenging.

## 解题思路

待补充

## 答案

```ts
type LengthOfString<S extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type Deced = [10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
type Signum = Deced[number]
type Reped<
  S extends string,
  C extends Signum,
  R extends string = '',
>
  = (C extends 0
    ? R
    : Reped<S, Deced[C], `${R}${S}`>
  )
type t0 = 'k'
type t1 = Reped<t0, 10>
type t2 = Reped<t1, 10>
type t3 = Reped<t2, 10>
type t4 = Reped<t3, 10>
type t5 = Reped<t4, 10>
type t6 = Reped<t5, 10>
type Signums<
  N extends string,
  Acc extends readonly Signum[] = [],
> = N extends `${infer Head extends Signum}${infer Rest}`
  ? Signums<Rest, [...Acc, Head]>
  : Acc
type Gened<N extends string> = Signums<N> extends [
  infer N6 extends Signum,
  infer N5 extends Signum,
  infer N4 extends Signum,
  infer N3 extends Signum,
  infer N2 extends Signum,
  infer N1 extends Signum,
  infer N0 extends Signum,
] ? `${''
  }${Reped<t6, N6>
  }${Reped<t5, N5>
  }${Reped<t4, N4>
  }${Reped<t3, N3>
  }${Reped<t2, N2>
  }${Reped<t1, N1>
  }${Reped<t0, N0>
  }` : never

type cases = [
  Expect<Equal<LengthOfString<Gened<'0000000'>>, 0>>,
  Expect<Equal<LengthOfString<Gened<'0000001'>>, 1>>,
  Expect<Equal<LengthOfString<Gened<'0000002'>>, 2>>,
  Expect<Equal<LengthOfString<Gened<'0000003'>>, 3>>,
  Expect<Equal<LengthOfString<Gened<'0000004'>>, 4>>,
  Expect<Equal<LengthOfString<Gened<'0000005'>>, 5>>,
  Expect<Equal<LengthOfString<Gened<'0000055'>>, 55>>,
  Expect<Equal<LengthOfString<Gened<'0000555'>>, 555>>,
  Expect<Equal<LengthOfString<Gened<'0005555'>>, 5555>>,
  Expect<Equal<LengthOfString<Gened<'0055555'>>, 55555>>,
  Expect<Equal<LengthOfString<Gened<'8464592'>>, 8464592>>,
  Expect<Equal<LengthOfString<Gened<'1373690'>>, 1373690>>,
  Expect<Equal<LengthOfString<Gened<'1707793'>>, 1707793>>,
  Expect<Equal<LengthOfString<Gened<'0196268'>>, 196268>>,
  Expect<Equal<LengthOfString<Gened<'6646734'>>, 6646734>>,
  Expect<Equal<LengthOfString<Gened<'0538159'>>, 538159>>,
  Expect<Equal<LengthOfString<Gened<'0058901'>>, 58901>>,
  Expect<Equal<LengthOfString<Gened<'8414001'>>, 8414001>>,
  Expect<Equal<LengthOfString<Gened<'1740697'>>, 1740697>>,
  Expect<Equal<LengthOfString<Gened<'2281441'>>, 2281441>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Maximum/index.md
---
# Maximum
## 题目

### Description

Implement the type `Maximum`, which takes an input type `T`, and returns the maximum value in `T`.

If `T` is an empty array, it returns `never`. **Negative numbers** are not considered.

For example:

```ts
Maximum<[]> // never
Maximum<[0, 2, 1]> // 2
Maximum<[1, 20, 200, 150]> // 200
```

### Advanced

Can you implement type `Minimum` inspired by `Maximum`?

## 解题思路

待补充

## 答案

```ts
type Maximum<T extends any[]> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Maximum<[]>, never>>,
  Expect<Equal<Maximum<[0, 2, 1]>, 2>>,
  Expect<Equal<Maximum<[1, 20, 200, 150]>, 200>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Mutable-Keys/index.md
---
# Mutable Keys
## 题目

Implement the advanced util type `MutableKeys<T>`, which picks all the mutable (not readonly) keys into a union.

For example:

```ts
type Keys = MutableKeys<{ readonly foo: string, bar: number }>
// expected to be “bar”
```

## 解题思路

待补充

## 答案

```ts
type MutableKeys<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<MutableKeys<{ a: number, readonly b: string }>, 'a'>>,
  Expect<Equal<MutableKeys<{ a: undefined, readonly b: undefined }>, 'a'>>,
  Expect<Equal<MutableKeys<{ a: undefined, readonly b?: undefined, c: string, d: null }>, 'a' | 'c' | 'd'>>,
  Expect<Equal<MutableKeys<{}>, never>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Object-Key-Paths/index.md
---
# Object Key Paths
## 题目

Get all possible paths that could be called by [\_.get](https://lodash.com/docs/4.17.15#get) (a lodash function) to get the value of an object

```typescript
type T1 = ObjectKeyPaths<{ name: string, age: number }> // expected to be 'name' | 'age'
type T2 = ObjectKeyPaths<{
  refCount: number
  person: { name: string, age: number }
}> // expected to be 'refCount' | 'person' | 'person.name' | 'person.age'
type T3 = ObjectKeyPaths<{ books: [{ name: string, price: number }] }> // expected to be the superset of 'books' | 'books.0' | 'books[0]' | 'books.[0]' | 'books.0.name' | 'books.0.price' | 'books.length' | 'books.find'
```

## 解题思路

待补充

## 答案

```ts
type ObjectKeyPaths<T extends object> = any
```

## 验证

```ts
import type { Equal, Expect, ExpectExtends } from '@type-challenges/utils'

const ref = {
  count: 1,
  person: {
    name: 'cattchen',
    age: 22,
    books: ['book1', 'book2'],
    pets: [
      {
        type: 'cat',
      },
    ],
  },
}

type cases = [
  Expect<Equal<ObjectKeyPaths<{ name: string, age: number }>, 'name' | 'age'>>,
  Expect<
    Equal<
      ObjectKeyPaths<{
        refCount: number
        person: { name: string, age: number }
      }>,
  'refCount' | 'person' | 'person.name' | 'person.age'
    >
  >,
  Expect<ExpectExtends<ObjectKeyPaths<typeof ref>, 'count'>>,
  Expect<ExpectExtends<ObjectKeyPaths<typeof ref>, 'person'>>,
  Expect<ExpectExtends<ObjectKeyPaths<typeof ref>, 'person.name'>>,
  Expect<ExpectExtends<ObjectKeyPaths<typeof ref>, 'person.age'>>,
  Expect<ExpectExtends<ObjectKeyPaths<typeof ref>, 'person.books'>>,
  Expect<ExpectExtends<ObjectKeyPaths<typeof ref>, 'person.pets'>>,
  Expect<ExpectExtends<ObjectKeyPaths<typeof ref>, 'person.books.0'>>,
  Expect<ExpectExtends<ObjectKeyPaths<typeof ref>, 'person.books.1'>>,
  Expect<ExpectExtends<ObjectKeyPaths<typeof ref>, 'person.books[0]'>>,
  Expect<ExpectExtends<ObjectKeyPaths<typeof ref>, 'person.books.[0]'>>,
  Expect<ExpectExtends<ObjectKeyPaths<typeof ref>, 'person.pets.0.type'>>,
  Expect<Equal<ExpectExtends<ObjectKeyPaths<typeof ref>, 'notExist'>, false>>,
  Expect<Equal<ExpectExtends<ObjectKeyPaths<typeof ref>, 'person.notExist'>, false>>,
  Expect<Equal<ExpectExtends<ObjectKeyPaths<typeof ref>, 'person.name.'>, false>>,
  Expect<Equal<ExpectExtends<ObjectKeyPaths<typeof ref>, '.person.name'>, false>>,
  Expect<Equal<ExpectExtends<ObjectKeyPaths<typeof ref>, 'person.pets.[0]type'>, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/ObjectFromEntries/index.md
---
# ObjectFromEntries
## 题目

Implement the type version of `Object.fromEntries`

For example:

```typescript
interface Model {
  name: string
  age: number
  locations: string[] | null
}

type ModelEntries = ['name', string] | ['age', number] | ['locations', string[] | null]

type result = ObjectFromEntries<ModelEntries> // expected to be Model
```

## 解题思路

待补充

## 答案

```ts
type ObjectFromEntries<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface Model {
  name: string
  age: number
  locations: string[] | null
}

type ModelEntries = ['name', string] | ['age', number] | ['locations', string[] | null]

type cases = [
  Expect<Equal<ObjectFromEntries<ModelEntries>, Model>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Optional-Keys/index.md
---
# Optional Keys
## 题目

实现高级工具类型`OptionalKeys<T>`，该类型将 T 中所有可选属性的键合并为一个联合类型。

## 解题思路

待补充

## 答案

```ts
type OptionalKeys<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<OptionalKeys<{ a: number, b?: string }>, 'b'>>,
  Expect<Equal<OptionalKeys<{ a: undefined, b?: undefined }>, 'b'>>,
  Expect<Equal<OptionalKeys<{ a: undefined, b?: undefined, c?: string, d?: null }>, 'b' | 'c' | 'd'>>,
  Expect<Equal<OptionalKeys<{}>, never>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/OptionalUndefined/index.md
---
# OptionalUndefined
## 题目

Implement the util type `OptionalUndefined<T, Props>` that turns all the properties of `T` that can be `undefined`, into optional properties. In addition, a second -optional- generic `Props` can be passed to restrict the properties that can be altered.

```ts
OptionalUndefined<{ value: string | undefined, description: string }>
// { value?: string | undefined; description: string }

OptionalUndefined<{ value: string | undefined, description: string | undefined, author: string | undefined }, 'description' | 'author'>
// { value: string | undefined; description?: string | undefined, author?: string | undefined }
```

## 解题思路

待补充

## 答案

```ts
type OptionalUndefined<T, Props> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<OptionalUndefined<{ value: string | undefined }, 'value'>, { value?: string | undefined }>>,
  Expect<Equal<OptionalUndefined<{ value: string, desc: string }, 'value'>, { value: string, desc: string }>>,
  Expect<Equal<OptionalUndefined<{ value: string | undefined, desc: string }, 'value'>, { value?: string, desc: string }>>,
  Expect<Equal<OptionalUndefined<{ value: string | undefined, desc: string | undefined }, 'value'>, { value?: string | undefined, desc: string | undefined }>>,
  Expect<Equal<OptionalUndefined<{ value: string | undefined, desc: string }, 'value' | 'desc'>, { value?: string, desc: string }>>,
  Expect<Equal<OptionalUndefined<{ value: string | undefined, desc: string | undefined }>, { value?: string, desc?: string }>>,
  Expect<Equal<OptionalUndefined<{ value?: string }, 'value'>, { value?: string }>>,
  Expect<Equal<OptionalUndefined<{ value?: string }>, { value?: string }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Pinia/index.md
---
# Pinia
## 题目

Create a type-level function whose types is similar to [Pinia](https://github.com/posva/pinia) library. You don't need to implement function actually, just adding types.

### Overview

This function receive only one parameter whose type is an object. The object contains 4 properties:

* `id` - just a string (required)
* `state` - a function which will return an object as store's state (required)
* `getters` - an object with methods which is similar to Vue's computed values or Vuex's getters, and details are below (optional)
* `actions` - an object with methods which can do side effects and mutate state, and details are below (optional)

### Getters

When you define a store like this:

```typescript
const store = defineStore({
  // ...other required fields
  getters: {
    getSomething() {
      return 'xxx'
    }
  }
})
```

And you should use it like this:

```typescript
store.getSomething
```

instead of:

```typescript
store.getSomething() // error
```

Additionally, getters can access state and/or other getters via `this`, but state is read-only.

### Actions

When you define a store like this:

```typescript
const store = defineStore({
  // ...other required fields
  actions: {
    doSideEffect() {
      this.xxx = 'xxx'
      return 'ok'
    }
  }
})
```

Using it is just to call it:

```typescript
const returnValue = store.doSideEffect()
```

Actions can return any value or return nothing, and it can receive any number of parameters with different types.
Parameters types and return type can't be lost, which means type-checking must be available at call side.

State can be accessed and mutated via `this`. Getters can be accessed via `this` but they're read-only.

## 解题思路

待补充

## 答案

```ts
declare function defineStore(store: unknown): unknown
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

const store = defineStore({
  id: '',
  state: () => ({
    num: 0,
    str: '',
  }),
  getters: {
    stringifiedNum() {
      // @ts-expect-error
      this.num += 1

      return this.num.toString()
    },
    parsedNum() {
      return Number.parseInt(this.stringifiedNum)
    },
  },
  actions: {
    init() {
      this.reset()
      this.increment()
    },
    increment(step = 1) {
      this.num += step
    },
    reset() {
      this.num = 0

      // @ts-expect-error
      this.parsedNum = 0

      return true
    },
    setNum(value: number) {
      this.num = value
    },
  },
})

// @ts-expect-error
store.nopeStateProp
// @ts-expect-error
store.nopeGetter
// @ts-expect-error
store.stringifiedNum()
store.init()
// @ts-expect-error
store.init(0)
store.increment()
store.increment(2)
// @ts-expect-error
store.setNum()
// @ts-expect-error
store.setNum('3')
store.setNum(3)
const r = store.reset()

type _tests = [
  Expect<Equal<typeof store.num, number>>,
  Expect<Equal<typeof store.str, string>>,
  Expect<Equal<typeof store.stringifiedNum, string>>,
  Expect<Equal<typeof store.parsedNum, number>>,
  Expect<Equal<typeof r, true>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/printf/index.md
---
# printf
## 题目

Implement `Format<T extends string>` generic.

For example,

```ts
type FormatCase1 = Format<'%sabc'> // FormatCase1 : string => string
type FormatCase2 = Format<'%s%dabc'> // FormatCase2 : string => number => string
type FormatCase3 = Format<'sdabc'> // FormatCase3 :  string
type FormatCase4 = Format<'sd%abc'> // FormatCase4 :  string
```

## 解题思路

待补充

## 答案

```ts
type Format<T extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Format<'abc'>, string>>,
  Expect<Equal<Format<'a%sbc'>, (s1: string) => string>>,
  Expect<Equal<Format<'a%dbc'>, (d1: number) => string>>,
  Expect<Equal<Format<'a%%dbc'>, string>>,
  Expect<Equal<Format<'a%%%dbc'>, (d1: number) => string>>,
  Expect<Equal<Format<'a%dbc%s'>, (d1: number) => (s1: string) => string>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Replace-Union/index.md
---
# Replace Union
## 题目

Given an `union of types` and `array of type pairs` to replace (`[[string, number], [Date, null]]`), return a new union replaced with the `type pairs`.

## 解题思路

待补充

## 答案

```ts
type UnionReplace<T, U extends [any, any][]> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  // string -> null
  Expect<Equal<UnionReplace<number | string, [[string, null]]>, number | null>>,

  // string -> null
  Expect<Equal<UnionReplace<number | string, [[string, null], [Date, Function]]>, number | null>>,

  // Date -> string; Function -> undefined
  Expect<Equal<UnionReplace<Function | Date | object, [[Date, string], [Function, undefined]]>, undefined | string | object>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Required-Keys/index.md
---
# Required Keys
## 题目

实现高级工具类型 `RequiredKeys<T>`，该类型返回 T 中所有必需属性的键组成的一个联合类型。

例如

```ts
type Result = RequiredKeys<{ foo: number, bar?: string }>
// expected to be “foo”
```

## 解题思路

待补充

## 答案

```ts
type RequiredKeys<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<RequiredKeys<{ a: number, b?: string }>, 'a'>>,
  Expect<Equal<RequiredKeys<{ a: undefined, b?: undefined }>, 'a'>>,
  Expect<Equal<RequiredKeys<{ a: undefined, b?: undefined, c: string, d: null }>, 'a' | 'c' | 'd'>>,
  Expect<Equal<RequiredKeys<{}>, never>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Run-length-encoding/index.md
---
# Run-length encoding
## 题目

Given a `string` sequence of a letters f.e. `AAABCCXXXXXXY`. Return run-length encoded string `3AB2C6XY`.
Also make a decoder for that string.

## 解题思路

待补充

## 答案

```ts
namespace RLE {
  export type Encode<S extends string> = any
  export type Decode<S extends string> = any
}
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  // Raw string -> encoded string
  Expect<Equal<RLE.Encode<'AAABCCXXXXXXY'>, '3AB2C6XY'>>,

  // Encoded string -> decoded string
  Expect<Equal<RLE.Decode<'3AB2C6XY'>, 'AAABCCXXXXXXY'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Simple-Vue/index.md
---
# Simple Vue
## 题目

实现类似Vue的类型支持的简化版本。

通过提供一个函数`SimpleVue`（类似于`Vue.extend`或`defineComponent`），它应该正确地推断出 computed 和 methods 内部的`this`类型。

在此挑战中，我们假设`SimpleVue`接受只带有`data`，`computed`和`methods`字段的Object作为其唯一的参数，

* `data`是一个简单的函数，它返回一个提供上下文`this`的对象，但是你无法在`data`中获取其他的计算属性或方法。

* `computed`是将`this`作为上下文的函数的对象，进行一些计算并返回结果。在上下文中应暴露计算出的值而不是函数。

* `methods`是函数的对象，其上下文也为`this`。函数中可以访问`data`，`computed`以及其他`methods`中的暴露的字段。 `computed`与`methods`的不同之处在于`methods`在上下文中按原样暴露为函数。

`SimpleVue`的返回值类型可以是任意的。

```ts
const instance = SimpleVue({
  data() {
    return {
      firstname: 'Type',
      lastname: 'Challenges',
      amount: 10,
    }
  },
  computed: {
    fullname() {
      return `${this.firstname} ${this.lastname}`
    }
  },
  methods: {
    hi() {
      alert(this.fullname.toLowerCase())
    }
  }
})
```

## 解题思路

待补充

## 答案

```ts
declare function SimpleVue(options: any): any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

SimpleVue({
  data() {
    // @ts-expect-error
    this.firstname
    // @ts-expect-error
    this.getRandom()
    // @ts-expect-error
    this.data()

    return {
      firstname: 'Type',
      lastname: 'Challenges',
      amount: 10,
    }
  },
  computed: {
    fullname() {
      return `${this.firstname} ${this.lastname}`
    },
  },
  methods: {
    getRandom() {
      return Math.random()
    },
    hi() {
      alert(this.amount)
      alert(this.fullname.toLowerCase())
      alert(this.getRandom())
    },
    test() {
      const fullname = this.fullname
      const cases: [Expect<Equal<typeof fullname, string>>] = [] as any
    },
  },
})
```

## 参考

无

---

---
url: /TypeGymnastics/hard/SnakeCase/index.md
---
# SnakeCase
## 题目

Create a `SnakeCase<T>` generic that turns a string formatted in **camelCase** into a string formatted in **snake\_case**.

A few examples:

```ts
type res1 = SnakeCase<'hello'> // => "hello"
type res2 = SnakeCase<'userName'> // => "user_name"
type res3 = SnakeCase<'getElementById'> // => "get_element_by_id"
```

## 解题思路

待补充

## 答案

```ts
type SnakeCase<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<SnakeCase<'hello'>, 'hello'>>,
  Expect<Equal<SnakeCase<'userName'>, 'user_name'>>,
  Expect<Equal<SnakeCase<'getElementById'>, 'get_element_by_id'>>,
  Expect<Equal<SnakeCase<'getElementById' | 'getElementByClassNames'>, 'get_element_by_id' | 'get_element_by_class_names'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Split/index.md
---
# Split
## 题目

The well known `split()` method splits a string into an array of substrings by looking for a separator, and returns the new array. The goal of this challenge is to split a string, by using a separator, but in the type system!

For example:

```ts
type result = Split<'Hi! How are you?', ' '> // should be ['Hi!', 'How', 'are', 'you?']
```

## 解题思路

待补充

## 答案

```ts
type Split<S extends string, SEP extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Split<'Hi! How are you?'>, ['Hi! How are you?']>>,
  Expect<Equal<Split<'Hi! How are you?', 'z'>, ['Hi! How are you?']>>,
  Expect<Equal<Split<'Hi! How are you?', ' '>, ['Hi!', 'How', 'are', 'you?']>>,
  Expect<Equal<Split<'Hi! How are you?', ''>, ['H', 'i', '!', ' ', 'H', 'o', 'w', ' ', 'a', 'r', 'e', ' ', 'y', 'o', 'u', '?']>>,
  Expect<Equal<Split<'', ''>, []>>,
  Expect<Equal<Split<'The sine in cosine', 'in'>, ['The s', 'e ', ' cos', 'e']>>,
  Expect<Equal<Split<'Never say never, forever and ever.', 'ver'>, ['Ne', ' say ne', ', fore', ' and e', '.']>>,
  Expect<Equal<Split<'', 'z'>, ['']>>,
  Expect<Equal<Split<''>, ['']>>,
  Expect<Equal<Split<string, 'whatever'>, string[]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/String-Join/index.md
---
# String Join
## 题目

Create a type-safe string join utility which can be used like so:

```ts
const hyphenJoiner = join('-')
const result = hyphenJoiner('a', 'b', 'c') // = 'a-b-c'
```

Or alternatively:

```ts
join('#')('a', 'b', 'c') // = 'a#b#c'
```

When we pass an empty delimiter (i.e '') to join, we should concat the strings as they are, i.e:

```ts
join('')('a', 'b', 'c') // = 'abc'
```

When only one item is passed, we should get back the original item (without any delimiter added):

```ts
join('-')('a') // = 'a'
```

## 解题思路

待补充

## 答案

```ts
declare function join(delimiter: any): (...parts: any[]) => any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

// Edge cases
const noCharsOutput = join('-')()
const oneCharOutput = join('-')('a')
const noDelimiterOutput = join('')('a', 'b', 'c')

// Regular cases
const hyphenOutput = join('-')('a', 'b', 'c')
const hashOutput = join('#')('a', 'b', 'c')
const twoCharOutput = join('-')('a', 'b')
const longOutput = join('-')('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h')

type cases = [
  Expect<Equal<typeof noCharsOutput, ''>>,
  Expect<Equal<typeof oneCharOutput, 'a'>>,
  Expect<Equal<typeof noDelimiterOutput, 'abc'>>,
  Expect<Equal<typeof twoCharOutput, 'a-b'>>,
  Expect<Equal<typeof hyphenOutput, 'a-b-c'>>,
  Expect<Equal<typeof hashOutput, 'a#b#c'>>,
  Expect<Equal<typeof longOutput, 'a-b-c-d-e-f-g-h'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/String-to-Number/index.md
---
# String to Number
## 题目

Convert a string literal to a number, which behaves like `Number.parseInt`.

## 解题思路

待补充

## 答案

```ts
type ToNumber<S extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<ToNumber<'0'>, 0>>,
  Expect<Equal<ToNumber<'5'>, 5>>,
  Expect<Equal<ToNumber<'12'>, 12>>,
  Expect<Equal<ToNumber<'27'>, 27>>,
  Expect<Equal<ToNumber<'18@7_$%'>, never>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Sudoku/index.md
---
# Sudoku
## 题目

Write a type that verifies [Sudoku](https://en.wikipedia.org/wiki/Sudoku) game is solved. This is based off a [challenge](https://typehero.dev/challenge/sudoku) from Advent of Typescript 2023 by TypeHero (Day 22). So kudos for them for thinking up such a neat challenge!

## 解题思路

待补充

## 答案

```ts
type Digits = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
type SudokuSolved = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type test_sudoku_1_actual = SudokuSolved<[
  [[1, 2, 3], [5, 6, 7], [4, 8, 9]],
  [[4, 8, 9], [1, 2, 3], [5, 6, 7]],
  [[5, 6, 7], [4, 8, 9], [1, 2, 3]],
  [[3, 1, 2], [8, 5, 6], [9, 7, 4]],
  [[7, 9, 4], [3, 1, 2], [8, 5, 6]],
  [[8, 5, 6], [7, 9, 4], [3, 1, 2]],
  [[2, 3, 1], [6, 4, 5], [7, 9, 8]],
  [[9, 7, 8], [2, 3, 1], [6, 4, 5]],
  [[6, 4, 5], [9, 7, 8], [2, 3, 1]],
]>

type test_sudoku_2_actual = SudokuSolved<[
  [[7, 1, 5], [4, 3, 8], [6, 9, 2]],
  [[4, 8, 6], [9, 2, 5], [7, 1, 3]],
  [[9, 3, 2], [1, 6, 7], [4, 8, 5]],
  [[6, 5, 7], [2, 8, 9], [1, 3, 4]],
  [[3, 2, 8], [7, 4, 1], [9, 5, 6]],
  [[1, 4, 9], [3, 5, 6], [8, 2, 7]],
  [[5, 9, 1], [6, 7, 3], [2, 4, 8]],
  [[2, 6, 3], [8, 9, 4], [5, 7, 1]],
  [[8, 7, 4], [5, 1, 2], [3, 6, 9]],
]>

type test_sudoku_3_actual = SudokuSolved<[
  [[3, 9, 2], [7, 5, 1], [8, 6, 4]],
  [[4, 8, 1], [6, 2, 9], [5, 7, 3]],
  [[5, 7, 6], [8, 4, 3], [2, 9, 1]],
  [[7, 2, 9], [3, 1, 8], [4, 5, 6]],
  [[6, 5, 8], [2, 7, 4], [3, 1, 9]],
  [[1, 4, 3], [5, 9, 6], [7, 2, 8]],
  [[2, 1, 4], [9, 3, 5], [6, 8, 7]],
  [[9, 6, 5], [4, 8, 7], [1, 3, 2]],
  [[8, 3, 7], [1, 6, 2], [9, 4, 5]],
]>

type test_sudoku_4_actual = SudokuSolved<[
  [[1, 2, 3], [5, 6, 7], [4, 8, 9]],
  [[4, 8, 9], [1, 2, 3], [5, 6, 7]],
  [[5, 6, 7], [4, 8, 9], [1, 2, 3]],
  [[3, 1, 2], [8, 5, 6], [9, 7, 4]],
  [[7, 9, 4], [3, 1, 2], [8, 5, 6]],
  [[8, 5, 6], [7, 9, 4], [3, 1, 2]],
  [[2, 3, 1], [6, 4, 5], [8, 9, 4]],
  [[9, 7, 8], [2, 3, 1], [6, 4, 5]],
  [[6, 4, 5], [9, 7, 8], [2, 3, 1]],
]>

type test_sudoku_5_actual = SudokuSolved<[
  [[7, 1, 5], [4, 3, 8], [6, 9, 2]],
  [[4, 8, 6], [9, 2, 5], [7, 1, 3]],
  [[9, 3, 2], [1, 6, 7], [4, 8, 5]],
  [[6, 5, 7], [2, 8, 9], [1, 3, 4]],
  [[3, 2, 8], [7, 4, 1], [9, 5, 6]],
  [[1, 4, 9], [3, 5, 6], [8, 2, 7]],
  [[5, 9, 1], [6, 2, 3], [2, 4, 8]],
  [[2, 6, 3], [8, 9, 4], [5, 7, 1]],
  [[8, 7, 4], [5, 1, 2], [3, 6, 9]],
]>

type test_sudoku_6_actual = SudokuSolved<[
  [[8, 9, 7], [3, 6, 1], [1, 4, 5]],
  [[6, 3, 4], [1, 4, 9], [2, 8, 7]],
  [[1, 2, 4], [5, 8, 7], [9, 6, 3]],
  [[3, 8, 9], [6, 2, 1], [5, 7, 4]],
  [[4, 7, 2], [8, 9, 5], [6, 3, 1]],
  [[5, 1, 6], [4, 7, 3], [8, 2, 9]],
  [[7, 5, 1], [2, 3, 8], [4, 9, 6]],
  [[9, 6, 8], [7, 5, 4], [3, 1, 2]],
  [[2, 4, 3], [9, 1, 6], [7, 5, 8]],
]>

type test_sudoku_7_actual = SudokuSolved<[
  [[1, 2, 3], [5, 6, 7], [4, 8, 9]],
  [[2, 3, 5], [6, 7, 4], [8, 9, 1]],
  [[3, 5, 6], [7, 4, 8], [9, 1, 2]],
  [[5, 6, 7], [4, 8, 9], [1, 2, 3]],
  [[6, 7, 4], [8, 9, 1], [2, 3, 5]],
  [[7, 4, 8], [9, 1, 2], [3, 5, 6]],
  [[4, 8, 9], [1, 2, 3], [5, 6, 7]],
  [[8, 9, 1], [2, 3, 5], [6, 7, 4]],
  [[9, 1, 2], [3, 5, 6], [7, 4, 8]],
]>

type test_sudoku_8_actual = SudokuSolved<[
  [[3, 9, 2], [7, 5, 1], [8, 6, 4]],
  [[3, 9, 2], [7, 5, 1], [8, 6, 4]],
  [[3, 9, 2], [7, 5, 1], [8, 6, 4]],
  [[3, 9, 2], [7, 5, 1], [8, 6, 4]],
  [[3, 9, 2], [7, 5, 1], [8, 6, 4]],
  [[3, 9, 2], [7, 5, 1], [8, 6, 4]],
  [[3, 9, 2], [7, 5, 1], [8, 6, 4]],
  [[3, 9, 2], [7, 5, 1], [8, 6, 4]],
  [[3, 9, 2], [7, 5, 1], [8, 6, 4]],
]>

type cases = [
  Expect<Equal<test_sudoku_1_actual, true>>,
  Expect<Equal<test_sudoku_2_actual, true>>,
  Expect<Equal<test_sudoku_3_actual, true>>,
  Expect<Equal<test_sudoku_4_actual, false>>,
  Expect<Equal<test_sudoku_5_actual, false>>,
  Expect<Equal<test_sudoku_6_actual, false>>,
  Expect<Equal<test_sudoku_7_actual, false>>,
  Expect<Equal<test_sudoku_8_actual, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Take-Elements/index.md
---
# Take Elements
## 题目

Implement a type `Take<N, Arr>` that returns the first `N` elements from an array `Arr`. If `N` is negative, return the last `|N|` elements

For example,

```ts
type T0 = Take<2, [1, 2, 3]> // [1, 2]
type T1 = Take<3, ['1', 2, true, false]> // ['1', 2, true]
type T2 = Take<-2, [1, 2, 3]> // [2, 3]
type T3 = Take<0, [1, 2, 3]> // []
type T4 = Take<5, [1, 2, 3]> // [1, 2, 3]
type T5 = Take<3, []> // []
```

## 解题思路

待补充

## 答案

```ts
type Take<N, Arr> = Arr
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Take<2, [1, 2, 3]>, [1, 2]>>,
  Expect<Equal<Take<3, ['1', 2, true, false]>, ['1', 2, true]>>,
  Expect<Equal<Take<-2, [1, 2, 3]>, [2, 3]>>,
  Expect<Equal<Take<0, [1, 2, 3]>, []>>,
  Expect<Equal<Take<5, [1, 2, 3]>, [1, 2, 3]>>,
  Expect<Equal<Take<3, []>, []>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Tree-path-array/index.md
---
# Tree path array
## 题目

Create a type `Path` that represents validates a possible path of a tree under the form of an array.

Related challenges:

* [Object key path](https://github.com/type-challenges/type-challenges/blob/main/questions/07258-hard-object-key-paths/README.md)

```ts
declare const example: {
  foo: {
    bar: {
      a: string
    }
    baz: {
      b: number
      c: number
    }
  }
}

// Possible solutions:
// []
// ['foo']
// ['foo', 'bar']
// ['foo', 'bar', 'a']
// ['foo', 'baz']
// ['foo', 'baz', 'b']
// ['foo', 'baz', 'c']
```

## 解题思路

待补充

## 答案

```ts
type Path<T> = any
```

## 验证

```ts
import type { ExpectExtends, ExpectFalse, ExpectTrue } from '@type-challenges/utils'

declare const example: {
  foo: {
    bar: {
      a: string
    }
    baz: {
      b: number
      c: number
    }
  }
}

type cases = [
  ExpectTrue<ExpectExtends<Path<typeof example['foo']['bar']>, ['a']>>,
  ExpectTrue<ExpectExtends<Path<typeof example['foo']['baz']>, ['b'] | ['c']>>,
  ExpectTrue<ExpectExtends<Path<typeof example['foo']>, ['bar'] | ['baz'] | ['bar', 'a'] | ['baz', 'b'] | ['baz', 'c']>>,
  ExpectFalse<ExpectExtends<Path<typeof example['foo']['bar']>, ['z']>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Tuple-Filter/index.md
---
# Tuple Filter
## 题目

Implement a type `FilterOut<T, F>` that filters out items of the given type `F` from the tuple `T`.

For example,

```ts
type Filtered = FilterOut<[1, 2, null, 3], null> // [1, 2, 3]
```

## 解题思路

待补充

## 答案

```ts
type FilterOut<T extends any[], F> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<FilterOut<[], never>, []>>,
  Expect<Equal<FilterOut<[never], never>, []>>,
  Expect<Equal<FilterOut<['a', never], never>, ['a']>>,
  Expect<Equal<FilterOut<[1, never, 'a'], never>, [1, 'a']>>,
  Expect<Equal<FilterOut<[never, 1, 'a', undefined, false, null], never | null | undefined>, [1, 'a', false]>>,
  Expect<Equal<FilterOut<[number | null | undefined, never], never | null | undefined>, [number | null | undefined]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Tuple-to-Enum-Object/index.md
---
# Tuple to Enum Object
## 题目

枚举是 TypeScript 的一种原生语法（在 JavaScript 中不存在）。因此在 JavaScript 中枚举会被转成如下形式的代码：

```js
let OperatingSystem
;(function (OperatingSystem) {
  OperatingSystem[(OperatingSystem.MacOS = 0)] = 'MacOS'
  OperatingSystem[(OperatingSystem.Windows = 1)] = 'Windows'
  OperatingSystem[(OperatingSystem.Linux = 2)] = 'Linux'
})(OperatingSystem || (OperatingSystem = {}))
```

在这个问题中，你实现的类型应当将给定的字符串元组转成一个行为类似枚举的对象。此外，枚举的属性一般是 `pascal-case` 的。

```ts
Enum<['macOS', 'Windows', 'Linux']>
// -> { readonly MacOS: "macOS", readonly Windows: "Windows", readonly Linux: "Linux" }
```

如果传递了第二个泛型参数，且值为 `true`，那么返回值应当是一个 `number` 字面量。

```ts
Enum<['macOS', 'Windows', 'Linux'], true>
// -> { readonly MacOS: 0, readonly Windows: 1, readonly Linux: 2 }
```

## 解题思路

待补充

## 答案

```ts
type Enum<T extends readonly string[], N extends boolean = false> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

const OperatingSystem = ['macOS', 'Windows', 'Linux'] as const
const Command = ['echo', 'grep', 'sed', 'awk', 'cut', 'uniq', 'head', 'tail', 'xargs', 'shift'] as const

type cases = [
  Expect<Equal<Enum<[]>, {}>>,
  Expect<Equal<
    Enum<typeof OperatingSystem>,
    {
      readonly MacOS: 'macOS'
      readonly Windows: 'Windows'
      readonly Linux: 'Linux'
    }
  >>,
  Expect<Equal<
    Enum<typeof OperatingSystem, true>,
    {
      readonly MacOS: 0
      readonly Windows: 1
      readonly Linux: 2
    }
  >>,
  Expect<Equal<
    Enum<typeof Command>,
    {
      readonly Echo: 'echo'
      readonly Grep: 'grep'
      readonly Sed: 'sed'
      readonly Awk: 'awk'
      readonly Cut: 'cut'
      readonly Uniq: 'uniq'
      readonly Head: 'head'
      readonly Tail: 'tail'
      readonly Xargs: 'xargs'
      readonly Shift: 'shift'
    }
  >>,
  Expect<Equal<
    Enum<typeof Command, true>,
    {
      readonly Echo: 0
      readonly Grep: 1
      readonly Sed: 2
      readonly Awk: 3
      readonly Cut: 4
      readonly Uniq: 5
      readonly Head: 6
      readonly Tail: 7
      readonly Xargs: 8
      readonly Shift: 9
    }
  >>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Two-Sum/index.md
---
# Two Sum
## 题目

给定一个整数数组 nums 和一个目标整数 target, 如果 nums 数组中存在两个元素的和等于 target 返回 true, 否则返回 false

## 解题思路

待补充

## 答案

```ts
type TwoSum<T extends number[], U extends number> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<TwoSum<[3, 3], 6>, true>>,
  Expect<Equal<TwoSum<[3, 2, 4], 6>, true>>,
  Expect<Equal<TwoSum<[2, 7, 11, 15], 15>, false>>,
  Expect<Equal<TwoSum<[2, 7, 11, 15], 9>, true>>,
  Expect<Equal<TwoSum<[1, 2, 3], 0>, false>>,
  Expect<Equal<TwoSum<[1, 2, 3], 1>, false>>,
  Expect<Equal<TwoSum<[1, 2, 3], 2>, false>>,
  Expect<Equal<TwoSum<[1, 2, 3], 3>, true>>,
  Expect<Equal<TwoSum<[1, 2, 3], 4>, true>>,
  Expect<Equal<TwoSum<[1, 2, 3], 5>, true>>,
  Expect<Equal<TwoSum<[1, 2, 3], 6>, false>>,
  Expect<Equal<TwoSum<[3, 2, 0], 2>, true>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Typed-Get/index.md
---
# Typed Get
## 题目

The [`get` function in lodash](https://lodash.com/docs/4.17.15#get) is a quite convenient helper for accessing nested values in JavaScript. However, when we come to TypeScript, using functions like this will make you lose the type information. With TS 4.1's upcoming [Template Literal Types](https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#template-literal-types) feature, properly typing `get` becomes possible. Can you implement it?

For example,

```ts
interface Data {
  foo: {
    bar: {
      value: 'foobar'
      count: 6
    }
    included: true
  }
  hello: 'world'
}

type A = Get<Data, 'hello'> // 'world'
type B = Get<Data, 'foo.bar.count'> // 6
type C = Get<Data, 'foo.bar'> // { value: 'foobar', count: 6 }
```

Accessing arrays is not required in this challenge.

## 解题思路

待补充

## 答案

```ts
type Get<T, K> = string
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Get<Data, 'hello'>, 'world'>>,
  Expect<Equal<Get<Data, 'foo.bar.count'>, 6>>,
  Expect<Equal<Get<Data, 'foo.bar'>, { value: 'foobar', count: 6 }>>,
  Expect<Equal<Get<Data, 'foo.baz'>, false>>,

  Expect<Equal<Get<Data, 'no.existed'>, never>>,
]

interface Data {
  'foo': {
    bar: {
      value: 'foobar'
      count: 6
    }
    included: true
  }
  'foo.baz': false
  'hello': 'world'
}
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Unbox/index.md
---
# Unbox
## 题目

How can we build a type that "unboxes" arrays, functions, promises, and tuples?

Example:

```typescript
Unbox<string> // string
Unbox<() => number> // number
Unbox<boolean[]> // boolean
Unbox<Promise<boolean>> // boolean
```

Bonus: Can we make it recursive?

```typescript
Unbox<() => () => () => () => number> // number
```

Double Bonus: Can we control the recursion?

```typescript
Unbox<() => () => () => () => number, 3> // () => number
```

## 解题思路

待补充

## 答案

```ts
type Unbox<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  // Base cases
  Expect<Equal<Unbox<number>, number>>,
  Expect<Equal<Unbox<() => number>, number>>,
  Expect<Equal<Unbox<() => number | string>, number | string>>,
  Expect<Equal<Unbox<number[]>, number>>,
  Expect<Equal<Unbox<(number | string)[]>, number | string>>,
  Expect<Equal<Unbox<[number]>, number>>,
  Expect<Equal<Unbox<Promise<number>>, number>>,

  // Bonus: Recursion
  Expect<Equal<Unbox<() => Promise<() => Array<Promise<boolean>>>>, boolean>>,

  // Bonus: Recursion levels
  Expect<Equal<Unbox<() => () => () => () => number, 0>, number>>,
  Expect<Equal<Unbox<() => () => () => () => number, 1>, () => () => () => number>>,
  Expect<Equal<Unbox<() => () => () => () => number, 2>, () => () => number>>,
  Expect<Equal<Unbox<() => () => () => () => number, 3>, () => number>>,
  Expect<Equal<Unbox<() => () => () => () => number, 4>, number>>,
  Expect<Equal<Unbox<() => () => () => () => number, 5>, number>>,
  Expect<Equal<Unbox<number[][][][], 0>, number>>,
  Expect<Equal<Unbox<number[][][][], 1>, number[][][]>>,
  Expect<Equal<Unbox<number[][][][], 2>, number[][]>>,
  Expect<Equal<Unbox<number[][][][], 3>, number[]>>,
  Expect<Equal<Unbox<number[][][][], 4>, number>>,
  Expect<Equal<Unbox<number[][][][], 5>, number>>,
  Expect<Equal<Unbox<[[[[number]]]], 0>, number>>,
  Expect<Equal<Unbox<[[[[number]]]], 1>, [[[number]]]>>,
  Expect<Equal<Unbox<[[[[number]]]], 2>, [[number]]>>,
  Expect<Equal<Unbox<[[[[number]]]], 3>, [number]>>,
  Expect<Equal<Unbox<[[[[number]]]], 4>, number>>,
  Expect<Equal<Unbox<[[[[number]]]], 5>, number>>,
  Expect<Equal<Unbox<Promise<Promise<Promise<number>>>, 0>, number>>,
  Expect<Equal<Unbox<Promise<Promise<Promise<number>>>, 1>, Promise<Promise<number>>>>,
  Expect<Equal<Unbox<Promise<Promise<Promise<number>>>, 2>, Promise<number>>>,
  Expect<Equal<Unbox<Promise<Promise<Promise<number>>>, 3>, number>>,
  Expect<Equal<Unbox<Promise<Promise<Promise<number>>>, 4>, number>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Union-to-Intersection/index.md
---
# Union to Intersection
## 题目

实现高级工具类型 `UnionToIntersection<U>`

例如

```ts
type I = UnionToIntersection<'foo' | 42 | true> // expected to be 'foo' & 42 & true
```

## 解题思路

待补充

## 答案

```ts
type UnionToIntersection<U> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<UnionToIntersection<'foo' | 42 | true>, 'foo' & 42 & true>>,
  Expect<Equal<UnionToIntersection<(() => 'foo') | ((i: 42) => true)>, (() => 'foo') & ((i: 42) => true)>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Union-to-Object-from-key/index.md
---
# Union to Object from key
## 题目

Find the object containing the key in the union type by the key. It  takes two parameters: a union of object types and a key name.

## 解题思路

待补充

## 答案

```ts
type UnionToObjectFromKey<Union, Key> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface Foo {
  foo: string
  common: boolean
}

interface Bar {
  bar: number
  common: boolean
}

interface Other {
  other: string
}

type cases = [
  Expect<Equal<UnionToObjectFromKey<Foo | Bar, 'foo'>, Foo>>,
  Expect<Equal<UnionToObjectFromKey<Foo | Bar, 'common'>, {
    foo: string
    common: boolean
  } | {
    bar: number
    common: boolean
  }>>,
  Expect<Equal<UnionToObjectFromKey<Foo | Bar | Other, 'common'>, {
    foo: string
    common: boolean
  } | {
    bar: number
    common: boolean
  }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Union-to-Tuple/index.md
---
# Union to Tuple
## 题目

Implement a type, `UnionToTuple`, that converts a union to a tuple.

As we know, union is an unordered structure, but tuple is an ordered, which implies that we are not supposed to preassume any order will be preserved between terms of one union, when unions are created or transformed.

Hence in this challenge, **any permutation of the elements in the output tuple is acceptable**.

Your type should resolve to one of the following two types, but ***NOT*** a union of them!

```ts
UnionToTuple<1> // [1], and correct
UnionToTuple<'any' | 'a'> // ['any','a'], and correct
```

or

```ts
UnionToTuple<'any' | 'a'> // ['a','any'], and correct
```

It shouldn't be a union of all acceptable tuples...

```ts
UnionToTuple<'any' | 'a'> // ['a','any'] | ['any','a'], which is incorrect
```

And a union could collapes, which means some types could absorb (or be absorbed by) others and there is no way to prevent this absorption. See the following examples:

```ts
Equal<UnionToTuple<any | 'a'>, UnionToTuple<any>> // will always be a true
Equal<UnionToTuple<unknown | 'a'>, UnionToTuple<unknown>> // will always be a true
Equal<UnionToTuple<never | 'a'>, UnionToTuple<'a'>> // will always be a true
Equal<UnionToTuple<'a' | 'a' | 'a'>, UnionToTuple<'a'>> // will always be a true
```

## 解题思路

待补充

## 答案

```ts
type UnionToTuple<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type ExtractValuesOfTuple<T extends any[]> = T[keyof T & number]

type cases = [
  Expect<Equal<UnionToTuple<'a' | 'b'>['length'], 2>>,
  Expect<Equal<ExtractValuesOfTuple<UnionToTuple<'a' | 'b'>>, 'a' | 'b'>>,
  Expect<Equal<ExtractValuesOfTuple<UnionToTuple<'a'>>, 'a'>>,
  Expect<Equal<ExtractValuesOfTuple<UnionToTuple<any>>, any>>,
  Expect<Equal<ExtractValuesOfTuple<UnionToTuple<undefined | void | 1>>, void | 1>>,
  Expect<Equal<ExtractValuesOfTuple<UnionToTuple<any | 1>>, any | 1>>,
  Expect<Equal<ExtractValuesOfTuple<UnionToTuple<any | 1>>, any>>,
  Expect<Equal<ExtractValuesOfTuple<UnionToTuple<'d' | 'f' | 1 | never>>, 'f' | 'd' | 1>>,
  Expect<Equal<ExtractValuesOfTuple<UnionToTuple<[{ a: 1 }] | 1>>, [{ a: 1 }] | 1>>,
  Expect<Equal<ExtractValuesOfTuple<UnionToTuple<never>>, never>>,
  Expect<Equal<ExtractValuesOfTuple<UnionToTuple<'a' | 'b' | 'c' | 1 | 2 | 'd' | 'e' | 'f' | 'g'>>, 'f' | 'e' | 1 | 2 | 'g' | 'c' | 'd' | 'a' | 'b'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Unique-Items/index.md
---
# Unique Items
## 题目

Some concepts in TypeScript can not be described by types, but can be expressed through type constraints. For example, you can't define a type for positive numbers, but you can check whether a number literal type is positive. One of the patterns for applying such constraints is constrained identity function (CIF). A CIF takes one parameter, infers its type, performs additional checks and returns the parameter unmodified.

```ts
// Ensures `n` is a positive number
function positive<const N extends number>(n: `${N}` extends `-${string}` ? never : N) {
  return n
}

const a = positive(1) // Ok
const b = positive(-1) // Error, -1 is not assignable to never
```

Write a CIF `uniqueItems` that takes a tuple of literals and ensures that all of them are unique.
You are free to use either mutable or readonly tuples.

Bonus task: Helpful error messages instead of `not assignable to never`.
Bonus task: Only repeating tuple elements should be treated as errors, not the entire argument.

## 解题思路

待补充

## 答案

```ts
function uniqueItems(items: any[]) {
  return items
}
```

## 验证

```ts
import type { Equal } from '@type-challenges/utils'

declare const readonlyEqual: <A>() => <T>(value: T) => Equal<Readonly<A>, Readonly<T>>
declare const expect: (value: true) => void

// Should work
expect(readonlyEqual<[1, 2, 3]>()(uniqueItems([1, 2, 3])))
expect(readonlyEqual<['a', 'b', 'c']>()(uniqueItems(['a', 'b', 'c'])))
expect(readonlyEqual<[1, 'a', true]>()(uniqueItems([1, 'a', true])))
expect(readonlyEqual<[undefined, null, 3, false]>()(uniqueItems([undefined, null, 3, false])))

// Should error
// @ts-expect-error
uniqueItems([1, 2, 2, 3, 4, 4, 5, 6])
// @ts-expect-error
uniqueItems([true, true, false, false, 'b', 'b'])
// @ts-expect-error
uniqueItems([1, 1])
// @ts-expect-error
uniqueItems([undefined, undefined])
// @ts-expect-error
uniqueItems([null, undefined, null])
// @ts-expect-error
uniqueItems(['test', undefined, 'test'])

// Bonus: Should give detailed errors
uniqueItems([
  1,
  2,
  // @ts-expect-error
  2,
  3,
  4,
  // @ts-expect-error
  4,
  6,
  7,
])

uniqueItems([
  true,
  // @ts-expect-error
  true,
  false,
  // @ts-expect-error
  false,
  'b',
  // @ts-expect-error
  'b',
])
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Valid-Sudoku/index.md
---
# Valid Sudoku
## 题目

Sudoku is a famous paper and pencil game. The goal of Sudoku is to fill a 9x9 grid with numbers so that each row, column and 3x3 section contain all of the digits between 1 and 9. You'll be given a finished 9x9 grid, and you need to determine if it's a valid Sudoku solution. Return true if it is, and false if it is not.

```ts
type Matrix = [
  [9, 5, 7, 8, 4, 6, 1, 3, 2],
  [2, 3, 4, 5, 9, 1, 6, 7, 8],
  [1, 8, 6, 7, 3, 2, 5, 4, 9],
  [8, 9, 1, 6, 2, 3, 4, 5, 7],
  [3, 4, 5, 9, 7, 8, 2, 6, 1],
  [6, 7, 2, 1, 5, 4, 8, 9, 3],
  [4, 6, 8, 3, 1, 9, 7, 2, 5],
  [5, 2, 3, 4, 8, 7, 9, 1, 6],
  [7, 1, 9, 2, 6, 5, 3, 8, 4]
]
type result = ValidSudoku <Matrix> // expected to be true
```

## 解题思路

待补充

## 答案

```ts
type ValidSudoku<M extends number[][]> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type Matrix0 = [
  [9, 5, 7, 8, 4, 6, 1, 3, 2],
  [2, 3, 4, 5, 9, 1, 6, 7, 8],
  [1, 8, 6, 7, 3, 2, 5, 4, 9],
  [8, 9, 1, 6, 2, 3, 4, 5, 7],
  [3, 4, 5, 9, 7, 8, 2, 6, 1],
  [6, 7, 2, 1, 5, 4, 8, 9, 3],
  [4, 6, 8, 3, 1, 9, 7, 2, 5],
  [5, 2, 3, 4, 8, 7, 9, 1, 6],
  [7, 1, 9, 2, 6, 5, 3, 8, 4],
]

type Matrix1 = [
  [8, 3, 6, 9, 5, 1, 7, 4, 2],
  [4, 7, 5, 2, 6, 3, 1, 8, 9],
  [2, 1, 9, 7, 4, 8, 6, 3, 5],
  [7, 6, 2, 8, 3, 5, 9, 1, 4],
  [5, 9, 4, 1, 7, 6, 8, 2, 3],
  [3, 8, 1, 4, 2, 9, 5, 7, 6],
  [9, 4, 3, 6, 8, 7, 2, 5, 1],
  [6, 5, 8, 3, 1, 2, 4, 9, 7],
  [1, 2, 7, 5, 9, 4, 3, 6, 8],
]

type Matrix2 = [
  [8, 3, 6, 9, 5, 1, 7, 4, 2],
  [4, 7, 5, 2, 6, 3, 1, 8, 9],
  [2, 1, 9, 7, 4, 8, 6, 3, 5],
  [7, 6, 2, 8, 3, 5, 9, 1, 4],
  [5, 9, 4, 1, 6, 7, 8, 2, 3],
  [3, 8, 1, 4, 2, 9, 5, 7, 6],
  [9, 4, 3, 6, 8, 7, 2, 5, 1],
  [6, 5, 8, 3, 1, 2, 4, 9, 7],
  [1, 2, 7, 5, 9, 4, 3, 6, 8],
]

type Matrix3 = [
  [1, 2, 3, 4, 5, 6, 7, 8, 9],
  [2, 3, 4, 5, 6, 7, 8, 9, 1],
  [3, 4, 5, 6, 7, 8, 9, 1, 2],
  [4, 5, 6, 7, 8, 9, 1, 2, 3],
  [5, 6, 7, 8, 9, 1, 2, 3, 4],
  [6, 7, 8, 9, 1, 2, 3, 4, 5],
  [7, 8, 9, 1, 2, 3, 4, 5, 6],
  [8, 9, 1, 2, 3, 4, 5, 6, 7],
  [9, 1, 2, 3, 4, 5, 6, 7, 8],
]

type cases = [
  Expect<Equal<ValidSudoku<Matrix0>, true>>,
  Expect<Equal<ValidSudoku<Matrix1>, true>>,
  Expect<Equal<ValidSudoku<Matrix2>, false>>,
  Expect<Equal<ValidSudoku<Matrix3>, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/ValidDate/index.md
---
# ValidDate
## 题目

Implement a type `ValidDate`, which takes an input type T and returns whether T is a valid date.

**Leap year is not considered**

Good Luck!

```ts
ValidDate<'0102'> // true
ValidDate<'0131'> // true
ValidDate<'1231'> // true
ValidDate<'0229'> // false
ValidDate<'0100'> // false
ValidDate<'0132'> // false
ValidDate<'1301'> // false
```

## 解题思路

待补充

## 答案

```ts
type ValidDate<T extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<ValidDate<'0102'>, true>>,
  Expect<Equal<ValidDate<'0131'>, true>>,
  Expect<Equal<ValidDate<'1231'>, true>>,
  Expect<Equal<ValidDate<'0229'>, false>>,
  Expect<Equal<ValidDate<'0100'>, false>>,
  Expect<Equal<ValidDate<'0132'>, false>>,
  Expect<Equal<ValidDate<'1301'>, false>>,
  Expect<Equal<ValidDate<'0123'>, true>>,
  Expect<Equal<ValidDate<'0430'>, true>>,
  Expect<Equal<ValidDate<'01234'>, false>>,
  Expect<Equal<ValidDate<''>, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/hard/Vue-Basic-Props/index.md
---
# Vue Basic Props
## 题目

**This challenge continues from [6 - Simple Vue](//tsch.js.org/6), you should finish that one first, and modify your code based on it to start this challenge**.

In addition to the Simple Vue, we are now having a new `props` field in the options. This is a simplified version of Vue's `props` option. Here are some of the rules.

`props` is an object containing each field as the key of the real props injected into `this`. The injected props will be accessible in all the context including `data`, `computed`, and `methods`.

A prop will be defined either by a constructor or an object with a `type` field containing constructor(s).

For example

```js
props: {
  foo: Boolean
}
// or
props: {
  foo: { type: Boolean }
}
```

should be inferred to `type Props = { foo: boolean }`.

When passing multiple constructors, the type should be inferred to a union.

```ts
props: {
  foo: { type: [Boolean, Number, String] }
}
// -->
interface Props { foo: boolean | number | string }
```

When an empty object is passed, the key should be inferred to `any`.

For more specified cases, check out the Test Cases section.

> `required`, `default`, and array props in Vue are not considered in this challenge.

## 解题思路

待补充

## 答案

```ts
declare function VueBasicProps(options: any): any
```

## 验证

```ts
import type { Debug, Equal, Expect, IsAny } from '@type-challenges/utils'

class ClassA {}

VueBasicProps({
  props: {
    propA: {},
    propB: { type: String },
    propC: { type: Boolean },
    propD: { type: ClassA },
    propE: { type: [String, Number] },
    propF: RegExp,
  },
  data(this) {
    type PropsType = Debug<typeof this>
    type cases = [
      Expect<IsAny<PropsType['propA']>>,
      Expect<Equal<PropsType['propB'], string>>,
      Expect<Equal<PropsType['propC'], boolean>>,
      Expect<Equal<PropsType['propD'], ClassA>>,
      Expect<Equal<PropsType['propE'], string | number>>,
      Expect<Equal<PropsType['propF'], RegExp>>,
    ]

    // @ts-expect-error
    this.firstname
    // @ts-expect-error
    this.getRandom()
    // @ts-expect-error
    this.data()

    return {
      firstname: 'Type',
      lastname: 'Challenges',
      amount: 10,
    }
  },
  computed: {
    fullname() {
      return `${this.firstname} ${this.lastname}`
    },
  },
  methods: {
    getRandom() {
      return Math.random()
    },
    hi() {
      alert(this.fullname.toLowerCase())
      alert(this.getRandom())
    },
    test() {
      const fullname = this.fullname
      const propE = this.propE
      type cases = [
        Expect<Equal<typeof fullname, string>>,
        Expect<Equal<typeof propE, string | number>>,
      ]
    },
  },
})
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Absolute/index.md
---
# Absolute
## 题目

实现一个接收string,number或bigInt类型参数的`Absolute`类型,返回一个正数字符串。

例如

```ts
type Test = -100
type Result = Absolute<Test> // expected to be "100"
```

## 解题思路

利用模板字符串会把数字转成十进制字符串的原理，匹配第一个字符是否为 `-`，取其数字部分即可。

## 答案

```ts
type Absolute<T extends number | string | bigint> = `${T}` extends `${infer F}${infer R}`
  ? (F extends '-' ? R : `${F}${R}`)
  : ''
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type Absolute<T extends number | string | bigint> = `${T}` extends `${infer F}${infer R}`
  ? (F extends '-' ? R : `${F}${R}`)
  : ''
// ---cut---
type cases = [
  Expect<Equal<Absolute<0>, '0'>>,
  Expect<Equal<Absolute<-0>, '0'>>,
  Expect<Equal<Absolute<10>, '10'>>,
  Expect<Equal<Absolute<-5>, '5'>>,
  Expect<Equal<Absolute<'0'>, '0'>>,
  Expect<Equal<Absolute<'-0'>, '0'>>,
  Expect<Equal<Absolute<'10'>, '10'>>,
  Expect<Equal<Absolute<'-5'>, '5'>>,
  Expect<Equal<Absolute<-1_000_000n>, '1000000'>>,
  Expect<Equal<Absolute<9_999n>, '9999'>>,
]
```

## 参考

* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /TypeGymnastics/medium/All/index.md
---
# All
## 题目

如果传入的第一个参数中所有元素都等于传入的第二个参数，则返回 true；如果有不匹配，则返回 false。

例如：

```ts
type Test1 = [1, 1, 1]
type Test2 = [1, 1, 2]

type Todo = All<Test1, 1> // 应与 true 相同
type Todo2 = All<Test2, 1> // 应与 false 相同
```

## 解题思路

从第一项开始比对至结束，若有不相等的即返回 `false`。

## 答案

```ts
type All<T extends any[], U> = T extends [infer First, ...infer Rest]
  ? Equal<First, U> extends true
    ? All<Rest, U>
    : false
  : true
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type All<T extends any[], U> = T extends [infer First, ...infer Rest]
  ? Equal<First, U> extends true
    ? All<Rest, U>
    : false
  : true
// ---cut---
type cases = [
  Expect<Equal<All<[1, 1, 1], 1>, true>>,
  Expect<Equal<All<[1, 1, 2], 1>, false>>,
  Expect<Equal<All<['1', '1', '1'], '1'>, true>>,
  Expect<Equal<All<['1', '1', '1'], 1>, false>>,
  Expect<Equal<All<[number, number, number], number>, true>>,
  Expect<Equal<All<[number, number, string], number>, false>>,
  Expect<Equal<All<[null, null, null], null>, true>>,
  Expect<Equal<All<[[1], [1], [1]], [1]>, true>>,
  Expect<Equal<All<[{}, {}, {}], {}>, true>>,
  Expect<Equal<All<[never], never>, true>>,
  Expect<Equal<All<[any], any>, true>>,
  Expect<Equal<All<[unknown], unknown>, true>>,
  Expect<Equal<All<[any], unknown>, false>>,
  Expect<Equal<All<[unknown], any>, false>>,
  Expect<Equal<All<[1, 1, 2], 1 | 2>, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/AllCombinations/index.md
---
# AllCombinations
## 题目

Implement type `AllCombinations<S>` that return all combinations of strings which use characters from `S` at most once.

For example:

```ts
type AllCombinations_ABC = AllCombinations<'ABC'>
// should be '' | 'A' | 'B' | 'C' | 'AB' | 'AC' | 'BA' | 'BC' | 'CA' | 'CB' | 'ABC' | 'ACB' | 'BAC' | 'BCA' | 'CAB' | 'CBA'
```

## 解题思路

首先，看结果我们需要一个联合类型，那么我们可以通过分离联合类型并递归来实现。

先实现一个字符串转联合类型的工具类型 `StringToUnion<S>`，注意这里会返回空字符串 ''。

```ts twoslash
type StringToUnion<S> = S extends `${infer F}${infer R}` ? F | StringToUnion<R> : S
type Test = StringToUnion<'ABC'>
```

我们需要在递归中保存联合类型，因此需要添加一个参数 `T`，默认值为 `StringToUnion<S>`。我们还需要将联合类型分离，因而再添加一个参数 `U`，默认值为 `T`。

递归体内，我们需要每次将用到的 `U` 从 `T` 中删去，我们可以用 `Exclude` 类型：

```ts twoslash
type StringToUnion<S> = S extends `${infer F}${infer R}` ? F | StringToUnion<R> : S
// ---cut---
// @errors: 2589
type AllCombinations<
  S extends string,
  T extends string = StringToUnion<S>,
  U extends string = T,
> = U extends U ? `${U}${AllCombinations<S, Exclude<T, U>>}` : never
type Test = AllCombinations<'ABC'>
```

现在这段代码无论传什么都会返回 `never`，因为最后联合类型 `T` 中的所有类型都被删去了，但我们的逻辑是正确的，现在就保持这样。

接下来我们考虑空字符串 `''`，我们可以将 `''`，`'A'`，`'AB'` 这样的结果视作字母与多个空字符串传的组合，换言之，空字符串在排列组合中可以出现多次。

如何做到呢？如果 `U` 为空字符串 `''`，那么就不从 `T` 中将其删去，将它保留到一下次递归即可：

```ts twoslash
type StringToUnion<S> = S extends `${infer F}${infer R}` ? F | StringToUnion<R> : S
// ---cut---
// @errors: 2589
type AllCombinations<
  S extends string,
  T extends string = StringToUnion<S>,
  U extends string = T,
> = U extends U ? `${U}${AllCombinations<S, U extends '' ? T : Exclude<T, U>>}` : never
type Test = AllCombinations<'ABC'>
```

最后，我们需要想想怎么让我们的的类型跳出递归。现在，由于空字符串不会被从 `T` 中删去，这段代码会无限递归，而且，我们也无法通过 `T` 来判断是否应当跳出递归。那么我们还能通过什么来判断呢？

那就是 `S` 的长度。我们可以每次递归从 `S` 中删去一个字符，再在递归前对其进行非空判断即可。

## 答案

```ts
type StringToUnion<S> = S extends `${infer F}${infer R}` ? F | StringToUnion<R> : S
type AllCombinations<
  S extends string,
  T extends string = StringToUnion<S>,
  U extends string = T,
> = S extends `${infer F}${infer R}`
  ? U extends U
    ? `${U}${AllCombinations<R, U extends '' ? T : Exclude<T, U>>}`
    : never
  : ''
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type StringToUnion<S> = S extends `${infer F}${infer R}` ? F | StringToUnion<R> : S
type AllCombinations<
  S extends string,
  T extends string = StringToUnion<S>,
  U extends string = T,
> = S extends `${infer F}${infer R}`
  ? U extends U
    ? `${U}${AllCombinations<R, U extends '' ? T : Exclude<T, U>>}`
    : never
  : ''
// ---cut---
type cases = [
  Expect<Equal<AllCombinations<''>, ''>>,
  Expect<Equal<AllCombinations<'A'>, '' | 'A'>>,
  Expect<Equal<AllCombinations<'AB'>, '' | 'A' | 'B' | 'AB' | 'BA'>>,
  Expect<Equal<AllCombinations<'ABC'>, '' | 'A' | 'B' | 'C' | 'AB' | 'AC' | 'BA' | 'BC' | 'CA' | 'CB' | 'ABC' | 'ACB' | 'BAC' | 'BCA' | 'CAB' | 'CBA'>>,
  Expect<Equal<AllCombinations<'ABCD'>, '' | 'A' | 'B' | 'C' | 'D' | 'AB' | 'AC' | 'AD' | 'BA' | 'BC' | 'BD' | 'CA' | 'CB' | 'CD' | 'DA' | 'DB' | 'DC' | 'ABC' | 'ABD' | 'ACB' | 'ACD' | 'ADB' | 'ADC' | 'BAC' | 'BAD' | 'BCA' | 'BCD' | 'BDA' | 'BDC' | 'CAB' | 'CAD' | 'CBA' | 'CBD' | 'CDA' | 'CDB' | 'DAB' | 'DAC' | 'DBA' | 'DBC' | 'DCA' | 'DCB' | 'ABCD' | 'ABDC' | 'ACBD' | 'ACDB' | 'ADBC' | 'ADCB' | 'BACD' | 'BADC' | 'BCAD' | 'BCDA' | 'BDAC' | 'BDCA' | 'CABD' | 'CADB' | 'CBAD' | 'CBDA' | 'CDAB' | 'CDBA' | 'DABC' | 'DACB' | 'DBAC' | 'DBCA' | 'DCAB' | 'DCBA'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/AnyOf/index.md
---
# AnyOf
## 题目

在类型系统中实现类似于 Python 中 `any` 函数。类型接收一个数组，如果数组中任一个元素为真，则返回 `true`，否则返回 `false`。如果数组为空，返回 `false`。

例如：

```ts
type Sample1 = AnyOf<[1, '', false, [], {}]> // expected to be true.
type Sample2 = AnyOf<[0, '', false, [], {}]> // expected to be false.
```

## 解题思路

把所有为 `false` 的类型列举出来依次比较即可。

> `Record<string, never>` 常用于构建只包含属性名称而不包含属性值的对象，即 `{ [k: string]: never }`

## 答案

```ts
type Falsely = 0 | '' | false | undefined | null | [] | Record<string, never>
type AnyOf<T extends readonly any[]> = T[number] extends Falsely ? false : true
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type Falsely = 0 | '' | false | undefined | null | [] | Record<string, never>
type AnyOf<T extends readonly any[]> = T[number] extends Falsely ? false : true
// ---cut---
type cases = [
  Expect<Equal<AnyOf<[1, 'test', true, [1], { name: 'test' }, { 1: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[1, '', false, [], {}]>, true>>,
  Expect<Equal<AnyOf<[0, 'test', false, [], {}]>, true>>,
  Expect<Equal<AnyOf<[0, '', true, [], {}]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [1], {}]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], { name: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], { 1: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], { name: 'test' }, { 1: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], {}, undefined, null]>, false>>,
  Expect<Equal<AnyOf<[]>, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Appear-only-once/index.md
---
# Appear only once
## 题目

找出目标数组中只出现过一次的元素。例如：输入\[1,2,2,3,3,4,5,6,6,6]，输出\[1,4,5]

## 解题思路

待补充

## 答案

```ts
type FindEles<T extends any[]> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<FindEles<[1, 2, 2, 3, 3, 4, 5, 6, 6, 6]>, [1, 4, 5]>>,
  Expect<Equal<FindEles<[2, 2, 3, 3, 6, 6, 6]>, []>>,
  Expect<Equal<FindEles<[1, 2, 3]>, [1, 2, 3]>>,
  Expect<Equal<FindEles<[1, 2, number]>, [1, 2, number]>>,
  Expect<Equal<FindEles<[1, 2, number, number]>, [1, 2]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Append-Argument/index.md
---
# Append Argument
## 题目

> 由 @antfu 翻译

实现一个泛型 `AppendArgument<Fn, A>`，对于给定的函数类型 `Fn`，以及一个任意类型 `A`，返回一个新的函数 `G`。`G` 拥有 `Fn` 的所有参数并在末尾追加类型为 `A` 的参数。

```typescript
type Fn = (a: number, b: string) => number

type Result = AppendArgument<Fn, boolean>
// 期望是 (a: number, b: string, x: boolean) => number
```

> 本挑战来自于 [@maciejsikora](https://github.com/maciejsikora) 在 Dev.io 上的[文章](https://dev.to/macsikora/advanced-typescript-exercises-question-4-495c)

## 解题思路

待补充

## 答案

```ts
type AppendArgument<Fn, A> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type Case1 = AppendArgument<(a: number, b: string) => number, boolean>
type Result1 = (a: number, b: string, x: boolean) => number

type Case2 = AppendArgument<() => void, undefined>
type Result2 = (x: undefined) => void

type cases = [
  Expect<Equal<Case1, Result1>>,
  Expect<Equal<Case2, Result2>>,
  // @ts-expect-error
  AppendArgument<unknown, undefined>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Append-to-object/index.md
---
# Append to object
## 题目

实现一个为接口添加一个新字段的类型。该类型接收三个参数，返回带有新字段的接口类型。

例如:

```ts
interface Test { id: '1' }
type Result = AppendToObject<Test, 'value', 4> // expected to be { id: '1', value: 4 }
```

## 解题思路

待补充

## 答案

```ts
type AppendToObject<T, U, V> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface test1 {
  key: 'cat'
  value: 'green'
}

interface testExpect1 {
  key: 'cat'
  value: 'green'
  home: boolean
}

interface test2 {
  key: 'dog' | undefined
  value: 'white'
  sun: true
}

interface testExpect2 {
  key: 'dog' | undefined
  value: 'white'
  sun: true
  home: 1
}

interface test3 {
  key: 'cow'
  value: 'yellow'
  sun: false
}

interface testExpect3 {
  key: 'cow'
  value: 'yellow'
  sun: false
  moon: false | undefined
}

type cases = [
  Expect<Equal<AppendToObject<test1, 'home', boolean>, testExpect1>>,
  Expect<Equal<AppendToObject<test2, 'home', 1>, testExpect2>>,
  Expect<Equal<AppendToObject<test3, 'moon', false | undefined>, testExpect3>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/BEM-style-string/index.md
---
# BEM style string
## 题目

The Block, Element, Modifier methodology (BEM) is a popular naming convention for classes in CSS.

For example, the block component would be represented as `btn`, element that depends upon the block would be represented as `btn__price`, modifier that changes the style of the block would be represented as `btn--big` or `btn__price--warning`.

Implement `BEM<B, E, M>` which generate string union from these three parameters. Where `B` is a string literal, `E` and `M` are string arrays (can be empty).

## 解题思路

待补充

## 答案

```ts
type BEM<B extends string, E extends string[], M extends string[]> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<BEM<'btn', ['price'], []>, 'btn__price'>>,
  Expect<Equal<BEM<'btn', ['price'], ['warning', 'success']>, 'btn__price--warning' | 'btn__price--success'>>,
  Expect<Equal<BEM<'btn', [], ['small', 'medium', 'large']>, 'btn--small' | 'btn--medium' | 'btn--large'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Capitalize/index.md
---
# Capitalize
## 题目

实现 `Capitalize<T>` 它将字符串的第一个字母转换为大写，其余字母保持原样。

例如

```ts
type capitalized = Capitalize<'hello world'> // expected to be 'Hello world'
```

## 解题思路

待补充

## 答案

```ts
type MyCapitalize<S extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<MyCapitalize<'foobar'>, 'Foobar'>>,
  Expect<Equal<MyCapitalize<'FOOBAR'>, 'FOOBAR'>>,
  Expect<Equal<MyCapitalize<'foo bar'>, 'Foo bar'>>,
  Expect<Equal<MyCapitalize<''>, ''>>,
  Expect<Equal<MyCapitalize<'a'>, 'A'>>,
  Expect<Equal<MyCapitalize<'b'>, 'B'>>,
  Expect<Equal<MyCapitalize<'c'>, 'C'>>,
  Expect<Equal<MyCapitalize<'d'>, 'D'>>,
  Expect<Equal<MyCapitalize<'e'>, 'E'>>,
  Expect<Equal<MyCapitalize<'f'>, 'F'>>,
  Expect<Equal<MyCapitalize<'g'>, 'G'>>,
  Expect<Equal<MyCapitalize<'h'>, 'H'>>,
  Expect<Equal<MyCapitalize<'i'>, 'I'>>,
  Expect<Equal<MyCapitalize<'j'>, 'J'>>,
  Expect<Equal<MyCapitalize<'k'>, 'K'>>,
  Expect<Equal<MyCapitalize<'l'>, 'L'>>,
  Expect<Equal<MyCapitalize<'m'>, 'M'>>,
  Expect<Equal<MyCapitalize<'n'>, 'N'>>,
  Expect<Equal<MyCapitalize<'o'>, 'O'>>,
  Expect<Equal<MyCapitalize<'p'>, 'P'>>,
  Expect<Equal<MyCapitalize<'q'>, 'Q'>>,
  Expect<Equal<MyCapitalize<'r'>, 'R'>>,
  Expect<Equal<MyCapitalize<'s'>, 'S'>>,
  Expect<Equal<MyCapitalize<'t'>, 'T'>>,
  Expect<Equal<MyCapitalize<'u'>, 'U'>>,
  Expect<Equal<MyCapitalize<'v'>, 'V'>>,
  Expect<Equal<MyCapitalize<'w'>, 'W'>>,
  Expect<Equal<MyCapitalize<'x'>, 'X'>>,
  Expect<Equal<MyCapitalize<'y'>, 'Y'>>,
  Expect<Equal<MyCapitalize<'z'>, 'Z'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/CartesianProduct/index.md
---
# CartesianProduct
## 题目

Given 2 sets (unions), return its Cartesian product in a set of tuples, e.g.

```ts
CartesianProduct<1 | 2, 'a' | 'b'>
// [1, 'a'] | [2, 'a'] | [1, 'b'] | [2, 'b']
```

## 解题思路

待补充

## 答案

```ts
type CartesianProduct<T, U> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<CartesianProduct<1 | 2, 'a' | 'b'>, [2, 'a'] | [1, 'a'] | [2, 'b'] | [1, 'b']>>,
  Expect<Equal<CartesianProduct<1 | 2 | 3, 'a' | 'b' | 'c'>, [2, 'a'] | [1, 'a'] | [3, 'a'] | [2, 'b'] | [1, 'b'] | [3, 'b'] | [2, 'c'] | [1, 'c'] | [3, 'c']>>,
  Expect<Equal<CartesianProduct<1 | 2, 'a' | never>, [2, 'a'] | [1, 'a']>>,
  Expect<Equal<CartesianProduct<'a', Function | string>, ['a', Function] | ['a', string]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Chainable-Options/index.md
---
# Chainable Options
## 题目

在 JavaScript 中我们经常会使用可串联（Chainable/Pipeline）的函数构造一个对象，但在 TypeScript 中，你能合理的给它赋上类型吗？

在这个挑战中，你可以使用任意你喜欢的方式实现这个类型 - Interface, Type 或 Class 都行。你需要提供两个函数 `option(key, value)` 和 `get()`。在 `option` 中你需要使用提供的 key 和 value 扩展当前的对象类型，通过 `get` 获取最终结果。

例如

```ts
declare const config: Chainable

const result = config
  .option('foo', 123)
  .option('name', 'type-challenges')
  .option('bar', { value: 'Hello World' })
  .get()

// 期望 result 的类型是：
interface Result {
  foo: number
  name: string
  bar: {
    value: string
  }
}
```

你只需要在类型层面实现这个功能 - 不需要实现任何 TS/JS 的实际逻辑。

你可以假设 `key` 只接受字符串而 `value` 接受任何类型，你只需要暴露它传递的类型而不需要进行任何处理。同样的 `key` 只会被使用一次。

## 解题思路

待补充

## 答案

```ts
interface Chainable {
  option: (key: string, value: any) => any
  get: () => any
}
```

## 验证

```ts
import type { Alike, Expect } from '@type-challenges/utils'

declare const a: Chainable

const result1 = a
  .option('foo', 123)
  .option('bar', { value: 'Hello World' })
  .option('name', 'type-challenges')
  .get()

const result2 = a
  .option('name', 'another name')
  // @ts-expect-error
  .option('name', 'last name')
  .get()

const result3 = a
  .option('name', 'another name')
  // @ts-expect-error
  .option('name', 123)
  .get()

type cases = [
  Expect<Alike<typeof result1, Expected1>>,
  Expect<Alike<typeof result2, Expected2>>,
  Expect<Alike<typeof result3, Expected3>>,
]

interface Expected1 {
  foo: number
  bar: {
    value: string
  }
  name: string
}

interface Expected2 {
  name: string
}

interface Expected3 {
  name: number
}
```

## 参考

无

---

---
url: /TypeGymnastics/medium/CheckRepeatedChars/index.md
---
# CheckRepeatedChars
## 题目

判断一个string类型中是否有相同的字符

```ts
type CheckRepeatedChars<'abc'>   // false
type CheckRepeatedChars<'aba'>   // true
```

## 解题思路

待补充

## 答案

```ts
type CheckRepeatedChars<T extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<CheckRepeatedChars<'abc'>, false>>,
  Expect<Equal<CheckRepeatedChars<'abb'>, true>>,
  Expect<Equal<CheckRepeatedChars<'cbc'>, true>>,
  Expect<Equal<CheckRepeatedChars<''>, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/CheckRepeatedTuple/index.md
---
# CheckRepeatedTuple
## 题目

判断一个元组类型中是否有相同的成员

For example:

```ts
type CheckRepeatedTuple<[1, 2, 3]>   // false
type CheckRepeatedTuple<[1, 2, 1]>   // true
```

## 解题思路

待补充

## 答案

```ts
type CheckRepeatedTuple<T extends unknown[]> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<CheckRepeatedTuple<[number, number, string, boolean]>, true>>,
  Expect<Equal<CheckRepeatedTuple<[number, string]>, false>>,
  Expect<Equal<CheckRepeatedTuple<[1, 2, 3]>, false>>,
  Expect<Equal<CheckRepeatedTuple<[1, 2, 1]>, true>>,
  Expect<Equal<CheckRepeatedTuple<[]>, false>>,
  Expect<Equal<CheckRepeatedTuple<string[]>, false>>,
  Expect<Equal<CheckRepeatedTuple<[number, 1, string, '1', boolean, true, false, unknown, any]>, false>>,
  Expect<Equal<CheckRepeatedTuple<[never, any, never]>, true>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Chunk/index.md
---
# Chunk
## 题目

Do you know `lodash`? `Chunk` is a very useful function in it, now let's implement it.
`Chunk<T, N>` accepts two required type parameters, the `T` must be a `tuple`, and the `N` must be an `integer >=1`

```ts
type exp1 = Chunk<[1, 2, 3], 2> // expected to be [[1, 2], [3]]
type exp2 = Chunk<[1, 2, 3], 4> // expected to be [[1, 2, 3]]
type exp3 = Chunk<[1, 2, 3], 1> // expected to be [[1], [2], [3]]
```

## 解题思路

待补充

## 答案

```ts
type Chunk = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Chunk<[], 1>, []>>,
  Expect<Equal<Chunk<[1, 2, 3], 1>, [[1], [2], [3]]>>,
  Expect<Equal<Chunk<[1, 2, 3], 2>, [[1, 2], [3]]>>,
  Expect<Equal<Chunk<[1, 2, 3, 4], 2>, [[1, 2], [3, 4]]>>,
  Expect<Equal<Chunk<[1, 2, 3, 4], 5>, [[1, 2, 3, 4]]>>,
  Expect<Equal<Chunk<[1, true, 2, false], 2>, [[1, true], [2, false]]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Combination-key-type/index.md
---
# Combination key type
## 题目

1. 把多个修饰键两两组合，但不可以出现相同的修饰键组合。
2. 提供的 `ModifierKeys` 中，前面的值比后面的值高，即 `cmd ctrl` 是可以的，但 `ctrl cmd` 是不允许的。

## 解题思路

待补充

## 答案

```ts
// 实现 Combs
type Combs<T extends any[]> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type ModifierKeys = ['cmd', 'ctrl', 'opt', 'fn']
type CaseTypeOne = 'cmd ctrl' | 'cmd opt' | 'cmd fn' | 'ctrl opt' | 'ctrl fn' | 'opt fn'

type cases = [
  Expect<Equal<Combs<ModifierKeys>, CaseTypeOne>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Combination/index.md
---
# Combination
## 题目

Given an array of strings, do Permutation & Combination.
It's also useful for the prop types like video [controlsList](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/controlsList)

```ts
// expected to be `"foo" | "bar" | "baz" | "foo bar" | "foo bar baz" | "foo baz" | "foo baz bar" | "bar foo" | "bar foo baz" | "bar baz" | "bar baz foo" | "baz foo" | "baz foo bar" | "baz bar" | "baz bar foo"`
type Keys = Combination<['foo', 'bar', 'baz']>
```

## 解题思路

待补充

## 答案

```ts
type Combination<T extends string[]> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Combination<['foo', 'bar', 'baz']>, 'foo' | 'bar' | 'baz' | 'foo bar' | 'foo bar baz' | 'foo baz' | 'foo baz bar' | 'bar foo' | 'bar foo baz' | 'bar baz' | 'bar baz foo' | 'baz foo' | 'baz foo bar' | 'baz bar' | 'baz bar foo'>>,
  Expect<Equal<Combination<['apple', 'banana', 'cherry']>, 'apple' | 'banana' | 'cherry'
  | 'apple banana' | 'apple cherry' | 'banana apple' | 'banana cherry' | 'cherry apple' | 'cherry banana'
  | 'apple banana cherry' | 'apple cherry banana' | 'banana apple cherry' | 'banana cherry apple' | 'cherry apple banana' | 'cherry banana apple'>>,
  Expect<Equal<Combination<['red', 'green', 'blue', 'yellow']>, 'red' | 'green' | 'blue' | 'yellow'
  | 'red green' | 'red blue' | 'red yellow' | 'green red' | 'green blue' | 'green yellow' | 'blue red' | 'blue green' | 'blue yellow' | 'yellow red' | 'yellow green' | 'yellow blue'
  | 'red green blue' | 'red green yellow' | 'red blue green' | 'red blue yellow' | 'red yellow green' | 'red yellow blue'
  | 'green red blue' | 'green red yellow' | 'green blue red' | 'green blue yellow' | 'green yellow red' | 'green yellow blue'
  | 'blue red green' | 'blue red yellow' | 'blue green red' | 'blue green yellow' | 'blue yellow red' | 'blue yellow green'
  | 'yellow red green' | 'yellow red blue' | 'yellow green red' | 'yellow green blue' | 'yellow blue red' | 'yellow blue green'
  | 'red green blue yellow' | 'red green yellow blue' | 'red blue green yellow' | 'red blue yellow green' | 'red yellow green blue' | 'red yellow blue green'
  | 'green red blue yellow' | 'green red yellow blue' | 'green blue red yellow' | 'green blue yellow red' | 'green yellow red blue' | 'green yellow blue red'
  | 'blue red green yellow' | 'blue red yellow green' | 'blue green red yellow' | 'blue green yellow red' | 'blue yellow red green' | 'blue yellow green red'
  | 'yellow red green blue' | 'yellow red blue green' | 'yellow green red blue' | 'yellow green blue red' | 'yellow blue red green' | 'yellow blue green red'>>,
  Expect<Equal<Combination<['one', 'two']>, 'one' | 'two'
  | 'one two' | 'two one'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Compare-Array-Length/index.md
---
# Compare Array Length
## 题目

Implement `CompareArrayLength` to compare two array length(T & U).

If length of T array is greater than U, return 1;
If length of U array is greater than T, return -1;
If length of T array is equal to U, return 0.

## 解题思路

待补充

## 答案

```ts
type CompareArrayLength<T extends any[], U extends any[]> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<CompareArrayLength<[1, 2, 3, 4], [5, 6]>, 1>>,
  Expect<Equal<CompareArrayLength<[1, 2], [3, 4, 5, 6]>, -1>>,
  Expect<Equal<CompareArrayLength<[], []>, 0>>,
  Expect<Equal<CompareArrayLength<[1, 2, 3], [4, 5, 6]>, 0>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Construct-Tuple/index.md
---
# Construct Tuple
## 题目

构造一个给定长度的元组。

例如

```ts
type result = ConstructTuple<2> // 期望得到 [unknown, unknown]
```

## 解题思路

待补充

## 答案

```ts
type ConstructTuple<L extends number> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<ConstructTuple<0>, []>>,
  Expect<Equal<ConstructTuple<2>, [unknown, unknown]>>,
  Expect<Equal<ConstructTuple<999>['length'], 999>>,
  // @ts-expect-error
  Expect<Equal<ConstructTuple<1000>['length'], 1000>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Count-Element-Number-To-Object/index.md
---
# Count Element Number To Object
## 题目

通过实现一个`CountElementNumberToObject`方法，统计数组中相同元素的个数

```ts
type Simple1 = CountElementNumberToObject<[]> // return {}
type Simple2 = CountElementNumberToObject<[1, 2, 3, 4, 5]>
/*
 return {
  1: 1,
  2: 1,
  3: 1,
  4: 1,
  5: 1
}
*/
type Simple3 = CountElementNumberToObject<[1, 2, 3, 4, 5, [1, 2, 3]]>
/*
 return {
  1: 2,
  2: 2,
  3: 2,
  4: 1,
  5: 1
}
*/
```

## 解题思路

待补充

## 答案

```ts
type CountElementNumberToObject<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<CountElementNumberToObject<[1, 2, 3, 4, 5]>, {
    1: 1
    2: 1
    3: 1
    4: 1
    5: 1
  }>>,
  Expect<Equal<CountElementNumberToObject<[1, 2, 3, 4, 5, [1, 2, 3]]>, {
    1: 2
    2: 2
    3: 2
    4: 1
    5: 1
  }>>,
  Expect<Equal<CountElementNumberToObject<[1, 2, 3, 4, 5, [1, 2, 3, [4, 4, 1, 2]]]>, {
    1: 3
    2: 3
    3: 2
    4: 3
    5: 1
  }>>,
  Expect<Equal<CountElementNumberToObject<[never]>, {}>>,
  Expect<Equal<CountElementNumberToObject<['1', '2', '0']>, {
    0: 1
    1: 1
    2: 1
  }>>,
  Expect<Equal<CountElementNumberToObject<['a', 'b', ['c', ['d']]]>, {
    a: 1
    b: 1
    c: 1
    d: 1
  }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Deep-Omit/index.md
---
# Deep Omit
## 题目

Implement a type`DeepOmit`, Like Utility types [Omit](https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys), A type takes two arguments.

For example:

```ts
interface obj {
  person: {
    name: string
    age: {
      value: number
    }
  }
}

type test1 = DeepOmit<obj, 'person'> // {}
type test2 = DeepOmit<obj, 'person.name'> // { person: { age: { value: number } } }
type test3 = DeepOmit<obj, 'name'> // { person: { name: string; age: { value: number } } }
type test4 = DeepOmit<obj, 'person.age.value'> // { person: { name: string; age: {} } }
```

## 解题思路

待补充

## 答案

```ts
type DeepOmit = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface obj {
  person: {
    name: string
    age: {
      value: number
    }
  }
}

type cases = [
  Expect<Equal<DeepOmit<obj, 'person'>, {}>>,
  Expect<Equal<DeepOmit<obj, 'person.name'>, { person: { age: { value: number } } }>>,
  Expect<Equal<DeepOmit<obj, 'name'>, obj>>,
  Expect<Equal<DeepOmit<obj, 'person.age.value'>, { person: { name: string, age: {} } }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Deep-Readonly/index.md
---
# Deep Readonly
## 题目

实现一个泛型 `DeepReadonly<T>`，它将对象的每个参数及其子对象递归地设为只读。

您可以假设在此挑战中我们仅处理对象。不考虑数组、函数、类等。但是，您仍然可以通过覆盖尽可能多的不同案例来挑战自己。

例如

```ts
interface X {
  x: {
    a: 1
    b: 'hi'
  }
  y: 'hey'
}

interface Expected {
  readonly x: {
    readonly a: 1
    readonly b: 'hi'
  }
  readonly y: 'hey'
}

type Todo = DeepReadonly<X> // should be same as `Expected`
```

## 解题思路

待补充

## 答案

```ts
type DeepReadonly<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<DeepReadonly<X1>, Expected1>>,
  Expect<Equal<DeepReadonly<X2>, Expected2>>,
]

interface X1 {
  a: () => 22
  b: string
  c: {
    d: boolean
    e: {
      g: {
        h: {
          i: true
          j: 'string'
        }
        k: 'hello'
      }
      l: [
        'hi',
        {
          m: ['hey']
        },
      ]
    }
  }
}

type X2 = { a: string } | { b: number }

interface Expected1 {
  readonly a: () => 22
  readonly b: string
  readonly c: {
    readonly d: boolean
    readonly e: {
      readonly g: {
        readonly h: {
          readonly i: true
          readonly j: 'string'
        }
        readonly k: 'hello'
      }
      readonly l: readonly [
        'hi',
        {
          readonly m: readonly ['hey']
        },
      ]
    }
  }
}

type Expected2 = { readonly a: string } | { readonly b: number }
```

## 参考

无

---

---
url: /TypeGymnastics/medium/DeepMutable/index.md
---
# DeepMutable
## 题目

实现一个通用的 `DeepMutable<T> `，它使对象的每个属性，及其递归的子属性 - 可变。

例如：

```ts
interface X {
  readonly a: () => 1
  readonly b: string
  readonly c: {
    readonly d: boolean
    readonly e: {
      readonly g: {
        readonly h: {
          readonly i: true
          readonly j: 's'
        }
        readonly k: 'hello'
      }
    }
  }
}

interface Expected {
  a: () => 1
  b: string
  c: {
    d: boolean
    e: {
      g: {
        h: {
          i: true
          j: 's'
        }
        k: 'hello'
      }
    }
  }
}

type Todo = DeepMutable<X> // should be same as `Expected`
```

你可以假设我们在这个挑战中只处理对象。 数组、函数、类等不需要考虑。 但是，您仍然可以通过涵盖尽可能多的不同案例来挑战自己。

## 解题思路

待补充

## 答案

```ts
type DeepMutable = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface Test1 {
  readonly title: string
  readonly description: string
  readonly completed: boolean
  readonly meta: {
    readonly author: string
  }
}
interface Test2 {
  readonly a: () => 1
  readonly b: string
  readonly c: {
    readonly d: boolean
    readonly e: {
      readonly g: {
        readonly h: {
          readonly i: true
          readonly j: 's'
        }
        readonly k: 'hello'
      }
      readonly l: readonly [
        'hi',
        {
          readonly m: readonly ['hey']
        },
      ]
    }
  }
}
interface DeepMutableTest1 {
  title: string
  description: string
  completed: boolean
  meta: {
    author: string
  }
}

interface DeepMutableTest2 {
  a: () => 1
  b: string
  c: {
    d: boolean
    e: {
      g: {
        h: {
          i: true
          j: 's'
        }
        k: 'hello'
      }
      l: [
        'hi',
        {
          m: ['hey']
        },
      ]
    }
  }
}

type cases = [
  Expect<Equal<DeepMutable<Test1>, DeepMutableTest1>>,
  Expect<Equal<DeepMutable<Test2>, DeepMutableTest2>>,
]

type errors = [
  // @ts-expect-error
  DeepMutable<'string'>,
  // @ts-expect-error
  DeepMutable<0>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Defined-Partial-Record/index.md
---
# Defined Partial Record
## 题目

### Defined Partial Record

Using a Record with union types as keys doesn't allow you to make an object with only some of them

```ts
const record: Record<'a' | 'b' | 'c', number> = { a: 42, b: 10 }
// error: Property 'c' is missing in type '{ a: number; b: number; }'
// but required in type 'Record<"a" | "b" | "c", number>'
```

Using a Partial Record with union types as keys allows you to make an object without all union members, but makes all keys and values optional, potentially leaving them undefined

```ts
const partial: Partial<Record<'a' | 'b' | 'c', number>> = { a: 42 }
const partialType = typeof partial // { a?: number | undefined, b? : number | undefined, c? : number | undefined }
const operation = 0 + partial.a // error: 'partial.a' is possibly 'undefined'
const access = partial.c // possible, type doesn't know that there is no such key
```

You need to make a type that takes the best of both worlds, creates all combinations of all the types in the union, so using a key that exists in the object gives you a defined type, but using a key that exists in the union and not in the object throws an error

```ts
const best: DefinedPartial<Record<'a' | 'b' | 'c', number>> = { a: 42 }
const sum = 0 + best.a // 42
const error = best.b // error: property 'b' does not exist on type '{ a: number; }'
```

## 解题思路

待补充

## 答案

```ts
type DefinedPartial<T> = any
```

## 验证

```ts
import type { Equal, Expect, ExpectTrue, NotAny, NotEqual } from '@type-challenges/utils'

type A1 = Record<'a' | 'b', string>
type E1 = { a: string }
  | { b: string }
  | { a: string, b: string }
type D1 = DefinedPartial<A1>
type C1 = Expect<Equal<D1, E1>>

type A2 = Record<'a' | 'b' | 'c', string>
type E2 = { a: string }
  | { b: string }
  | { c: string }
  | { a: string, b: string }
  | { a: string, c: string }
  | { b: string, c: string }
  | { a: string, b: string, c: string }
type D2 = DefinedPartial<A2>
type C2 = Expect<Equal<D2, E2>>

type A3 = Record<'a', number>
interface E3 { a: number }
type D3 = DefinedPartial<A3>
type C3 = Expect<Equal<D3, E3>>

type A4 = Record<'a', number>
interface E4 { a: string }
type D4 = DefinedPartial<A4>
type C4 = ExpectTrue<NotAny<D4> | NotEqual<D4, E4>>

type A5 = Record<'a' | 'c', number>
interface E5 { a: string, b: string }
type D5 = DefinedPartial<A5>
type C5 = ExpectTrue<NotAny<D5> | NotEqual<D5, E5>>

interface A6 { a: string, b: string }
type E6 = { a: string }
  | { b: string }
  | { a: string, b: string }
type D6 = DefinedPartial<A6>
type C6 = Expect<Equal<D6, E6>>
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Diff/index.md
---
# Diff
## 题目

获取两个接口类型中的差值属性。

```ts
interface Foo {
  a: string
  b: number
}
interface Bar {
  a: string
  c: boolean
}

type Result1 = Diff<Foo, Bar> // { b: number, c: boolean }
type Result2 = Diff<Bar, Foo> // { b: number, c: boolean }
```

## 解题思路

待补充

## 答案

```ts
type Diff<O, O1> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface Foo {
  name: string
  age: string
}
interface Bar {
  name: string
  age: string
  gender: number
}
interface Coo {
  name: string
  gender: number
}

type cases = [
  Expect<Equal<Diff<Foo, Bar>, { gender: number }>>,
  Expect<Equal<Diff<Bar, Foo>, { gender: number }>>,
  Expect<Equal<Diff<Foo, Coo>, { age: string, gender: number }>>,
  Expect<Equal<Diff<Coo, Foo>, { age: string, gender: number }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Drop-Char/index.md
---
# Drop Char
## 题目

从字符串中剔除指定字符。

例如：

```ts
type Butterfly = DropChar<' b u t t e r f l y ! ', ' '> // 'butterfly!'
```

## 解题思路

待补充

## 答案

```ts
type DropChar<S, C> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  // @ts-expect-error
  Expect<Equal<DropChar<'butter fly!', ''>, 'butterfly!'>>,
  Expect<Equal<DropChar<'butter fly!', ' '>, 'butterfly!'>>,
  Expect<Equal<DropChar<'butter fly!', '!'>, 'butter fly'>>,
  Expect<Equal<DropChar<'    butter fly!        ', ' '>, 'butterfly!'>>,
  Expect<Equal<DropChar<' b u t t e r f l y ! ', ' '>, 'butterfly!'>>,
  Expect<Equal<DropChar<' b u t t e r f l y ! ', 'b'>, '  u t t e r f l y ! '>>,
  Expect<Equal<DropChar<' b u t t e r f l y ! ', 't'>, ' b u   e r f l y ! '>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/EndsWith/index.md
---
# EndsWith
## 题目

实现`EndsWith<T, U>`,接收两个string类型参数,然后判断`T`是否以`U`结尾,根据结果返回`true`或`false`

例如:

```typescript
type a = EndsWith<'abc', 'bc'> // expected to be true
type b = EndsWith<'abc', 'abc'> // expected to be true
type c = EndsWith<'abc', 'd'> // expected to be false
```

## 解题思路

待补充

## 答案

```ts
type EndsWith<T extends string, U extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<EndsWith<'abc', 'bc'>, true>>,
  Expect<Equal<EndsWith<'abc', 'abc'>, true>>,
  Expect<Equal<EndsWith<'abc', 'd'>, false>>,
  Expect<Equal<EndsWith<'abc', 'ac'>, false>>,
  Expect<Equal<EndsWith<'abc', ''>, true>>,
  Expect<Equal<EndsWith<'abc', ' '>, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/ExtractToObject/index.md
---
# ExtractToObject
## 题目

Implement a type that extract prop value to the interface. The type takes the two arguments. The output should be an object with the prop values.
Prop value is object.

For example

```ts
interface Test { id: '1', myProp: { foo: '2' } }
type Result = ExtractToObject<Test, 'myProp'> // expected to be { id: '1', foo: '2' }
```

## 解题思路

待补充

## 答案

```ts
type ExtractToObject<T, U> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface test1 { id: '1', myProp: { foo: '2' } }

interface testExpect1 {
  id: '1'
  foo: '2'
}

interface test2 {
  id: '1'
  prop1: { zoo: '2' }
  prop2: { foo: '4' }
}

interface testExpect2 {
  id: '1'
  prop1: { zoo: '2' }
  foo: '4'
}

interface test3 {
  prop1: { zoo: '2', a: 2, b: 4, c: 7 }
  prop2: { foo: '4', v: 2, d: 4, g: 7 }
  k: 289
}

interface testExpect3 {
  zoo: '2'
  a: 2
  b: 4
  c: 7
  prop2: { foo: '4', v: 2, d: 4, g: 7 }
  k: 289
}

interface test4 { id: '1', myProp: { foo: '2' } }

interface testExpect4 {
  id: '1'
  myProp: { foo: '2' }
}

type cases = [
  Expect<Equal<ExtractToObject<test1, 'myProp'>, testExpect1>>,
  Expect<Equal<ExtractToObject<test2, 'prop2'>, testExpect2>>,
  Expect<Equal<ExtractToObject<test3, 'prop1'>, testExpect3>>,
  // @ts-expect-error
  Expect<Equal<ExtractToObject<test4, 'prop4'>, testExpect4>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Fibonacci-Sequence/index.md
---
# Fibonacci Sequence
## 题目

Implement a generic Fibonacci\<T> takes an number T and returns it's corresponding [Fibonacci number](https://en.wikipedia.org/wiki/Fibonacci_number).

The sequence starts:
1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...

For example

```js
type Result1 = Fibonacci<3> // 2
type Result2 = Fibonacci<8> // 21
```

## 解题思路

待补充

## 答案

```ts
type Fibonacci<T extends number> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Fibonacci<1>, 1>>,
  Expect<Equal<Fibonacci<2>, 1>>,
  Expect<Equal<Fibonacci<3>, 2>>,
  Expect<Equal<Fibonacci<8>, 21>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Fill/index.md
---
# Fill
## 题目

`Fill`, a common JavaScript function, now let us implement it with types.
`Fill<T, N, Start?, End?>`, as you can see,`Fill` accepts four types of parameters, of which `T` and `N` are required parameters, and `Start` and `End` are optional parameters.
The requirements for these parameters are: `T` must be a `tuple`, `N` can be any type of value, `Start` and `End` must be integers greater than or equal to 0.

```ts
type exp = Fill<[1, 2, 3], 0> // expected to be [0, 0, 0]
```

In order to simulate the real function, the test may contain some boundary conditions, I hope you can enjoy it :)

## 解题思路

待补充

## 答案

```ts
type Fill<
  T extends unknown[],
  N,
  Start extends number = 0,
  End extends number = T['length'],
> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Fill<[], 0>, []>>,
  Expect<Equal<Fill<[], 0, 0, 3>, []>>,
  Expect<Equal<Fill<[1, 2, 3], 0, 0, 0>, [1, 2, 3]>>,
  Expect<Equal<Fill<[1, 2, 3], 0, 2, 2>, [1, 2, 3]>>,
  Expect<Equal<Fill<[1, 2, 3], 0>, [0, 0, 0]>>,
  Expect<Equal<Fill<[1, 2, 3], true>, [true, true, true]>>,
  Expect<Equal<Fill<[1, 2, 3], true, 0, 1>, [true, 2, 3]>>,
  Expect<Equal<Fill<[1, 2, 3], true, 1, 3>, [1, true, true]>>,
  Expect<Equal<Fill<[1, 2, 3], true, 10, 0>, [1, 2, 3]>>,
  Expect<Equal<Fill<[1, 2, 3], true, 10, 20>, [1, 2, 3]>>,
  Expect<Equal<Fill<[1, 2, 3], true, 0, 10>, [true, true, true]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Filter/index.md
---
# Filter
## 题目

Implement the type `Filter<T, Predicate>`. Here `T` is an array, and `Predicate` is a primitive type or a union of primitive types. The result should be an array that contains only those elements whose types are included in `Predicate`.

## 解题思路

待补充

## 答案

```ts
type Filter<T extends any[], P> = []
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type Falsy = false | 0 | '' | null | undefined

type cases = [
  Expect<Equal<Filter<[0, 1, 2], 2>, [2]>>,
  Expect<Equal<Filter<[0, 1, 2], 0 | 1>, [0, 1]>>,
  Expect<Equal<Filter<[0, 1, 2], Falsy>, [0]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/FindAll/index.md
---
# FindAll
## 题目

Given a pattern string P and a text string T, implement the type `FindAll<T, P>` that returns an Array that contains all indices (0-indexed) from T where P matches.

## 解题思路

待补充

## 答案

```ts
type FindAll<T extends string, P extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<FindAll<'Collection of TypeScript type challenges', 'Type'>, [14]>>,
  Expect<Equal<FindAll<'Collection of TypeScript type challenges', 'pe'>, [16, 27]>>,
  Expect<Equal<FindAll<'Collection of TypeScript type challenges', ''>, []>>,
  Expect<Equal<FindAll<'', 'Type'>, []>>,
  Expect<Equal<FindAll<'', ''>, []>>,
  Expect<Equal<FindAll<'AAAA', 'A'>, [0, 1, 2, 3]>>,
  Expect<Equal<FindAll<'AAAA', 'AA'>, [0, 1, 2]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/FirstUniqueCharIndex/index.md
---
# FirstUniqueCharIndex
## 题目

Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1. (Inspired by [leetcode 387](https://leetcode.com/problems/first-unique-character-in-a-string/))

## 解题思路

待补充

## 答案

```ts
type FirstUniqueCharIndex<T extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<FirstUniqueCharIndex<'leetcode'>, 0>>,
  Expect<Equal<FirstUniqueCharIndex<'loveleetcode'>, 2>>,
  Expect<Equal<FirstUniqueCharIndex<'aabb'>, -1>>,
  Expect<Equal<FirstUniqueCharIndex<''>, -1>>,
  Expect<Equal<FirstUniqueCharIndex<'aaa'>, -1>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Flatten/index.md
---
# Flatten
## 题目

在这个挑战中，你需要写一个接受数组的类型，并且返回扁平化的数组类型。

例如:

```ts
type flatten = Flatten<[1, 2, [3, 4], [[[5]]]]> // [1, 2, 3, 4, 5]
```

## 解题思路

待补充

## 答案

```ts
type Flatten = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Flatten<[]>, []>>,
  Expect<Equal<Flatten<[1, 2, 3, 4]>, [1, 2, 3, 4]>>,
  Expect<Equal<Flatten<[1, [2]]>, [1, 2]>>,
  Expect<Equal<Flatten<[1, 2, [3, 4], [[[5]]]]>, [1, 2, 3, 4, 5]>>,
  Expect<Equal<Flatten<[{ foo: 'bar', 2: 10 }, 'foobar']>, [{ foo: 'bar', 2: 10 }, 'foobar']>>,
]

// @ts-expect-error
type error = Flatten<'1'>
```

## 参考

无

---

---
url: /TypeGymnastics/medium/FlattenDepth/index.md
---
# FlattenDepth
## 题目

Recursively flatten array up to depth times.

For example:

```typescript
type a = FlattenDepth<[1, 2, [3, 4], [[[5]]]], 2> // [1, 2, 3, 4, [5]]. flattern 2 times
type b = FlattenDepth<[1, 2, [3, 4], [[[5]]]]> // [1, 2, 3, 4, [[5]]]. Depth defaults to be 1
```

If the depth is provided, it's guaranteed to be positive integer.

## 解题思路

待补充

## 答案

```ts
type FlattenDepth = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<FlattenDepth<[]>, []>>,
  Expect<Equal<FlattenDepth<[1, 2, 3, 4]>, [1, 2, 3, 4]>>,
  Expect<Equal<FlattenDepth<[1, [2]]>, [1, 2]>>,
  Expect<Equal<FlattenDepth<[1, 2, [3, 4], [[[5]]]], 2>, [1, 2, 3, 4, [5]]>>,
  Expect<Equal<FlattenDepth<[1, 2, [3, 4], [[[5]]]]>, [1, 2, 3, 4, [[5]]]>>,
  Expect<Equal<FlattenDepth<[1, [2, [3, [4, [5]]]]], 3>, [1, 2, 3, 4, [5]]>>,
  Expect<Equal<FlattenDepth<[1, [2, [3, [4, [5]]]]], 19260817>, [1, 2, 3, 4, 5]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Flip-Arguments/index.md
---
# Flip Arguments
## 题目

Implement the type version of lodash's `_.flip`.

Type `FlipArguments<T>` requires function type `T` and returns a new function type which has the same return type of T but reversed parameters.

For example:

```typescript
type Flipped = FlipArguments<(arg0: string, arg1: number, arg2: boolean) => void>
// (arg0: boolean, arg1: number, arg2: string) => void
```

## 解题思路

待补充

## 答案

```ts
type FlipArguments<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<FlipArguments<() => boolean>, () => boolean>>,
  Expect<Equal<FlipArguments<(foo: string) => number>, (foo: string) => number>>,
  Expect<Equal<FlipArguments<(arg0: string, arg1: number, arg2: boolean) => void>, (arg0: boolean, arg1: number, arg2: string) => void>>,
]

type errors = [
  // @ts-expect-error
  FlipArguments<'string'>,
  // @ts-expect-error
  FlipArguments<{ key: 'value' }>,
  // @ts-expect-error
  FlipArguments<['apple', 'banana', 100, { a: 1 }]>,
  // @ts-expect-error
  FlipArguments<null | undefined>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Flip/index.md
---
# Flip
## 题目

Implement the type of `just-flip-object`. Examples:

```typescript
Flip<{ a: 'x', b: 'y', c: 'z' }> // {x: 'a', y: 'b', z: 'c'}
Flip<{ a: 1, b: 2, c: 3 }> // {1: 'a', 2: 'b', 3: 'c'}
Flip<{ a: false, b: true }> // {false: 'a', true: 'b'}
```

No need to support nested objects and values which cannot be object keys such as arrays

## 解题思路

待补充

## 答案

```ts
type Flip<T> = any
```

## 验证

```ts
import type { Equal, Expect, NotEqual } from '@type-challenges/utils'

type cases = [
  Expect<Equal<{ a: 'pi' }, Flip<{ pi: 'a' }>>>,
  Expect<NotEqual<{ b: 'pi' }, Flip<{ pi: 'a' }>>>,
  Expect<Equal<{ 3.14: 'pi', true: 'bool' }, Flip<{ pi: 3.14, bool: true }>>>,
  Expect<Equal<{ val2: 'prop2', val: 'prop' }, Flip<{ prop: 'val', prop2: 'val2' }>>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Get-Return-Type/index.md
---
# Get Return Type
## 题目

不使用 `ReturnType` 实现 TypeScript 的 `ReturnType<T>` 泛型。

例如：

```ts
function fn(v: boolean) {
  if (v)
    return 1
  else
    return 2
}

type a = MyReturnType<typeof fn> // 应推导出 "1 | 2"
```

## 解题思路

匹配函数模式即可。`(...args: any) => infer R`

## 答案

```ts
type MyReturnType<T> = T extends (...args: any) => infer U ? U : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type MyReturnType<T> = T extends (...args: any) => infer U ? U : never
// ---cut---
type cases = [
  Expect<Equal<string, MyReturnType<() => string>>>,
  Expect<Equal<123, MyReturnType<() => 123>>>,
  Expect<Equal<ComplexObject, MyReturnType<() => ComplexObject>>>,
  Expect<Equal<Promise<boolean>, MyReturnType<() => Promise<boolean>>>>,
  Expect<Equal<() => 'foo', MyReturnType<() => () => 'foo'>>>,
  Expect<Equal<1 | 2, MyReturnType<typeof fn>>>,
  Expect<Equal<1 | 2, MyReturnType<typeof fn1>>>,
]

interface ComplexObject {
  a: [12, 'foo']
  bar: 'hello'
  prev: () => number
}

const fn = (v: boolean) => v ? 1 : 2
const fn1 = (v: boolean, w: any) => v ? 1 : 2
```

## 参考

无

---

---
url: /TypeGymnastics/medium/GetMiddleElement/index.md
---
# GetMiddleElement
## 题目

通过实现一个 `GetMiddleElement` 方法，获取数组的中间元素，用数组表示

> 如果数组的长度为奇数，则返回中间一个元素
> 如果数组的长度为偶数，则返回中间两个元素

```ts
  type simple1 = GetMiddleElement<[1, 2, 3, 4, 5]>, // 返回 [3]
  type simple2 = GetMiddleElement<[1, 2, 3, 4, 5, 6]> // 返回 [3, 4]
```

## 解题思路

待补充

## 答案

```ts
type GetMiddleElement<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<GetMiddleElement<[]>, []>>,
  Expect<Equal<GetMiddleElement<[1, 2, 3, 4, 5]>, [3]>>,
  Expect<Equal<GetMiddleElement<[1, 2, 3, 4, 5, 6]>, [3, 4]>>,
  Expect<Equal<GetMiddleElement<[() => string]>, [() => string]>>,
  Expect<Equal<GetMiddleElement<[() => number, '3', [3, 4], 5]>, ['3', [3, 4]]>>,
  Expect<Equal<GetMiddleElement<[() => string, () => number]>, [() => string, () => number]>>,
  Expect<Equal<GetMiddleElement<[never]>, [never]>>,
]
// @ts-expect-error
type error = GetMiddleElement<1, 2, 3>
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Greater-Than/index.md
---
# Greater Than
## 题目

In This Challenge, You should implement a type `GreaterThan<T, U>` like `T > U`

Negative numbers do not need to be considered.

For example

```ts
GreaterThan<2, 1> // should be true
GreaterThan<1, 1> // should be false
GreaterThan<10, 100> // should be false
GreaterThan<111, 11> // should be true
```

Good Luck!

## 解题思路

待补充

## 答案

```ts
type GreaterThan<T extends number, U extends number> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<GreaterThan<1, 0>, true>>,
  Expect<Equal<GreaterThan<5, 4>, true>>,
  Expect<Equal<GreaterThan<4, 5>, false>>,
  Expect<Equal<GreaterThan<0, 0>, false>>,
  Expect<Equal<GreaterThan<10, 9>, true>>,
  Expect<Equal<GreaterThan<20, 20>, false>>,
  Expect<Equal<GreaterThan<10, 100>, false>>,
  Expect<Equal<GreaterThan<111, 11>, true>>,
  Expect<Equal<GreaterThan<1234567891011, 1234567891010>, true>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/IndexOf/index.md
---
# IndexOf
## 题目

Implement the type version of Array.indexOf, indexOf\<T, U> takes an Array T, any U and returns the index of the first U in Array T.

```ts
type Res = IndexOf<[1, 2, 3], 2> // expected to be 1
type Res1 = IndexOf<[2, 6, 3, 8, 4, 1, 7, 3, 9], 3> // expected to be 2
type Res2 = IndexOf<[0, 0, 0], 2> // expected to be -1
```

## 解题思路

待补充

## 答案

```ts
type IndexOf<T, U> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<IndexOf<[1, 2, 3], 2>, 1>>,
  Expect<Equal<IndexOf<[2, 6, 3, 8, 4, 1, 7, 3, 9], 3>, 2>>,
  Expect<Equal<IndexOf<[0, 0, 0], 2>, -1>>,
  Expect<Equal<IndexOf<[string, 1, number, 'a'], number>, 2>>,
  Expect<Equal<IndexOf<[string, 1, number, 'a', any], any>, 4>>,
  Expect<Equal<IndexOf<[string, 'a'], 'a'>, 1>>,
  Expect<Equal<IndexOf<[any, 1], 1>, 1>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Integer/index.md
---
# Integer
## 题目

请完成类型 `Integer<T>`，类型 `T` 继承于 `number`，如果 `T` 是一个整数则返回它，否则返回 `never`。

## 解题思路

待补充

## 答案

```ts
type Integer<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

let x = 1
let y = 1 as const

type cases1 = [
  Expect<Equal<Integer<1>, 1>>,
  Expect<Equal<Integer<1.1>, never>>,
  Expect<Equal<Integer<1.0>, 1>>,
  Expect<Equal<Integer<1.000000000>, 1>>,
  Expect<Equal<Integer<0.5>, never>>,
  Expect<Equal<Integer<28.00>, 28>>,
  Expect<Equal<Integer<28.101>, never>>,
  Expect<Equal<Integer<typeof x>, never>>,
  Expect<Equal<Integer<typeof y>, 1>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/IsAlphabet/index.md
---
# IsAlphabet
## 题目

Determine if the given letter is an alphabet.

## 解题思路

待补充

## 答案

```ts
type IsAlphabet<S extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<IsAlphabet<'A'>, true>>,
  Expect<Equal<IsAlphabet<'z'>, true>>,
  Expect<Equal<IsAlphabet<'9'>, false>>,
  Expect<Equal<IsAlphabet<'!'>, false>>,
  Expect<Equal<IsAlphabet<'😂'>, false>>,
  Expect<Equal<IsAlphabet<''>, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/IsEqual/index.md
---
# IsEqual
## 题目

Implements the equal operator that returns a boolean for whether the two given types are equal.

For example:

```ts
type X1 = 1
type Y1 = 1
type T1 = IsEqual<X1, Y1> // expected to be true

type X2 = 1
type Y2 = 2
type T2 = IsEqual<X2, Y2> // expected to be false
```

## 解题思路

待补充

## 答案

```ts
type IsEqual<X, Y> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<IsEqual<number, string>, false>>,
  Expect<Equal<IsEqual<1, 1>, true>>,
  Expect<Equal<IsEqual<any, 1>, false>>,
  Expect<Equal<IsEqual<1 | 2, 1>, false>>,
  Expect<Equal<IsEqual<any, never>, false>>,
  Expect<Equal<IsEqual<[any], [number]>, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/IsFixedStringLiteralType/index.md
---
# IsFixedStringLiteralType
## 题目

Sometimes you may want to determine whether a string literal is a definite type. For example, when you want to check whether the type specified as a class identifier is a fixed string literal type.

```typescript
interface Action<ID extends string> { readonly id: ID }
```

Since it must be fixed, the following types must be determined as false.

* never type
* Union of string literal types
* Template literal types with embedded string, number, bigint, boolean

Determine whether the given type S is a definite string literal type.

## 解题思路

待补充

## 答案

```ts
type IsFixedStringLiteralType<S extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type testcase
  = | Expect<Equal<IsFixedStringLiteralType<'ABC'>, true>>
    | Expect<Equal<IsFixedStringLiteralType<string>, false>>
    | Expect<Equal<IsFixedStringLiteralType<'ABC' | 'DEF'>, false>>
    | Expect<Equal<IsFixedStringLiteralType<never>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`${string}`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`${string & {}}`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`${number}`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`${bigint}`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`${boolean}`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`${true}`>, true>>
    | Expect<Equal<IsFixedStringLiteralType<`${false}`>, true>>
    | Expect<Equal<IsFixedStringLiteralType<`${null}`>, true>>
    | Expect<Equal<IsFixedStringLiteralType<`${undefined}`>, true>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${string}`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${string & {}}`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${number}`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${bigint}`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${boolean}`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${true}`>, true>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${false}`>, true>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${null}`>, true>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${undefined}`>, true>>
    | Expect<Equal<IsFixedStringLiteralType<`${string}DEF`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`${string & {}}DEF`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`${number}DEF`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`${bigint}DEF`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`${boolean}DEF`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`${true}DEF`>, true>>
    | Expect<Equal<IsFixedStringLiteralType<`${false}DEF`>, true>>
    | Expect<Equal<IsFixedStringLiteralType<`${null}DEF`>, true>>
    | Expect<Equal<IsFixedStringLiteralType<`${undefined}DEF`>, true>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${string}DEF`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${string & {}}DEF`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${number}DEF`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${bigint}DEF`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${boolean}DEF`>, false>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${true}DEF`>, true>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${false}DEF`>, true>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${null}DEF`>, true>>
    | Expect<Equal<IsFixedStringLiteralType<`ABC${undefined}DEF`>, true>>
    | true
```

## 参考

无

---

---
url: /TypeGymnastics/medium/IsNever/index.md
---
# IsNever
## 题目

Implement a type IsNever, which takes input type `T`.
If the type of resolves to `never`, return `true`, otherwise `false`.

For example:

```ts
type A = IsNever<never> // expected to be true
type B = IsNever<undefined> // expected to be false
type C = IsNever<null> // expected to be false
type D = IsNever<[]> // expected to be false
type E = IsNever<number> // expected to be false
```

## 解题思路

待补充

## 答案

```ts
type IsNever<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<IsNever<never>, true>>,
  Expect<Equal<IsNever<never | string>, false>>,
  Expect<Equal<IsNever<''>, false>>,
  Expect<Equal<IsNever<undefined>, false>>,
  Expect<Equal<IsNever<null>, false>>,
  Expect<Equal<IsNever<[]>, false>>,
  Expect<Equal<IsNever<{}>, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/IsOdd/index.md
---
# IsOdd
## 题目

return true is a number is odd

## 解题思路

待补充

## 答案

```ts
type IsOdd<T extends number> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<IsOdd<5>, true>>,
  Expect<Equal<IsOdd<2023>, true>>,
  Expect<Equal<IsOdd<1453>, true>>,
  Expect<Equal<IsOdd<1926>, false>>,
  Expect<Equal<IsOdd<2.3>, false>>,
  Expect<Equal<IsOdd<3e23>, false>>,
  Expect<Equal<IsOdd<3e0>, true>>,
  Expect<Equal<IsOdd<number>, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/IsTuple/index.md
---
# IsTuple
## 题目

Implement a type `IsTuple`, which takes an input type `T` and returns whether `T` is tuple type.

For example:

```typescript
type case1 = IsTuple<[number]> // true
type case2 = IsTuple<readonly [number]> // true
type case3 = IsTuple<number[]> // false
```

## 解题思路

待补充

## 答案

```ts
type IsTuple<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<IsTuple<[]>, true>>,
  Expect<Equal<IsTuple<[number]>, true>>,
  Expect<Equal<IsTuple<readonly [1]>, true>>,
  Expect<Equal<IsTuple<{ length: 1 }>, false>>,
  Expect<Equal<IsTuple<number[]>, false>>,
  Expect<Equal<IsTuple<never>, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/IsUnion/index.md
---
# IsUnion
## 题目

Implement a type `IsUnion`, which takes an input type `T` and returns whether `T` resolves to a union type.

For example:

```ts
type case1 = IsUnion<string> // false
type case2 = IsUnion<string | number> // true
type case3 = IsUnion<[string | number]> // false
```

## 解题思路

待补充

## 答案

```ts
type IsUnion<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<IsUnion<string>, false>>,
  Expect<Equal<IsUnion<string | number>, true>>,
  Expect<Equal<IsUnion<'a' | 'b' | 'c' | 'd'>, true>>,
  Expect<Equal<IsUnion<undefined | null | void | ''>, true>>,
  Expect<Equal<IsUnion<{ a: string } | { a: number }>, true>>,
  Expect<Equal<IsUnion<{ a: string | number }>, false>>,
  Expect<Equal<IsUnion<[string | number]>, false>>,
  // Cases where T resolves to a non-union type.
  Expect<Equal<IsUnion<string | never>, false>>,
  Expect<Equal<IsUnion<string | unknown>, false>>,
  Expect<Equal<IsUnion<string | any>, false>>,
  Expect<Equal<IsUnion<string | 'a'>, false>>,
  Expect<Equal<IsUnion<never>, false>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Join/index.md
---
# Join
## 题目

Implement the type version of Array.join, Join\<T, U> takes an Array T, string or number U and returns the Array T with U stitching up.

```ts
type Res = Join<['a', 'p', 'p', 'l', 'e'], '-'> // expected to be 'a-p-p-l-e'
type Res1 = Join<['Hello', 'World'], ' '> // expected to be 'Hello World'
type Res2 = Join<['2', '2', '2'], 1> // expected to be '21212'
type Res3 = Join<['o'], 'u'> // expected to be 'o'
```

## 解题思路

待补充

## 答案

```ts
type Join<T, U> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Join<['a', 'p', 'p', 'l', 'e'], '-'>, 'a-p-p-l-e'>>,
  Expect<Equal<Join<['Hello', 'World'], ' '>, 'Hello World'>>,
  Expect<Equal<Join<['2', '2', '2'], 1>, '21212'>>,
  Expect<Equal<Join<['o'], 'u'>, 'o'>>,
  Expect<Equal<Join<[], 'u'>, ''>>,
  Expect<Equal<Join<['1', '1', '1']>, '1,1,1'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/JSON-Schema-to-TypeScript/index.md
---
# JSON Schema to TypeScript
## 题目

Implement the generic type JSONSchema2TS which will return the TypeScript type corresponding to the given JSON schema.

Additional challenges to handle:

* additionalProperties
* oneOf, anyOf, allOf
* minLength and maxLength

## 解题思路

待补充

## 答案

```ts
type JSONSchema2TS<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

// + Primitive types
type Type1 = JSONSchema2TS<{
  type: 'string'
}>
type Expected1 = string
type Result1 = Expect<Equal<Type1, Expected1>>

type Type2 = JSONSchema2TS<{
  type: 'number'
}>
type Expected2 = number
type Result2 = Expect<Equal<Type2, Expected2>>

type Type3 = JSONSchema2TS<{
  type: 'boolean'
}>
type Expected3 = boolean
type Result3 = Expect<Equal<Type3, Expected3>>
// - Primitive types

// + Enums
type Type4 = JSONSchema2TS<{
  type: 'string'
  enum: ['a', 'b', 'c']
}>
type Expected4 = 'a' | 'b' | 'c'
type Result4 = Expect<Equal<Type4, Expected4>>

type Type5 = JSONSchema2TS<{
  type: 'number'
  enum: [1, 2, 3]
}>
type Expected5 = 1 | 2 | 3
type Result5 = Expect<Equal<Type5, Expected5>>
// - Enums

// + Object types
type Type6 = JSONSchema2TS<{
  type: 'object'
}>
type Expected6 = Record<string, unknown>
type Result6 = Expect<Equal<Type6, Expected6>>

type Type7 = JSONSchema2TS<{
  type: 'object'
  properties: {}
}>
interface Expected7 {}
type Result7 = Expect<Equal<Type7, Expected7>>

type Type8 = JSONSchema2TS<{
  type: 'object'
  properties: {
    a: {
      type: 'string'
    }
  }
}>
interface Expected8 {
  a?: string
}
type Result8 = Expect<Equal<Type8, Expected8>>
// - Object types

// + Arrays
type Type9 = JSONSchema2TS<{
  type: 'array'
}>
type Expected9 = unknown[]
type Result9 = Expect<Equal<Type9, Expected9>>

type Type10 = JSONSchema2TS<{
  type: 'array'
  items: {
    type: 'string'
  }
}>
type Expected10 = string[]
type Result10 = Expect<Equal<Type10, Expected10>>

type Type11 = JSONSchema2TS<{
  type: 'array'
  items: {
    type: 'object'
  }
}>
type Expected11 = Record<string, unknown>[]
type Result11 = Expect<Equal<Type11, Expected11>>
// - Arrays

// + Mixed types
type Type12 = JSONSchema2TS<{
  type: 'object'
  properties: {
    a: {
      type: 'string'
      enum: ['a', 'b', 'c']
    }
    b: {
      type: 'number'
    }
  }
}>
interface Expected12 {
  a?: 'a' | 'b' | 'c'
  b?: number
}
type Result12 = Expect<Equal<Type12, Expected12>>

type Type13 = JSONSchema2TS<{
  type: 'array'
  items: {
    type: 'object'
    properties: {
      a: {
        type: 'string'
      }
    }
  }
}>
type Expected13 = {
  a?: string
}[]
type Result13 = Expect<Equal<Type13, Expected13>>
// - Mixed types

// + Required fields
type Type14 = JSONSchema2TS<{
  type: 'object'
  properties: {
    req1: { type: 'string' }
    req2: {
      type: 'object'
      properties: {
        a: {
          type: 'number'
        }
      }
      required: ['a']
    }
    add1: { type: 'string' }
    add2: {
      type: 'array'
      items: {
        type: 'number'
      }
    }
  }
  required: ['req1', 'req2']
}>
interface Expected14 {
  req1: string
  req2: { a: number }
  add1?: string
  add2?: number[]
}
type Result14 = Expect<Equal<Type14, Expected14>>
// - Required fields
```

## 参考

无

---

---
url: /TypeGymnastics/medium/KebabCase/index.md
---
# KebabCase
## 题目

Replace the `camelCase` or `PascalCase` string with `kebab-case`.

`FooBarBaz` -> `foo-bar-baz`

For example

```ts
type FooBarBaz = KebabCase<'FooBarBaz'>
const foobarbaz: FooBarBaz = 'foo-bar-baz'

type DoNothing = KebabCase<'do-nothing'>
const doNothing: DoNothing = 'do-nothing'
```

## 解题思路

待补充

## 答案

```ts
type KebabCase<S> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<KebabCase<'FooBarBaz'>, 'foo-bar-baz'>>,
  Expect<Equal<KebabCase<'fooBarBaz'>, 'foo-bar-baz'>>,
  Expect<Equal<KebabCase<'foo-bar'>, 'foo-bar'>>,
  Expect<Equal<KebabCase<'foo_bar'>, 'foo_bar'>>,
  Expect<Equal<KebabCase<'Foo-Bar'>, 'foo--bar'>>,
  Expect<Equal<KebabCase<'ABC'>, 'a-b-c'>>,
  Expect<Equal<KebabCase<'-'>, '-'>>,
  Expect<Equal<KebabCase<''>, ''>>,
  Expect<Equal<KebabCase<'😎'>, '😎'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Last-of-Array/index.md
---
# Last of Array
## 题目

> 在此挑战中建议使用TypeScript 4.0

实现一个`Last<T>`泛型，它接受一个数组`T`并返回其最后一个元素的类型。

例如

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

type tail1 = Last<arr1> // 应推导出 'c'
type tail2 = Last<arr2> // 应推导出 1
```

## 解题思路

待补充

## 答案

```ts
type Last<T extends any[]> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Last<[]>, never>>,
  Expect<Equal<Last<[2]>, 2>>,
  Expect<Equal<Last<[3, 2, 1]>, 1>>,
  Expect<Equal<Last<[() => 123, { a: string }]>, { a: string }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/LastIndexOf/index.md
---
# LastIndexOf
## 题目

实现类型版本的 `Array.lastIndexOf`, `LastIndexOf<T, U>`  接受数组 `T`, any 类型 `U`, 如果 `U` 存在于 `T` 中, 返回 `U` 在数组 `T` 中最后一个位置的索引, 不存在则返回 `-1`

For example:

```typescript
type Res1 = LastIndexOf<[1, 2, 3, 2, 1], 2> // 3
type Res2 = LastIndexOf<[0, 0, 0], 2> // -1
```

## 解题思路

待补充

## 答案

```ts
type LastIndexOf<T, U> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<LastIndexOf<[1, 2, 3, 2, 1], 2>, 3>>,
  Expect<Equal<LastIndexOf<[2, 6, 3, 8, 4, 1, 7, 3, 9], 3>, 7>>,
  Expect<Equal<LastIndexOf<[0, 0, 0], 2>, -1>>,
  Expect<Equal<LastIndexOf<[string, 2, number, 'a', number, 1], number>, 4>>,
  Expect<Equal<LastIndexOf<[string, any, 1, number, 'a', any, 1], any>, 5>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Length-of-String/index.md
---
# Length of String
## 题目

计算字符串的长度，类似于 `String#length` 。

## 解题思路

待补充

## 答案

```ts
type LengthOfString<S extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<LengthOfString<''>, 0>>,
  Expect<Equal<LengthOfString<'kumiko'>, 6>>,
  Expect<Equal<LengthOfString<'reina'>, 5>>,
  Expect<Equal<LengthOfString<'Sound! Euphonium'>, 16>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Longest-Common-Prefix/index.md
---
# Longest Common Prefix
## 题目

### Longest Common Prefix

Write a type, `LongestCommonPrefix` that returns the longest common prefix string amongst a tuple of strings.

If there is no common prefix, return an empty string `""`.

```ts
type Common = LongestCommonPrefix<['flower', 'flow', 'flight']>
//   ?^ "fl"

type Uncommon = LongestCommonPrefix<['dog', 'racecar', 'race']>
//   ?^ ""
```

Inspired by [LeetCode 14. Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/description/)

## 解题思路

待补充

## 答案

```ts
type LongestCommonPrefix<T extends string[], P extends string = ''> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<LongestCommonPrefix<['flower', 'flow', 'flight']>, 'fl'>>,
  Expect<Equal<LongestCommonPrefix<['dog', 'racecar', 'race']>, ''>>,
  Expect<Equal<LongestCommonPrefix<['', '', '']>, ''>>,
  Expect<Equal<LongestCommonPrefix<['a', '', '']>, ''>>,
  Expect<Equal<LongestCommonPrefix<['', 'a', '']>, ''>>,
  Expect<Equal<LongestCommonPrefix<['', '', 'a']>, ''>>,
  Expect<Equal<LongestCommonPrefix<['a', 'a', '']>, ''>>,
  Expect<Equal<LongestCommonPrefix<['a', '', 'a']>, ''>>,
  Expect<Equal<LongestCommonPrefix<['', 'a', 'a']>, ''>>,
  Expect<Equal<LongestCommonPrefix<['a', 'a', 'a']>, 'a'>>,
  Expect<Equal<LongestCommonPrefix<['abc', 'abcd', 'abcde']>, 'abc'>>,
  Expect<Equal<LongestCommonPrefix<[' ', ' ', ' ']>, ' '>>,
  Expect<Equal<LongestCommonPrefix<['type-challenges', 'type-hero', 'typescript']>, 'type'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/MapTypes/index.md
---
# MapTypes
## 题目

Implement `MapTypes<T, R>` which will transform types in object T to different types defined by type R which has the following structure

```ts
interface StringToNumber {
  mapFrom: string // value of key which value is string
  mapTo: number // will be transformed for number
}
```

## Examples:

```ts
interface StringToNumber { mapFrom: string, mapTo: number }
MapTypes<{ iWillBeANumberOneDay: string }, StringToNumber> // gives { iWillBeANumberOneDay: number; }
```

Be aware that user can provide a union of types:

```ts
interface StringToNumber { mapFrom: string, mapTo: number }
interface StringToDate { mapFrom: string, mapTo: Date }
MapTypes<{ iWillBeNumberOrDate: string }, StringToDate | StringToNumber> // gives { iWillBeNumberOrDate: number | Date; }
```

If the type doesn't exist in our map, leave it as it was:

```ts
interface StringToNumber { mapFrom: string, mapTo: number }
MapTypes<{ iWillBeANumberOneDay: string, iWillStayTheSame: Function }, StringToNumber> // // gives { iWillBeANumberOneDay: number, iWillStayTheSame: Function }
```

## 解题思路

待补充

## 答案

```ts
type MapTypes<T, R> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<MapTypes<{ stringToArray: string }, { mapFrom: string, mapTo: [] }>, { stringToArray: [] }>>,
  Expect<Equal<MapTypes<{ stringToNumber: string }, { mapFrom: string, mapTo: number }>, { stringToNumber: number }>>,
  Expect<Equal<MapTypes<{ stringToNumber: string, skipParsingMe: boolean }, { mapFrom: string, mapTo: number }>, { stringToNumber: number, skipParsingMe: boolean }>>,
  Expect<Equal<MapTypes<{ date: string }, { mapFrom: string, mapTo: Date } | { mapFrom: string, mapTo: null }>, { date: null | Date }>>,
  Expect<Equal<MapTypes<{ date: string }, { mapFrom: string, mapTo: Date | null }>, { date: null | Date }>>,
  Expect<Equal<MapTypes<{ fields: Record<string, boolean> }, { mapFrom: Record<string, boolean>, mapTo: string[] }>, { fields: string[] }>>,
  Expect<Equal<MapTypes<{ name: string }, { mapFrom: boolean, mapTo: never }>, { name: string }>>,
  Expect<Equal<MapTypes<{ name: string, date: Date }, { mapFrom: string, mapTo: boolean } | { mapFrom: Date, mapTo: string }>, { name: boolean, date: string }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Merge/index.md
---
# Merge
## 题目

将两个类型合并成一个类型，第二个类型的键会覆盖第一个类型的键。

例如

```ts
interface foo {
  name: string
  age: string
}

interface coo {
  age: number
  sex: string
}

type Result = Merge<foo, coo> // expected to be {name: string, age: number, sex: string}
```

## 解题思路

待补充

## 答案

```ts
type Merge<F, S> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface Foo {
  a: number
  b: string
}
interface Bar {
  b: number
  c: boolean
}

type cases = [
  Expect<Equal<Merge<Foo, Bar>, {
    a: number
    b: number
    c: boolean
  }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/MergeAll/index.md
---
# MergeAll
## 题目

Merge variadic number of types into a new type. If the keys overlap, its values should be merged into an union.

For example:

```ts
interface Foo { a: 1, b: 2 }
interface Bar { a: 2 }
interface Baz { c: 3 }

type Result = MergeAll<[Foo, Bar, Baz]> // expected to be { a: 1 | 2; b: 2; c: 3 }
```

## 解题思路

待补充

## 答案

```ts
type MergeAll<XS> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<MergeAll<[]>, {}>>,
  Expect<Equal<MergeAll<[{ a: 1 }]>, { a: 1 }>>,
  Expect<Equal<
    MergeAll<[{ a: string }, { a: string }]>,
    { a: string }
  >
  >,
  Expect<Equal<
    MergeAll<[{ }, { a: string }]>,
    { a: string }
  >
  >,
  Expect<Equal<
    MergeAll<[{ a: 1 }, { c: 2 }]>,
    { a: 1, c: 2 }
  >
  >,
  Expect<Equal<
    MergeAll<[{ a: 1, b: 2 }, { a: 2 }, { c: 3 }]>,
    { a: 1 | 2, b: 2, c: 3 }
  >
  >,
  Expect<Equal<MergeAll<[{ a: 1 }, { a: number }]>, { a: number }>>,
  Expect<Equal<MergeAll<[{ a: number }, { a: 1 }]>, { a: number }>>,
  Expect<Equal<MergeAll<[{ a: 1 | 2 }, { a: 1 | 3 }]>, { a: 1 | 2 | 3 }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/MinusOne/index.md
---
# MinusOne
## 题目

给定一个正整数作为类型的参数，要求返回的类型是该数字减 1。

例如:

```ts
type Zero = MinusOne<1> // 0
type FiftyFour = MinusOne<55> // 54
```

## 解题思路

待补充

## 答案

```ts
type MinusOne<T extends number> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<MinusOne<1>, 0>>,
  Expect<Equal<MinusOne<55>, 54>>,
  Expect<Equal<MinusOne<3>, 2>>,
  Expect<Equal<MinusOne<100>, 99>>,
  Expect<Equal<MinusOne<1101>, 1100>>,
  Expect<Equal<MinusOne<9_007_199_254_740_992>, 9_007_199_254_740_991>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Mutable/index.md
---
# Mutable
## 题目

实现一个通用的类型 `Mutable<T>`，使类型 `T` 的全部属性可变（非只读）。

例如：

```typescript
interface Todo {
  readonly title: string
  readonly description: string
  readonly completed: boolean
}

type MutableTodo = Mutable<Todo> // { title: string; description: string; completed: boolean; }
```

## 解题思路

待补充

## 答案

```ts
type Mutable<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface Todo1 {
  title: string
  description: string
  completed: boolean
  meta: {
    author: string
  }
}

type List = [1, 2, 3]

type cases = [
  Expect<Equal<Mutable<Readonly<Todo1>>, Todo1>>,
  Expect<Equal<Mutable<Readonly<List>>, List>>,
]

type errors = [
  // @ts-expect-error
  Mutable<'string'>,
  // @ts-expect-error
  Mutable<0>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/MyUppercase/index.md
---
# MyUppercase
## 题目

Implement `Uppercase<T>`, convert all letter to uppercase

## 解题思路

待补充

## 答案

```ts
type MyUppercase<T extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<MyUppercase<'a'>, 'A'>>,
  Expect<Equal<MyUppercase<'Z'>, 'Z'>>,
  Expect<Equal<MyUppercase<'A z h yy 😃cda\n\t  a   '>, 'A Z H YY 😃CDA\n\t  A   '>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Number-Range/index.md
---
# Number Range
## 题目

Sometimes we want to limit the range of numbers...
For examples.

```ts
type result = NumberRange<2, 9> //  | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

## 解题思路

待补充

## 答案

```ts
type NumberRange<L, H> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type Result1 = | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
type Result2 = | 0 | 1 | 2
type Result3
  = | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10
    | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20
    | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30
    | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40
    | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50
    | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60
    | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70
    | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80
    | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90
    | 91 | 92 | 93 | 94 | 95 | 96 | 97 | 98 | 99 | 100
    | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110
    | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120
    | 121 | 122 | 123 | 124 | 125 | 126 | 127 | 128 | 129 | 130
    | 131 | 132 | 133 | 134 | 135 | 136 | 137 | 138 | 139 | 140
type cases = [
  Expect<Equal<NumberRange<2, 9>, Result1>>,
  Expect<Equal<NumberRange<0, 2>, Result2>>,
  Expect<Equal<NumberRange<0, 140>, Result3>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/ObjectEntries/index.md
---
# ObjectEntries
## 题目

Implement the type version of `Object.entries`

For example

```typescript
interface Model {
  name: string
  age: number
  locations: string[] | null
}
type modelEntries = ObjectEntries<Model> // ['name', string] | ['age', number] | ['locations', string[] | null];
```

## 解题思路

待补充

## 答案

```ts
type ObjectEntries<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface Model {
  name: string
  age: number
  locations: string[] | null
}

type ModelEntries = ['name', string] | ['age', number] | ['locations', string[] | null]

type cases = [
  Expect<Equal<ObjectEntries<Model>, ModelEntries>>,
  Expect<Equal<ObjectEntries<Partial<Model>>, ModelEntries>>,
  Expect<Equal<ObjectEntries<{ key?: undefined }>, ['key', undefined]>>,
  Expect<Equal<ObjectEntries<{ key: undefined }>, ['key', undefined]>>,
  Expect<Equal<ObjectEntries<{ key: string | undefined }>, ['key', string | undefined]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Omit/index.md
---
# Omit
## 题目

不使用 `Omit` 实现 TypeScript 的 `Omit<T, K>` 泛型。

`Omit` 会创建一个省略 `K` 中字段的 `T` 对象。

例如：

```ts
interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = MyOmit<Todo, 'description' | 'title'>

const todo: TodoPreview = {
  completed: false,
}
```

## 解题思路

遍历 `T` 中的键，判断是否在 `K` 中。注意 `K` 需要限定在 `T` 的键中。

## 答案

```ts
type MyOmit<T, K extends keyof T> = {
  [P in keyof T as P extends K ? never : P]: T[P]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '@type-challenges/utils'
type MyOmit<T, K extends keyof T> = {
  [P in keyof T as P extends K ? never : P]: T[P]
}
// ---cut---
type cases = [
  Expect<Equal<Expected1, MyOmit<Todo, 'description'>>>,
  Expect<Equal<Expected2, MyOmit<Todo, 'description' | 'completed'>>>,
  Expect<Equal<Expected3, MyOmit<Todo1, 'description' | 'completed'>>>,
]

// @ts-expect-error
type error = MyOmit<Todo, 'description' | 'invalid'>

interface Todo {
  title: string
  description: string
  completed: boolean
}

interface Todo1 {
  readonly title: string
  description: string
  completed: boolean
}

interface Expected1 {
  title: string
  completed: boolean
}

interface Expected2 {
  title: string
}

interface Expected3 {
  readonly title: string
}
```

## 参考

无

---

---
url: /TypeGymnastics/medium/OmitByType/index.md
---
# OmitByType
## 题目

From `T`, pick a set of properties whose type are not assignable to `U`.

For Example

```typescript
type OmitBoolean = OmitByType<{
  name: string
  count: number
  isReadonly: boolean
  isEnable: boolean
}, boolean> // { name: string; count: number }
```

## 解题思路

待补充

## 答案

```ts
type OmitByType<T, U> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface Model {
  name: string
  count: number
  isReadonly: boolean
  isEnable: boolean
}

type cases = [
  Expect<Equal<OmitByType<Model, boolean>, { name: string, count: number }>>,
  Expect<Equal<OmitByType<Model, string>, { count: number, isReadonly: boolean, isEnable: boolean }>>,
  Expect<Equal<OmitByType<Model, number>, { name: string, isReadonly: boolean, isEnable: boolean }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Parse-URL-Params/index.md
---
# Parse URL Params
## 题目

You're required to implement a type-level parser to parse URL params string into an Union.

```ts
ParseUrlParams<':id'> // id
ParseUrlParams<'posts/:id'> // id
ParseUrlParams<'posts/:id/:user'> // id | user
```

## 解题思路

待补充

## 答案

```ts
type ParseUrlParams<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<ParseUrlParams<''>, never>>,
  Expect<Equal<ParseUrlParams<':id'>, 'id'>>,
  Expect<Equal<ParseUrlParams<'posts/:id'>, 'id'>>,
  Expect<Equal<ParseUrlParams<'posts/:id/'>, 'id'>>,
  Expect<Equal<ParseUrlParams<'posts/:id/:user'>, 'id' | 'user'>>,
  Expect<Equal<ParseUrlParams<'posts/:id/:user/like'>, 'id' | 'user'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/PartialByKeys/index.md
---
# PartialByKeys
## 题目

实现一个通用的`PartialByKeys<T, K>`，它接收两个类型参数`T`和`K`。

`K`指定应设置为可选的`T`的属性集。当没有提供`K`时，它就和普通的`Partial<T>`一样使所有属性都是可选的。

例如:

```ts
interface User {
  name: string
  age: number
  address: string
}

type UserPartialName = PartialByKeys<User, 'name'> // { name?:string; age:number; address:string }
```

## 解题思路

待补充

## 答案

```ts
type PartialByKeys<T, K> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface User {
  name: string
  age: number
  address: string
}

interface UserPartialName {
  name?: string
  age: number
  address: string
}

interface UserPartialNameAndAge {
  name?: string
  age?: number
  address: string
}

type cases = [
  Expect<Equal<PartialByKeys<User, 'name'>, UserPartialName>>,
  Expect<Equal<PartialByKeys<User, 'name' | 'age'>, UserPartialNameAndAge>>,
  Expect<Equal<PartialByKeys<User>, Partial<User>>>,
  // @ts-expect-error
  Expect<Equal<PartialByKeys<User, 'name' | 'unknown'>, UserPartialName>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Pascals-triangle/index.md
---
# Pascal's triangle
## 题目

Given a number N, construct the Pascal's triangle with N rows.
[Wikipedia](https://en.wikipedia.org/wiki/Pascal%27s_triangle)

## 解题思路

待补充

## 答案

```ts
type Pascal<N extends number> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<
    Equal<
      Pascal<1>,
      [
        [1],
      ]
    >
  >,
  Expect<
    Equal<
      Pascal<3>,
      [
        [1],
        [1, 1],
        [1, 2, 1],
      ]
    >
  >,
  Expect<
    Equal<
      Pascal<5>,
      [
        [1],
        [1, 1],
        [1, 2, 1],
        [1, 3, 3, 1],
        [1, 4, 6, 4, 1],
      ]
    >
  >,
  Expect<
    Equal<
      Pascal<7>,
      [
        [1],
        [1, 1],
        [1, 2, 1],
        [1, 3, 3, 1],
        [1, 4, 6, 4, 1],
        [1, 5, 10, 10, 5, 1],
        [1, 6, 15, 20, 15, 6, 1],
      ]
    >
  >,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Percentage-Parser/index.md
---
# Percentage Parser
## 题目

实现类型 `PercentageParser<T extends string>`。根据规则 `/^(\+|\-)?(\d*)?(\%)?$/` 匹配类型 T。

匹配的结果由三部分组成，分别是：\[`正负号`, `数字`, `单位`]，如果没有匹配，则默认是空字符串。

例如：

```ts
type PString1 = ''
type PString2 = '+85%'
type PString3 = '-85%'
type PString4 = '85%'
type PString5 = '85'

type R1 = PercentageParser<PString1> // expected ['', '', '']
type R2 = PercentageParser<PString2> // expected ["+", "85", "%"]
type R3 = PercentageParser<PString3> // expected ["-", "85", "%"]
type R4 = PercentageParser<PString4> // expected ["", "85", "%"]
type R5 = PercentageParser<PString5> // expected ["", "85", ""]
```

## 解题思路

待补充

## 答案

```ts
type PercentageParser<A extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type Case0 = ['', '', '']
type Case1 = ['+', '', '']
type Case2 = ['+', '1', '']
type Case3 = ['+', '100', '']
type Case4 = ['+', '100', '%']
type Case5 = ['', '100', '%']
type Case6 = ['-', '100', '%']
type Case7 = ['-', '100', '']
type Case8 = ['-', '1', '']
type Case9 = ['', '', '%']
type Case10 = ['', '1', '']
type Case11 = ['', '100', '']

type cases = [
  Expect<Equal<PercentageParser<''>, Case0>>,
  Expect<Equal<PercentageParser<'+'>, Case1>>,
  Expect<Equal<PercentageParser<'+1'>, Case2>>,
  Expect<Equal<PercentageParser<'+100'>, Case3>>,
  Expect<Equal<PercentageParser<'+100%'>, Case4>>,
  Expect<Equal<PercentageParser<'100%'>, Case5>>,
  Expect<Equal<PercentageParser<'-100%'>, Case6>>,
  Expect<Equal<PercentageParser<'-100'>, Case7>>,
  Expect<Equal<PercentageParser<'-1'>, Case8>>,
  Expect<Equal<PercentageParser<'%'>, Case9>>,
  Expect<Equal<PercentageParser<'1'>, Case10>>,
  Expect<Equal<PercentageParser<'100'>, Case11>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Permutation/index.md
---
# Permutation
## 题目

实现联合类型的全排列，将联合类型转换成所有可能的全排列数组的联合类型。

```typescript
type perm = Permutation<'A' | 'B' | 'C'> // ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']
```

## 解题思路

待补充

## 答案

```ts
type Permutation<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Permutation<'A'>, ['A']>>,
  Expect<Equal<Permutation<'A' | 'B' | 'C'>, ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']>>,
  Expect<Equal<Permutation<'B' | 'A' | 'C'>, ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']>>,
  Expect<Equal<Permutation<boolean>, [false, true] | [true, false]>>,
  Expect<Equal<Permutation<never>, []>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Permutations-of-Tuple/index.md
---
# Permutations of Tuple
## 题目

Given a generic tuple type `T extends unknown[]`, write a type which produces all permutations of `T` as a union.

For example:

```ts
PermutationsOfTuple<[1, number, unknown]>
// Should return:
// | [1, number, unknown]
// | [1, unknown, number]
// | [number, 1, unknown]
// | [unknown, 1, number]
// | [number, unknown, 1]
// | [unknown, number ,1]
```

## 解题思路

待补充

## 答案

```ts
type PermutationsOfTuple<T extends unknown[]> = any
```

## 验证

```ts
import type { Equal, Expect, ExpectFalse } from '@type-challenges/utils'

type cases = [
  Expect<Equal<PermutationsOfTuple<[]>, []>>,
  Expect<Equal<PermutationsOfTuple<[any]>, [any]>>,
  Expect<Equal<PermutationsOfTuple<[any, unknown]>, [any, unknown] | [unknown, any]>>,
  Expect<Equal<
    PermutationsOfTuple<[any, unknown, never]>,
    | [any, unknown, never]
    | [unknown, any, never]
    | [unknown, never, any]
    | [any, never, unknown]
    | [never, any, unknown]
    | [never, unknown, any]
  >>,
  Expect<Equal<
    PermutationsOfTuple<[1, number, unknown]>,
    | [1, number, unknown]
    | [1, unknown, number]
    | [number, 1, unknown]
    | [unknown, 1, number]
    | [number, unknown, 1]
    | [unknown, number, 1]
  >>,
  ExpectFalse<Equal<PermutationsOfTuple<[ 1, number, unknown ]>, [unknown]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/PickByType/index.md
---
# PickByType
## 题目

From `T`, pick a set of properties whose type are assignable to `U`.

For Example

```typescript
type OnlyBoolean = PickByType<{
  name: string
  count: number
  isReadonly: boolean
  isEnable: boolean
}, boolean> // { isReadonly: boolean; isEnable: boolean; }
```

## 解题思路

待补充

## 答案

```ts
type PickByType<T, U> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface Model {
  name: string
  count: number
  isReadonly: boolean
  isEnable: boolean
}

type cases = [
  Expect<Equal<PickByType<Model, boolean>, { isReadonly: boolean, isEnable: boolean }>>,
  Expect<Equal<PickByType<Model, string>, { name: string }>>,
  Expect<Equal<PickByType<Model, number>, { count: number }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Pop/index.md
---
# Pop
## 题目

> 在此挑战中建议使用TypeScript 4.0

实现一个泛型`Pop<T>`，它接受一个数组`T`，并返回一个由数组`T`的前 N-1 项（N 为数组`T`的长度）以相同的顺序组成的数组。

例如

```ts
type arr1 = ['a', 'b', 'c', 'd']
type arr2 = [3, 2, 1]

type re1 = Pop<arr1> // expected to be ['a', 'b', 'c']
type re2 = Pop<arr2> // expected to be [3, 2]
```

**额外**：同样，您也可以实现`Shift`，`Push`和`Unshift`吗？

## 解题思路

待补充

## 答案

```ts
type Pop<T extends any[]> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Pop<[3, 2, 1]>, [3, 2]>>,
  Expect<Equal<Pop<['a', 'b', 'c', 'd']>, ['a', 'b', 'c']>>,
  Expect<Equal<Pop<[]>, []>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Promiseall/index.md
---
# Promise.all
## 题目

给函数`PromiseAll`指定类型，它接受元素为 Promise 或者类似 Promise 的对象的数组，返回值应为`Promise<T>`，其中`T`是这些 Promise 的结果组成的数组。

```ts
const promise1 = Promise.resolve(3)
const promise2 = 42
const promise3 = new Promise<string>((resolve, reject) => {
  setTimeout(resolve, 100, 'foo')
})

// 应推导出 `Promise<[number, 42, string]>`
const p = PromiseAll([promise1, promise2, promise3] as const)
```

## 解题思路

待补充

## 答案

```ts
declare function PromiseAll(values: any): any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

const promiseAllTest1 = PromiseAll([1, 2, 3] as const)
const promiseAllTest2 = PromiseAll([1, 2, Promise.resolve(3)] as const)
const promiseAllTest3 = PromiseAll([1, 2, Promise.resolve(3)])
const promiseAllTest4 = PromiseAll<Array<number | Promise<number>>>([1, 2, 3])
const promiseAllTest5 = PromiseAll<(number | Promise<string>)[]>([1, 2, Promise.resolve('3')])

type cases = [
  Expect<Equal<typeof promiseAllTest1, Promise<[1, 2, 3]>>>,
  Expect<Equal<typeof promiseAllTest2, Promise<[1, 2, number]>>>,
  Expect<Equal<typeof promiseAllTest3, Promise<[number, number, number]>>>,
  Expect<Equal<typeof promiseAllTest4, Promise<number[]>>>,
  Expect<Equal<typeof promiseAllTest5, Promise<(number | string)[]>>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Public-Type/index.md
---
# Public Type
## 题目

Remove the key starting with `_` from given type `T`.

## 解题思路

待补充

## 答案

```ts
type PublicType<T extends object> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<PublicType<{ a: number }>, { a: number }>>,
  Expect<Equal<PublicType<{ _b: string | bigint }>, {}>>,
  Expect<Equal<PublicType<{ readonly c?: number }>, { readonly c?: number }>>,
  Expect<Equal<PublicType<{ d: string, _e: string }>, { d: string }>>,
  Expect<Equal<PublicType<{ _f: () => bigint[] }>, {}>>,
  Expect<Equal<PublicType<{ g: '_g' }>, { g: '_g' }>>,
  Expect<Equal<PublicType<{ __h: number, i: unknown }>, { i: unknown }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Readonly-2/index.md
---
# Readonly 2
## 题目

实现一个泛型`MyReadonly2<T, K>`，它带有两种类型的参数`T`和`K`。

类型 `K` 指定 `T` 中要被设置为只读 (readonly) 的属性。如果未提供`K`，则应使所有属性都变为只读，就像普通的`Readonly<T>`一样。

例如

```ts
interface Todo {
  title: string
  description: string
  completed: boolean
}

const todo: MyReadonly2<Todo, 'title' | 'description'> = {
  title: 'Hey',
  description: 'foobar',
  completed: false,
}

todo.title = 'Hello' // Error: cannot reassign a readonly property
todo.description = 'barFoo' // Error: cannot reassign a readonly property
todo.completed = true // OK
```

## 解题思路

待补充

## 答案

```ts
type MyReadonly2<T, K> = any
```

## 验证

```ts
import type { Alike, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Alike<MyReadonly2<Todo1>, Readonly<Todo1>>>,
  Expect<Alike<MyReadonly2<Todo1, 'title' | 'description'>, Expected>>,
  Expect<Alike<MyReadonly2<Todo2, 'title' | 'description'>, Expected>>,
  Expect<Alike<MyReadonly2<Todo2, 'description'>, Expected>>,
]

// @ts-expect-error
type error = MyReadonly2<Todo1, 'title' | 'invalid'>

interface Todo1 {
  title: string
  description?: string
  completed: boolean
}

interface Todo2 {
  readonly title: string
  description?: string
  completed: boolean
}

interface Expected {
  readonly title: string
  readonly description?: string
  completed: boolean
}
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Remove-Index-Signature/index.md
---
# Remove Index Signature
## 题目

Implement `RemoveIndexSignature<T>` , exclude the index signature from object types.

For example:

```ts
interface Foo {
  [key: string]: any
  foo: () => void
}

type A = RemoveIndexSignature<Foo> // expected { foo(): void }
```

## 解题思路

待补充

## 答案

```ts
type RemoveIndexSignature<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface Foo {
  [key: string]: any
  foo: () => void
}

interface Bar {
  [key: number]: any
  bar: () => void
  0: string
}

const foobar = Symbol('foobar')
interface FooBar {
  [key: symbol]: any
  [foobar]: () => void
}

interface Baz {
  bar: () => void
  baz: string
}

type cases = [
  Expect<Equal<RemoveIndexSignature<Foo>, { foo: () => void }>>,
  Expect<Equal<RemoveIndexSignature<Bar>, { bar: () => void, 0: string }>>,
  Expect<Equal<RemoveIndexSignature<FooBar>, { [foobar]: () => void }>>,
  Expect<Equal<RemoveIndexSignature<Baz>, { bar: () => void, baz: string }>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Replace-First/index.md
---
# Replace First
## 题目

Implement the type `ReplaceFirst<T, S, R>` which will replace the first occurrence of S in a tuple T with R. If no such S exists in T, the result should be T.

## 解题思路

待补充

## 答案

```ts
type ReplaceFirst<T extends readonly unknown[], S, R> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<ReplaceFirst<[1, 2, 3], 3, 4>, [1, 2, 4]>>,
  Expect<Equal<ReplaceFirst<['A', 'B', 'C'], 'C', 'D'>, ['A', 'B', 'D']>>,
  Expect<Equal<ReplaceFirst<[true, true, true], true, false>, [false, true, true]>>,
  Expect<Equal<ReplaceFirst<[string, boolean, number], boolean, string>, [string, string, number]>>,
  Expect<Equal<ReplaceFirst<[1, 'two', 3], string, 2>, [1, 2, 3]>>,
  Expect<Equal<ReplaceFirst<['six', 'eight', 'ten'], 'eleven', 'twelve'>, ['six', 'eight', 'ten']>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Replace/index.md
---
# Replace
## 题目

实现 `Replace<S, From, To>` 将字符串 `S` 中的第一个子字符串 `From` 替换为 `To` 。

例如

```ts
type replaced = Replace<'types are fun!', 'fun', 'awesome'> // 期望是 'types are awesome!'
```

## 解题思路

待补充

## 答案

```ts
type Replace<S extends string, From extends string, To extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Replace<'foobar', 'bar', 'foo'>, 'foofoo'>>,
  Expect<Equal<Replace<'foobarbar', 'bar', 'foo'>, 'foofoobar'>>,
  Expect<Equal<Replace<'foobarbar', '', 'foo'>, 'foobarbar'>>,
  Expect<Equal<Replace<'foobarbar', 'bar', ''>, 'foobar'>>,
  Expect<Equal<Replace<'foobarbar', 'bra', 'foo'>, 'foobarbar'>>,
  Expect<Equal<Replace<'', '', ''>, ''>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/ReplaceAll/index.md
---
# ReplaceAll
## 题目

实现 `ReplaceAll<S, From, To>` 将一个字符串 `S` 中的所有子字符串 `From` 替换为 `To`。

例如

```ts
type replaced = ReplaceAll<'t y p e s', ' ', ''> // 期望是 'types'
```

## 解题思路

待补充

## 答案

```ts
type ReplaceAll<S extends string, From extends string, To extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<ReplaceAll<'foobar', 'bar', 'foo'>, 'foofoo'>>,
  Expect<Equal<ReplaceAll<'foobar', 'bag', 'foo'>, 'foobar'>>,
  Expect<Equal<ReplaceAll<'foobarbar', 'bar', 'foo'>, 'foofoofoo'>>,
  Expect<Equal<ReplaceAll<'t y p e s', ' ', ''>, 'types'>>,
  Expect<Equal<ReplaceAll<'foobarbar', '', 'foo'>, 'foobarbar'>>,
  Expect<Equal<ReplaceAll<'barfoo', 'bar', 'foo'>, 'foofoo'>>,
  Expect<Equal<ReplaceAll<'foobarfoobar', 'ob', 'b'>, 'fobarfobar'>>,
  Expect<Equal<ReplaceAll<'foboorfoboar', 'bo', 'b'>, 'foborfobar'>>,
  Expect<Equal<ReplaceAll<'', '', ''>, ''>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/ReplaceKeys/index.md
---
# ReplaceKeys
## 题目

Implement a type ReplaceKeys, that replace keys in union types, if some type has not this key, just skip replacing,
A type takes three arguments.

For example:

```ts
interface NodeA {
  type: 'A'
  name: string
  flag: number
}

interface NodeB {
  type: 'B'
  id: number
  flag: number
}

interface NodeC {
  type: 'C'
  name: string
  flag: number
}

type Nodes = NodeA | NodeB | NodeC

type ReplacedNodes = ReplaceKeys<
  Nodes,
  'name' | 'flag',
  { name: number, flag: string }
> // {type: 'A', name: number, flag: string} | {type: 'B', id: number, flag: string} | {type: 'C', name: number, flag: string} // would replace name from string to number, replace flag from number to string.

type ReplacedNotExistKeys = ReplaceKeys<Nodes, 'name', { aa: number }> // {type: 'A', name: never, flag: number} | NodeB | {type: 'C', name: never, flag: number} // would replace name to never
```

## 解题思路

待补充

## 答案

```ts
type ReplaceKeys<U, T, Y> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface NodeA {
  type: 'A'
  name: string
  flag: number
}

interface NodeB {
  type: 'B'
  id: number
  flag: number
}

interface NodeC {
  type: 'C'
  name: string
  flag: number
}

interface ReplacedNodeA {
  type: 'A'
  name: number
  flag: string
}

interface ReplacedNodeB {
  type: 'B'
  id: number
  flag: string
}

interface ReplacedNodeC {
  type: 'C'
  name: number
  flag: string
}

interface NoNameNodeA {
  type: 'A'
  flag: number
  name: never
}

interface NoNameNodeC {
  type: 'C'
  flag: number
  name: never
}

type Nodes = NodeA | NodeB | NodeC
type ReplacedNodes = ReplacedNodeA | ReplacedNodeB | ReplacedNodeC
type NodesNoName = NoNameNodeA | NoNameNodeC | NodeB

type cases = [
  Expect<Equal<ReplaceKeys<Nodes, 'name' | 'flag', { name: number, flag: string }>, ReplacedNodes>>,
  Expect<Equal<ReplaceKeys<Nodes, 'name', { aa: number }>, NodesNoName>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/RequiredByKeys/index.md
---
# RequiredByKeys
## 题目

实现一个通用的`RequiredByKeys<T, K>`，它接收两个类型参数`T`和`K`。

`K`指定应设为必选的`T`的属性集。当没有提供`K`时，它就和普通的`Required<T>`一样使所有的属性成为必选的。

例如:

```ts
interface User {
  name?: string
  age?: number
  address?: string
}

type UserRequiredName = RequiredByKeys<User, 'name'> // { name: string; age?: number; address?: string }
```

## 解题思路

待补充

## 答案

```ts
type RequiredByKeys<T, K> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface User {
  name?: string
  age?: number
  address?: string
}

interface UserRequiredName {
  name: string
  age?: number
  address?: string
}

interface UserRequiredNameAndAge {
  name: string
  age: number
  address?: string
}

type cases = [
  Expect<Equal<RequiredByKeys<User, 'name'>, UserRequiredName>>,
  Expect<Equal<RequiredByKeys<User, 'name' | 'age'>, UserRequiredNameAndAge>>,
  Expect<Equal<RequiredByKeys<User>, Required<User>>>,
  // @ts-expect-error
  Expect<Equal<RequiredByKeys<User, 'name' | 'unknown'>, UserRequiredName>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Reverse/index.md
---
# Reverse
## 题目

实现类型版本的数组反转 `Array.reverse`

例如：

```typescript
type a = Reverse<['a', 'b']> // ['b', 'a']
type b = Reverse<['a', 'b', 'c']> // ['c', 'b', 'a']
```

## 解题思路

待补充

## 答案

```ts
type Reverse<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Reverse<[]>, []>>,
  Expect<Equal<Reverse<['a', 'b']>, ['b', 'a']>>,
  Expect<Equal<Reverse<['a', 'b', 'c']>, ['c', 'b', 'a']>>,
]

type errors = [
  // @ts-expect-error
  Reverse<'string'>,
  // @ts-expect-error
  Reverse<{ key: 'value' }>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Shift/index.md
---
# Shift
## 题目

Implement the type version of `Array.shift`

For example

```typescript
type Result = Shift<[3, 2, 1]> // [2, 1]
```

## 解题思路

待补充

## 答案

```ts
type Shift<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  // @ts-expect-error
  Shift<unknown>,
  Expect<Equal<Shift<[]>, []>>,
  Expect<Equal<Shift<[1]>, []>>,
  Expect<Equal<Shift<[3, 2, 1]>, [2, 1]>>,
  Expect<Equal<Shift<['a', 'b', 'c', 'd']>, ['b', 'c', 'd']>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Square/index.md
---
# Square
## 题目

Given a number, your type should return its square.

## 解题思路

待补充

## 答案

```ts
type Square<N extends number> = number
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Square<0>, 0>>,
  Expect<Equal<Square<1>, 1>>,
  Expect<Equal<Square<3>, 9>>,
  Expect<Equal<Square<20>, 400>>,
  Expect<Equal<Square<100>, 10000>>,
  Expect<Equal<Square<101>, 10201>>,

  // Negative numbers
  Expect<Equal<Square<-2>, 4>>,
  Expect<Equal<Square<-5>, 25>>,
  Expect<Equal<Square<-31>, 961>>,
  Expect<Equal<Square<-50>, 2500>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/StartsWith/index.md
---
# StartsWith
## 题目

实现`StartsWith<T, U>`,接收两个string类型参数,然后判断`T`是否以`U`开头,根据结果返回`true`或`false`

例如:

```typescript
type a = StartsWith<'abc', 'ac'> // expected to be false
type b = StartsWith<'abc', 'ab'> // expected to be true
type c = StartsWith<'abc', 'abcd'> // expected to be false
```

## 解题思路

待补充

## 答案

```ts
type StartsWith<T extends string, U extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<StartsWith<'abc', 'ac'>, false>>,
  Expect<Equal<StartsWith<'abc', 'ab'>, true>>,
  Expect<Equal<StartsWith<'abc', 'abc'>, true>>,
  Expect<Equal<StartsWith<'abc', 'abcd'>, false>>,
  Expect<Equal<StartsWith<'abc', ''>, true>>,
  Expect<Equal<StartsWith<'abc', ' '>, false>>,
  Expect<Equal<StartsWith<'', ''>, true>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/String-to-Union/index.md
---
# String to Union
## 题目

实现一个将接收到的String参数转换为一个字母Union的类型。

例如

```ts
type Test = '123'
type Result = StringToUnion<Test> // expected to be "1" | "2" | "3"
```

## 解题思路

待补充

## 答案

```ts
type StringToUnion<T extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<StringToUnion<''>, never>>,
  Expect<Equal<StringToUnion<'t'>, 't'>>,
  Expect<Equal<StringToUnion<'hello'>, 'h' | 'e' | 'l' | 'l' | 'o'>>,
  Expect<Equal<StringToUnion<'coronavirus'>, 'c' | 'o' | 'r' | 'o' | 'n' | 'a' | 'v' | 'i' | 'r' | 'u' | 's'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Subsequence/index.md
---
# Subsequence
## 题目

Given an array of unique elements, return all possible subsequences.

A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.

For example:

```typescript
type A = Subsequence<[1, 2]> // [] | [1] | [2] | [1, 2]
```

## 解题思路

待补充

## 答案

```ts
type Subsequence<T extends any[]> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Subsequence<[1, 2]>, [] | [1] | [2] | [1, 2]>>,
  Expect<Equal<Subsequence<[1, 2, 3]>, [] | [1] | [2] | [1, 2] | [3] | [1, 3] | [2, 3] | [1, 2, 3]>>,
  Expect<Equal<Subsequence<[1, 2, 3, 4, 5]>, []
  | [1] | [2] | [3] | [4] | [5]
  | [1, 2] | [1, 3] | [1, 4] | [1, 5] | [2, 3] | [2, 4] | [2, 5] | [3, 4] | [3, 5] | [4, 5]
  | [1, 2, 3] | [1, 2, 4] | [1, 2, 5] | [1, 3, 4] | [1, 3, 5] | [1, 4, 5] | [2, 3, 4] | [2, 3, 5] | [2, 4, 5] | [3, 4, 5]
  | [1, 2, 3, 4] | [1, 2, 3, 5] | [1, 2, 4, 5] | [1, 3, 4, 5] | [2, 3, 4, 5]
  | [1, 2, 3, 4, 5]>>,
  Expect<Equal<Subsequence<['a', 'b', 'c']>, []
  | ['a'] | ['b'] | ['c']
  | ['a', 'b'] | ['a', 'c'] | ['b', 'c']
  | ['a', 'b', 'c']>>,
  Expect<Equal<Subsequence<['x', 'y']>, []
  | ['x'] | ['y']
  | ['x', 'y']>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/ToPrimitive/index.md
---
# ToPrimitive
## 题目

// 将类型为字面类型（标签类型）的属性，转换为基本类型。

type PersonInfo = {
name: 'Tom',
age: 30,
married: false,
addr: {
home: '123456',
phone: '13111111111'
}
}

// 要求结果如下：
type PersonInfo = {
name: string,
age: number,
married: boolean,
addr: {
home: string,
phone: string
}
}

## 解题思路

待补充

## 答案

```ts
type ToPrimitive = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface PersonInfo {
  name: 'Tom'
  age: 30
  married: false
  addr: {
    home: '123456'
    phone: '13111111111'
  }
  hobbies: ['sing', 'dance']
  readonlyArr: readonly ['test']
  fn: () => any
}

interface ExpectedResult {
  name: string
  age: number
  married: boolean
  addr: {
    home: string
    phone: string
  }
  hobbies: [string, string]
  readonlyArr: readonly [string]
  fn: Function
}

type cases = [
  Expect<Equal<ToPrimitive<PersonInfo>, ExpectedResult>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Tower-of-hanoi/index.md
---
# Tower of hanoi
## 题目

Simulate the solution for the Tower of Hanoi puzzle. Your type should take the number of rings as input an return an array of steps to move the rings from tower A to tower B using tower C as additional. Each entry in the array should be a pair of strings `[From, To]` which denotes ring being moved `From -> To`.

[Wikipedia](https://en.wikipedia.org/wiki/Tower_of_Hanoi)
[GeeksForGeeks](https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi)

## 解题思路

待补充

## 答案

```ts
type Hanoi<N extends number, From = 'A', To = 'B', Intermediate = 'C'> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type Tests = [
  Expect<Equal<Hanoi<0>, []>>,
  Expect<Equal<Hanoi<1>, [['A', 'B']]>>,
  Expect<Equal<Hanoi<2>, [['A', 'C'], ['A', 'B'], ['C', 'B']]>>,
  Expect<Equal<Hanoi<3>, [['A', 'B'], ['A', 'C'], ['B', 'C'], ['A', 'B'], ['C', 'A'], ['C', 'B'], ['A', 'B']]>>,
  Expect<Equal<Hanoi<5>, [['A', 'B'], ['A', 'C'], ['B', 'C'], ['A', 'B'], ['C', 'A'], ['C', 'B'], ['A', 'B'], ['A', 'C'], ['B', 'C'], ['B', 'A'], ['C', 'A'], ['B', 'C'], ['A', 'B'], ['A', 'C'], ['B', 'C'], ['A', 'B'], ['C', 'A'], ['C', 'B'], ['A', 'B'], ['C', 'A'], ['B', 'C'], ['B', 'A'], ['C', 'A'], ['C', 'B'], ['A', 'B'], ['A', 'C'], ['B', 'C'], ['A', 'B'], ['C', 'A'], ['C', 'B'], ['A', 'B']]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Trace/index.md
---
# Trace
## 题目

The trace of a square matrix is the sum of the elements on its main diagonal.
However, it's difficult to calculate the sum with type system.
To make things simple, let's return the elements on the main diagonal with union type.

For example:

```ts
type Arr = [
  [1, 2],
  [3, 4]
]
type Test = Trace<Arr> // expected to be 1 | 4
```

## 解题思路

待补充

## 答案

```ts
type Trace<T extends any[][]> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Trace<[[1, 2], [3, 4]]>, 1 | 4>>,
  Expect<Equal<Trace<[[0, 1, 1], [2, 0, 2], [3, 3, 0]]>, 0>>,
  Expect<Equal<Trace<[['a', 'b', ''], ['c', '', ''], ['d', 'e', 'f']]>, 'a' | '' | 'f'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Transpose/index.md
---
# Transpose
## 题目

The transpose of a matrix is an operator which flips a matrix over its diagonal; that is, it switches the row and column indices of the matrix A by producing another matrix, often denoted by AT.

```ts
type Matrix = Transpose <[[1]]> // expected to be [[1]]
type Matrix1 = Transpose <[[1, 2], [3, 4]]> // expected to be [[1, 3], [2, 4]]
type Matrix2 = Transpose <[[1, 2, 3], [4, 5, 6]]> // expected to be [[1, 4], [2, 5], [3, 6]]
```

## 解题思路

待补充

## 答案

```ts
type Transpose<M extends number[][]> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Transpose<[]>, []>>,
  Expect<Equal<Transpose<[[1]]>, [[1]]>>,
  Expect<Equal<Transpose<[[1, 2]]>, [[1], [2]]>>,
  Expect<Equal<Transpose<[[1, 2], [3, 4]]>, [[1, 3], [2, 4]]>>,
  Expect<Equal<Transpose<[[1, 2, 3], [4, 5, 6]]>, [[1, 4], [2, 5], [3, 6]]>>,
  Expect<Equal<Transpose<[[1, 4], [2, 5], [3, 6]]>, [[1, 2, 3], [4, 5, 6]]>>,
  Expect<Equal<Transpose<[[1, 2, 3], [4, 5, 6], [7, 8, 9]]>, [[1, 4, 7], [2, 5, 8], [3, 6, 9]]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Triangular-number/index.md
---
# Triangular number
## 题目

Given a number N, find the Nth triangular number, i.e. `1 + 2 + 3 + ... + N`

## 解题思路

待补充

## 答案

```ts
type Triangular<N extends number> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Triangular<0>, 0>>,
  Expect<Equal<Triangular<1>, 1>>,
  Expect<Equal<Triangular<3>, 6>>,
  Expect<Equal<Triangular<10>, 55>>,
  Expect<Equal<Triangular<20>, 210>>,
  Expect<Equal<Triangular<55>, 1540>>,
  Expect<Equal<Triangular<100>, 5050>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Trim-Left/index.md
---
# Trim Left
## 题目

实现 `TrimLeft<T>` ，它接收确定的字符串类型并返回一个新的字符串，其中新返回的字符串删除了原字符串开头的空白字符串。

例如

```ts
type trimmed = TrimLeft<'  Hello World  '> // 应推导出 'Hello World  '
```

## 解题思路

待补充

## 答案

```ts
type TrimLeft<S extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<TrimLeft<'str'>, 'str'>>,
  Expect<Equal<TrimLeft<' str'>, 'str'>>,
  Expect<Equal<TrimLeft<'     str'>, 'str'>>,
  Expect<Equal<TrimLeft<'     str     '>, 'str     '>>,
  Expect<Equal<TrimLeft<'   \n\t foo bar '>, 'foo bar '>>,
  Expect<Equal<TrimLeft<''>, ''>>,
  Expect<Equal<TrimLeft<' \n\t'>, ''>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Trim-Right/index.md
---
# Trim Right
## 题目

实现 `TrimRight<T>` ，它接收确定的字符串类型并返回一个新的字符串，其中新返回的字符串删除了原字符串结尾的空白字符串。

例如

```ts
type Trimmed = TrimRight<'  Hello World  '> // 应推导出 '  Hello World'
```

## 解题思路

待补充

## 答案

```ts
type TrimRight<S extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<TrimRight<'str'>, 'str'>>,
  Expect<Equal<TrimRight<'str '>, 'str'>>,
  Expect<Equal<TrimRight<'str     '>, 'str'>>,
  Expect<Equal<TrimRight<'     str     '>, '     str'>>,
  Expect<Equal<TrimRight<'   foo bar  \n\t '>, '   foo bar'>>,
  Expect<Equal<TrimRight<''>, ''>>,
  Expect<Equal<TrimRight<'\n\t '>, ''>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Trim/index.md
---
# Trim
## 题目

实现`Trim<T>`，它接受一个明确的字符串类型，并返回一个新字符串，其中两端的空白符都已被删除。

例如

```ts
type trimmed = Trim<'  Hello World  '> // expected to be 'Hello World'
```

## 解题思路

待补充

## 答案

```ts
type Trim<S extends string> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Trim<'str'>, 'str'>>,
  Expect<Equal<Trim<' str'>, 'str'>>,
  Expect<Equal<Trim<'     str'>, 'str'>>,
  Expect<Equal<Trim<'str   '>, 'str'>>,
  Expect<Equal<Trim<'     str     '>, 'str'>>,
  Expect<Equal<Trim<'   \n\t foo bar \t'>, 'foo bar'>>,
  Expect<Equal<Trim<''>, ''>>,
  Expect<Equal<Trim<' \n\t '>, ''>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Trunc/index.md
---
# Trunc
## 题目

Implement the type version of `Math.trunc`, which takes string or number and returns the integer part of a number by removing any fractional digits.

For example:

```typescript
type A = Trunc<12.34> // 12
```

## 解题思路

待补充

## 答案

```ts
type Trunc = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Trunc<0.1>, '0'>>,
  Expect<Equal<Trunc<0.2>, '0'>>,
  Expect<Equal<Trunc<1.234>, '1'>>,
  Expect<Equal<Trunc<12.345>, '12'>>,
  Expect<Equal<Trunc<-5.1>, '-5'>>,
  Expect<Equal<Trunc<'.3'>, '0'>>,
  Expect<Equal<Trunc<'1.234'>, '1'>>,
  Expect<Equal<Trunc<'-.3'>, '-0'>>,
  Expect<Equal<Trunc<'-10.234'>, '-10'>>,
  Expect<Equal<Trunc<10>, '10'>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Tuple-to-Nested-Object/index.md
---
# Tuple to Nested Object
## 题目

Given a tuple type `T` that only contains string type, and a type `U`, build an object recursively.

```typescript
type a = TupleToNestedObject<['a'], string> // {a: string}
type b = TupleToNestedObject<['a', 'b'], number> // {a: {b: number}}
type c = TupleToNestedObject<[], boolean> // boolean. if the tuple is empty, just return the U type
```

## 解题思路

待补充

## 答案

```ts
type TupleToNestedObject<T, U> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<TupleToNestedObject<['a'], string>, { a: string }>>,
  Expect<Equal<TupleToNestedObject<['a', 'b'], number>, { a: { b: number } }>>,
  Expect<Equal<TupleToNestedObject<['a', 'b', 'c'], boolean>, { a: { b: { c: boolean } } }>>,
  Expect<Equal<TupleToNestedObject<[], boolean>, boolean>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Tuple-to-Union/index.md
---
# Tuple to Union
## 题目

实现泛型`TupleToUnion<T>`，它返回元组所有值的合集。

例如

```ts
type Arr = ['1', '2', '3']

type Test = TupleToUnion<Arr> // expected to be '1' | '2' | '3'
```

## 解题思路

待补充

## 答案

```ts
type TupleToUnion<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<TupleToUnion<[123, '456', true]>, 123 | '456' | true>>,
  Expect<Equal<TupleToUnion<[123]>, 123>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Type-Lookup/index.md
---
# Type Lookup
## 题目

有时，您可能希望根据某个属性在联合类型中查找类型。

在此挑战中，我们想通过在联合类型`Cat | Dog`中通过指定公共属性`type`的值来获取相应的类型。换句话说，在以下示例中，`LookUp<Dog | Cat, 'dog'>`的结果应该是`Dog`，`LookUp<Dog | Cat, 'cat'>`的结果应该是`Cat`。

```ts
interface Cat {
  type: 'cat'
  breeds: 'Abyssinian' | 'Shorthair' | 'Curl' | 'Bengal'
}

interface Dog {
  type: 'dog'
  breeds: 'Hound' | 'Brittany' | 'Bulldog' | 'Boxer'
  color: 'brown' | 'white' | 'black'
}

type MyDog = LookUp<Cat | Dog, 'dog'> // expected to be `Dog`
```

## 解题思路

待补充

## 答案

```ts
type LookUp<U, T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

interface Cat {
  type: 'cat'
  breeds: 'Abyssinian' | 'Shorthair' | 'Curl' | 'Bengal'
}

interface Dog {
  type: 'dog'
  breeds: 'Hound' | 'Brittany' | 'Bulldog' | 'Boxer'
  color: 'brown' | 'white' | 'black'
}

type Animal = Cat | Dog

type cases = [
  Expect<Equal<LookUp<Animal, 'dog'>, Dog>>,
  Expect<Equal<LookUp<Animal, 'cat'>, Cat>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Unique/index.md
---
# Unique
## 题目

实现类型版本的 Lodash.uniq 方法, `Unique<T>` 接收数组类型 T, 返回去重后的数组类型.

```ts
type Res = Unique<[1, 1, 2, 2, 3, 3]> // expected to be [1, 2, 3]
type Res1 = Unique<[1, 2, 3, 4, 4, 5, 6, 7]> // expected to be [1, 2, 3, 4, 5, 6, 7]
type Res2 = Unique<[1, 'a', 2, 'b', 2, 'a']> // expected to be [1, "a", 2, "b"]
type Res3 = Unique<[string, number, 1, 'a', 1, string, 2, 'b', 2, number]> // expected to be [string, number, 1, "a", 2, "b"]
type Res4 = Unique<[unknown, unknown, any, any, never, never]> // expected to be [unknown, any, never]
```

## 解题思路

待补充

## 答案

```ts
type Unique<T> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Unique<[1, 1, 2, 2, 3, 3]>, [1, 2, 3]>>,
  Expect<Equal<Unique<[1, 2, 3, 4, 4, 5, 6, 7]>, [1, 2, 3, 4, 5, 6, 7]>>,
  Expect<Equal<Unique<[1, 'a', 2, 'b', 2, 'a']>, [1, 'a', 2, 'b']>>,
  Expect<Equal<Unique<[string, number, 1, 'a', 1, string, 2, 'b', 2, number]>, [string, number, 1, 'a', 2, 'b']>>,
  Expect<Equal<Unique<[unknown, unknown, any, any, never, never]>, [unknown, any, never]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Without/index.md
---
# Without
## 题目

实现一个像 Lodash.without 函数一样的泛型 `Without<T, U>`，它接收数组类型的 T 和数字或数组类型的 U 为参数，会返回一个去除 U 中元素的数组 T。

例如：

```ts
type Res = Without<[1, 2], 1> // expected to be [2]
type Res1 = Without<[1, 2, 4, 1, 5], [1, 2]> // expected to be [4, 5]
type Res2 = Without<[2, 3, 2, 3, 2, 3, 2, 3], [2, 3]> // expected to be []
```

## 解题思路

待补充

## 答案

```ts
type Without<T, U> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Without<[1, 2], 1>, [2]>>,
  Expect<Equal<Without<[1, 2, 4, 1, 5], [1, 2]>, [4, 5]>>,
  Expect<Equal<Without<[2, 3, 2, 3, 2, 3, 2, 3], [2, 3]>, []>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/medium/Zip/index.md
---
# Zip
## 题目

In This Challenge, You should implement a type `Zip<T, U>`, T and U must be `Tuple`

```ts
type exp = Zip<[1, 2], [true, false]> // expected to be [[1, true], [2, false]]
```

## 解题思路

待补充

## 答案

```ts
type Zip<T, U> = any
```

## 验证

```ts
import type { Equal, Expect } from '@type-challenges/utils'

type cases = [
  Expect<Equal<Zip<[], []>, []>>,
  Expect<Equal<Zip<[1, 2], [true, false]>, [[1, true], [2, false]]>>,
  Expect<Equal<Zip<[1, 2, 3], ['1', '2']>, [[1, '1'], [2, '2']]>>,
  Expect<Equal<Zip<[], [1, 2, 3]>, []>>,
  Expect<Equal<Zip<[[1, 2]], [3]>, [[[1, 2], 3]]>>,
]
```

## 参考

无

---

---
url: /TypeGymnastics/warm/Hello-World/index.md
---
# Hello World
## 题目

Hello, World!

这个简单的提问希望让你可以快速上手 Type Challenges。在这里，我们使用了一些神奇的技巧让 TypeScript 通过自身的类型系统来实现自动判题。

在这个挑战中，你需要修改下方的代码使得测试通过（使其没有类型错误）。

```ts
// 期望是一个 string 类型
type HelloWorld = any

// 你需要使得如下这行不会抛出异常
type test = Expect<Equal<HelloWorld, string>>
```

## 解题思路

显然，`HelloWorld` 即为 `string` 类型。

## 答案

```ts
type HelloWorld = string // expected to be a string
```

## 验证

```ts twoslash
import { Equal, Expect } from '@type-challenges/utils'
type HelloWorld = string
// ---cut---
type test = Expect<Equal<HelloWorld, string>>
```

## 参考

无
