import{a,c as p,e as c,o}from"./app-BjK21BRJ.js";const t={};function i(r,e){return o(),p("div",null,[...e[0]||(e[0]=[c('<div class="hint-container tip"><p class="hint-container-title">提问</p><ol><li>对 webpack 的了解</li><li>webpack 的工作原理</li><li>loader 和 plugin 有什么区别</li><li>webpack 优化</li></ol></div><h2 id="webpack" tabindex="-1"><a class="header-anchor" href="#webpack"><span>webpack</span></a></h2><p>webpack 是一个用于现代 javascript 应用程序的静态打包工具。</p><h2 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理"><span>工作原理</span></a></h2><ol><li>读取<code>webpack</code>配置参数</li><li>启动<code>webpack</code>，创建<code>compiler</code>对象，开始解析项目</li><li>从入口文件<code>entry</code>开始解析，并找到其导入的<strong>依赖模块</strong>，递归遍历分析，形成<strong>依赖关系树</strong></li><li>对不同的文件类型资源的依赖模块文件，使用对应的<code>Loader</code>进行转换，最终转为<code>webpack</code>的有效模块</li><li>在编译过程中，<code>webpack</code>通过<strong>发布订阅模式</strong>，向外抛出一些<code>hooks</code>，<code>webpack</code>的<code>Plugin</code>通过监听各个<code>hooks</code>， 执行插件任务，扩展<code>webpack</code>的功能，干预输出结果</li><li>根据输出配置<code>output</code>，将打包构建好的资源文件输出</li></ol><h2 id="loader" tabindex="-1"><a class="header-anchor" href="#loader"><span>loader</span></a></h2><p>将其他类型的资源文件转换为 webpack 能够处理的有效模块。</p><h2 id="plugin" tabindex="-1"><a class="header-anchor" href="#plugin"><span>plugin</span></a></h2><p>plugin 是 webpack 的核心功能，其目的是在于解决 loader 无法解决的其他事上。</p><p>plugin 可以在 webpack 访问到 webpack 的整个生命周期，并且可以访问到 compile 对象，以及当前编译过程对象<code>compilation</code>, 这使得 plugin 拥有非常强大的能力。</p><h2 id="loader-和-plugin-的区别" tabindex="-1"><a class="header-anchor" href="#loader-和-plugin-的区别"><span>loader 和 plugin 的区别</span></a></h2><p>loader 仅能对其关联的模块类型进行解析转换，不能访问到 webpack 的整个生命周期</p><p>plugin 是对 webpack 的扩展，可以访问到 webpack 整个生命周期。</p><h2 id="webpack-优化" tabindex="-1"><a class="header-anchor" href="#webpack-优化"><span>webpack 优化</span></a></h2><p>以下内容是针对<code>webpack@5</code>的优化方向建议：</p><h3 id="构建流程分析" tabindex="-1"><a class="header-anchor" href="#构建流程分析"><span>构建流程分析</span></a></h3><p>在进行优化前，首先要搞清楚有哪些地方出现了痛点，需要进行优化。</p><ul><li><p>编译速度分析</p><p>借助<code>speed-measure-webpack-plugin</code>插件，可以帮助我们获取插件、loader 的耗时。 消耗时间比较长的，认为可以优化的，则放到优化计划中。</p></li><li><p>打包体积分析</p><p>借助<code>webpack-bundle-analyzer</code>插件，可以帮助我们获取打包后生成的 bundle 的体积中，各个模块的位置、体积等信息。</p></li></ul><h3 id="编译速度优化" tabindex="-1"><a class="header-anchor" href="#编译速度优化"><span>编译速度优化</span></a></h3><ol><li><p>配置缓存方案。</p><p>在 webpack 的配置文件中 声明 配置：<code>{ cache: { type: &#39;filesystem } }</code>,来启用对模块和 chunk 的持久缓存。 可以大幅度优化 二次启动构建速度、打包速度等。</p></li><li><p>对使用的 loader，根据其作用，指定 include 或者 exclude，减少 loader 的应用范围。</p></li><li><p>管理资源</p><p>使用 webpack5 内置的<code>asset/resource</code>代替<code>assets loader</code>(如， url-loader、file-loader、raw-loader)。</p></li><li><p>多进程打包编译</p><p>使用<code>thread-loader</code>将耗时长的 loader 进行包装，放到其他的线程中进行处理。</p></li></ol><h3 id="打包体积优化" tabindex="-1"><a class="header-anchor" href="#打包体积优化"><span>打包体积优化</span></a></h3><p>重复多次出现的模块，可以抽到共享 chunk 中，非首屏加载必须的模块，可以抽到异步 chunk 中。</p><p>（还有对各种资源进行压缩等）</p>',23)])])}const n=a(t,[["render",i]]),d=JSON.parse('{"path":"/interview/webpack/","title":"webpack","lang":"zh-CN","frontmatter":{"title":"webpack","createTime":"2025/03/14 10:24:27","permalink":"/interview/webpack/","description":"提问 对 webpack 的了解 webpack 的工作原理 loader 和 plugin 有什么区别 webpack 优化 webpack webpack 是一个用于现代 javascript 应用程序的静态打包工具。 工作原理 读取webpack配置参数 启动webpack，创建compiler对象，开始解析项目 从入口文件entry开始解析，并...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"webpack\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-02-12T02:59:48.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://blog.l0v3ch4n.top/interview/webpack/"}],["meta",{"property":"og:site_name","content":"L0v3ch4n"}],["meta",{"property":"og:title","content":"webpack"}],["meta",{"property":"og:description","content":"提问 对 webpack 的了解 webpack 的工作原理 loader 和 plugin 有什么区别 webpack 优化 webpack webpack 是一个用于现代 javascript 应用程序的静态打包工具。 工作原理 读取webpack配置参数 启动webpack，创建compiler对象，开始解析项目 从入口文件entry开始解析，并..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-12T02:59:48.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-12T02:59:48.000Z"}]]},"readingTime":{"minutes":2.44,"words":731},"git":{"createdTime":1741936139000,"updatedTime":1770865188000,"contributors":[{"name":"Cuber-Wei","username":"Cuber-Wei","email":"cuberwei0@163.com","commits":4,"avatar":"https://avatars.githubusercontent.com/Cuber-Wei?v=4","url":"https://github.com/Cuber-Wei"}]},"autoDesc":true,"filePathRelative":"interview/tools/02-webpack.md","headers":[]}');export{n as comp,d as data};
