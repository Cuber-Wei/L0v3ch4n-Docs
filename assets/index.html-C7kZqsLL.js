import{a,c as i,e as s,o as t}from"./app-BjK21BRJ.js";const n={};function p(r,e){return t(),i("div",null,[...e[0]||(e[0]=[s(`<div class="hint-container tip"><p class="hint-container-title">提问</p><ol><li>请说说浏览器渲染页面的过程</li></ol></div><p>浏览器在拿到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出渲染任务开始渲染流程。</p><h2 id="渲染流程" tabindex="-1"><a class="header-anchor" href="#渲染流程"><span>渲染流程</span></a></h2><p>整个渲染流程分为多个阶段： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、展示。</p><p>每个阶段都有明确的输入和输出，形成一套严密的生产流水线。</p><h2 id="解析-html" tabindex="-1"><a class="header-anchor" href="#解析-html"><span>解析 HTML</span></a></h2><div class="language-" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>输入：HTML文档</span></span>
<span class="line"><span>输出：DOM树、CSSOM树</span></span></code></pre></div><p>解析 HTML 过程中遇到 CSS 会解析 CSS，遇到 JS 会执行 JS。为了提高效率，浏览器在开始解析前会启动预解析线程，先行下载 HTML 中用到的外部的 CSS、JS 文件。</p><p>下载和解析 CSS 文件的工作是在预解析线程中进行的，所以 CSS 解析不会阻塞主线程。</p><p>而 JS 执行可能会影响 DOM 树，因此执行 JS 时主线程会被阻塞。</p><p>本阶段完成后，会得到 DOM 树和 CSSOM 树，浏览器默认样式、内部样式、行内样式均会包含在 CSSOM 树中。</p><h2 id="样式计算" tabindex="-1"><a class="header-anchor" href="#样式计算"><span>样式计算</span></a></h2><div class="language-" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>输入：DOM树、CSSOM树</span></span>
<span class="line"><span>输出：带样式的DOM树</span></span></code></pre></div><p>主线程会一次遍历 DOM 树，为树中每个节点计算出最终样式（Computed Style）。</p><p>这一过程中，很多预设值会转变成绝对值，相对单位会转变成绝对单位。</p><p>这一阶段完成后，会得到一棵带样式的 DOM 树。</p><h2 id="布局" tabindex="-1"><a class="header-anchor" href="#布局"><span>布局</span></a></h2><div class="language-" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>输入：带样式的DOM树</span></span>
<span class="line"><span>输出：布局树</span></span></code></pre></div><p>依次遍历 DOM 树的每一节点，计算节点几何信息（宽高、相对包含快的位置）。</p><div class="hint-container note"><p class="hint-container-title">提示</p><p>大部分时候，布局树和 DOM 树并非一一对对应。</p><p>比如 <code>display: none</code> 的节点没有几何信息，因此不会生成到布局树；又如伪元素选择器，虽然 DOM 书中不存在这些伪元素节点，但是他们拥有几何信息， 因此会被天机道布局树中。</p></div><p>本阶段完成后会产生一棵布局树。</p><h2 id="分层" tabindex="-1"><a class="header-anchor" href="#分层"><span>分层</span></a></h2><p>主线程会根据库一套复杂的策略对整个布局树进行分层。</p><p>分层的优势在于：将来某一层改变后，仅会对该层进行处理，提升效率。</p><p>可能影响分层的事物：</p><ol><li>滚动条</li><li>堆叠上下文</li><li>transform</li><li>opacity</li><li>will-change 属性</li></ol><h2 id="绘制" tabindex="-1"><a class="header-anchor" href="#绘制"><span>绘制</span></a></h2><p>对每一层生成绘制指令集，描述如何绘制该层内容。</p><h2 id="分块" tabindex="-1"><a class="header-anchor" href="#分块"><span>分块</span></a></h2><p>完成分层后，主线程将信息提交给合成线程，剩余工作在合成线程中完成。</p><p>合成线程先将每个图层分块，划分成更多的小区域。</p><h2 id="光栅化" tabindex="-1"><a class="header-anchor" href="#光栅化"><span>光栅化</span></a></h2><p>将每个快变成位图，<strong>优先处理靠近视口的分块</strong>。</p><h2 id="展示" tabindex="-1"><a class="header-anchor" href="#展示"><span>展示</span></a></h2><p>最后调用 GPU 硬件将页面渲染到屏幕上。</p>`,35)])])}const l=a(n,[["render",p]]),c=JSON.parse('{"path":"/interview/BrowserRender/","title":"浏览器渲染原理","lang":"zh-CN","frontmatter":{"title":"浏览器渲染原理","createTime":"2025/03/14 14:11:04","permalink":"/interview/BrowserRender/","description":"提问 请说说浏览器渲染页面的过程 浏览器在拿到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出渲染任务开始渲染流程。 渲染流程 整个渲染流程分为多个阶段： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、展示。 每个阶段都有明确的输入和输出，形成一套严密的生产流水线。 解析 HT...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"浏览器渲染原理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-02-12T02:59:48.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://blog.l0v3ch4n.top/interview/BrowserRender/"}],["meta",{"property":"og:site_name","content":"L0v3ch4n"}],["meta",{"property":"og:title","content":"浏览器渲染原理"}],["meta",{"property":"og:description","content":"提问 请说说浏览器渲染页面的过程 浏览器在拿到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出渲染任务开始渲染流程。 渲染流程 整个渲染流程分为多个阶段： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、展示。 每个阶段都有明确的输入和输出，形成一套严密的生产流水线。 解析 HT..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-12T02:59:48.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-12T02:59:48.000Z"}]]},"readingTime":{"minutes":2.56,"words":769},"git":{"createdTime":1741936139000,"updatedTime":1770865188000,"contributors":[{"name":"Cuber-Wei","username":"Cuber-Wei","email":"cuberwei0@163.com","commits":4,"avatar":"https://avatars.githubusercontent.com/Cuber-Wei?v=4","url":"https://github.com/Cuber-Wei"}]},"autoDesc":true,"filePathRelative":"interview/browser/02-浏览器渲染原理.md","headers":[]}');export{l as comp,c as data};
