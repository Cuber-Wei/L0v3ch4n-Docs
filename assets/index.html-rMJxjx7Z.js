import{_ as t,c as o,a as r,o as a}from"./app-mXHhDMsf.js";const n={};function i(p,e){return a(),o("div",null,e[0]||(e[0]=[r('<div class="hint-container tip"><p class="hint-container-title">提问</p><ol><li>请说说什么是事件循环</li><li>说说你对JS异步的理解 / JS为什么会阻碍渲染</li></ol></div><h2 id="事件循环" tabindex="-1"><a class="header-anchor" href="#事件循环"><span>事件循环</span></a></h2><p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p><p>在 Chrome 浏览器源码中，它开启一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行。其他线程产生的任务会加入到队列末尾。</p><p>具体来说，每个任务都有不同的类型，而现代浏览器中会维护多个任务队列，不同任务队列中的任务对象具有不同的类型和执行优先级。不同的浏览器 实现这一功能时有所不同（队列个数不尽相同），但是其中必定会有一条微队列，其中的任务具有最高优先级，必须优先调度执行。</p><h2 id="js异步的理解" tabindex="-1"><a class="header-anchor" href="#js异步的理解"><span>JS异步的理解</span></a></h2><p>首先，JS是一门单线程的语言——因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p><p>渲染主线程承担着渲染页面、执行JS脚本等工作，如果采用同步的运行策略，就极可能导致主线程产生阻塞，导致其他任务无法得到执行。这样会导致 主线程工作效率极低，同时导致页面无法及时更新，面向用户就是卡死。</p><p>所以浏览器采用异步的策略来避免阻塞。具体来说是在某些任务（如计时器、网络、事件监听）发生时，主线程将任务交给其他线程处理，自身立刻结束 任务执行，转而执行后续代码。当其他线程完成任务时，会把事先传递的回调函数包装成任务对象，加入到消息队列末尾等待主线程调度执行。</p><p>这种模式下，浏览器用不阻塞，从而最大程度保证了浏览器的流畅运行。</p>',10)]))}const s=t(n,[["render",i]]),m=JSON.parse('{"path":"/interview/EventLoop/","title":"事件循环","lang":"zh-CN","frontmatter":{"title":"事件循环","createTime":"2025/03/14 13:59:22","permalink":"/interview/EventLoop/","description":"提问 请说说什么是事件循环 说说你对JS异步的理解 / JS为什么会阻碍渲染 事件循环 事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。 在 Chrome 浏览器源码中，它开启一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行。其他线程产生的任务会加入到队列末尾。 具体来说，每个任务都有不同的类型，而现代浏览器中会维护多个任务队列，...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"事件循环\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-14T07:08:59.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://blog.l0v3ch4n.top/interview/EventLoop/"}],["meta",{"property":"og:site_name","content":"L0v3ch4n"}],["meta",{"property":"og:title","content":"事件循环"}],["meta",{"property":"og:description","content":"提问 请说说什么是事件循环 说说你对JS异步的理解 / JS为什么会阻碍渲染 事件循环 事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。 在 Chrome 浏览器源码中，它开启一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行。其他线程产生的任务会加入到队列末尾。 具体来说，每个任务都有不同的类型，而现代浏览器中会维护多个任务队列，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-14T07:08:59.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-14T07:08:59.000Z"}]]},"readingTime":{"minutes":1.76,"words":528},"git":{"createdTime":1741936139000,"updatedTime":1741936139000,"contributors":[{"name":"L0v3ch4n","username":"L0v3ch4n","email":"cuberwei0@163.com","commits":1,"avatar":"https://avatars.githubusercontent.com/L0v3ch4n?v=4","url":"https://github.com/L0v3ch4n"}]},"autoDesc":true,"filePathRelative":"notes/interview/browser/01-事件循环.md","headers":[]}');export{s as comp,m as data};
